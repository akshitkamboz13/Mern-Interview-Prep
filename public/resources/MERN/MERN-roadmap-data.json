{
  "id": "mern-roadmap",
  "title": "MERN Stack Interview Roadmap",
  "description": "A comprehensive, deeply nested roadmap covering every topic you need to master for MERN stack interviews. Includes JavaScript, TypeScript, React, Redux, Next.js, Node.js, Express, MongoDB, Redis, system design, testing, DevOps, and behavioral rounds — with detailed descriptions at every level.",
  "briefDescription": "Complete MERN interview preparation roadmap with 23 major topics.",
  "priority": "must",
  "children": [
    {
      "id": "interview-fundamentals",
      "title": "Interview Fundamentals & Soft Skills",
      "description": "Mastering the non-technical side of interviews is just as important as coding ability. This section covers how to present yourself, structure answers, negotiate offers, and communicate effectively in both remote and in-person interview settings. These skills differentiate good candidates from great ones.",
      "briefDescription": "Essential soft skills, communication, and interview strategy.",
      "priority": "must",
      "children": [
        {
          "id": "resume-building",
          "title": "Resume Building for MERN Roles",
          "description": "Craft a resume tailored for MERN full-stack positions. Highlight relevant projects with tech stacks (React, Node, MongoDB, Express), quantify achievements (e.g., 'reduced load time by 40%'), keep it to one page, use action verbs, and include links to GitHub and deployed projects. Tailor for ATS by matching keywords from job descriptions.",
          "briefDescription": "How to write a targeted resume for MERN developer roles.",
          "priority": "must"
        },
        {
          "id": "portfolio-github",
          "title": "Portfolio & GitHub Profile",
          "description": "Your GitHub profile and portfolio are your proof of work. Maintain a clean GitHub with pinned projects, clear READMEs, commit history, and contribution graphs. Build a portfolio site showcasing 3-5 polished MERN projects with live demos, source code links, and descriptions of challenges solved.",
          "briefDescription": "Build a standout portfolio and maintain an active GitHub presence.",
          "priority": "must"
        },
        {
          "id": "self-introduction",
          "title": "How to Introduce Yourself",
          "description": "Prepare a 60-90 second elevator pitch covering: who you are, your technical background, key technologies you work with (MERN stack), a highlight project or achievement, and what you're looking for. Keep it conversational, confident, and tailored to the company you're interviewing with.",
          "briefDescription": "Craft a concise, compelling self-introduction for interviews.",
          "priority": "must"
        },
        {
          "id": "star-method",
          "title": "STAR Method for Answers",
          "description": "The STAR method (Situation, Task, Action, Result) is a structured way to answer behavioral questions. Describe the Situation you were in, the Task you needed to accomplish, the Action you took, and the Result you achieved. Always quantify results when possible. This framework keeps answers focused and impactful.",
          "briefDescription": "Structured technique for answering behavioral interview questions.",
          "priority": "must"
        },
        {
          "id": "salary-negotiation",
          "title": "Salary Negotiation",
          "description": "Research market rates for MERN developers in your region using Glassdoor, Levels.fyi, and LinkedIn Salary. Never share your current salary first. Negotiate based on the value you bring, not your previous pay. Consider total compensation: base salary, bonuses, equity, benefits, remote flexibility. Always get offers in writing before accepting.",
          "briefDescription": "Strategies for negotiating competitive compensation packages.",
          "priority": "imp"
        },
        {
          "id": "remote-interview-tips",
          "title": "Remote Interview Tips",
          "description": "Ensure stable internet, a quiet environment, good lighting, and a professional background. Test your camera, mic, and screen sharing beforehand. Use a wired connection if possible. Have your IDE, browser, and any required tools ready. Keep water nearby. Look at the camera when speaking. Share your screen proactively during coding rounds.",
          "briefDescription": "Practical tips for succeeding in remote/virtual interviews.",
          "priority": "imp"
        },
        {
          "id": "communication-skills",
          "title": "Communication Skills",
          "description": "Clear communication is critical in technical interviews. Think out loud when solving problems so interviewers can follow your reasoning. Ask clarifying questions before diving in. Summarize your approach before coding. Use precise technical terminology. Don't be afraid to say 'I don't know' — follow up with how you'd find the answer.",
          "briefDescription": "How to communicate clearly and effectively during interviews.",
          "priority": "must"
        },
        {
          "id": "time-management-interviews",
          "title": "Time Management in Interviews",
          "description": "Most coding interviews are 45-60 minutes. Spend the first 5 minutes understanding the problem and asking questions. Spend 5 minutes planning your approach. Code for 20-25 minutes. Reserve 10 minutes for testing and edge cases. If stuck, communicate your thought process and consider a brute-force solution before optimizing.",
          "briefDescription": "How to allocate time effectively during timed interview rounds.",
          "priority": "imp"
        }
      ]
    },
    {
      "id": "cs-fundamentals",
      "title": "Computer Science Fundamentals",
      "description": "The bedrock of software engineering knowledge. Interviewers test these to gauge how well you understand what happens beneath frameworks and libraries. Covers networking, operating systems, databases, OOP, and design patterns — all essential for writing performant, reliable MERN applications.",
      "briefDescription": "Core CS concepts: networking, OS, databases, OOP, design patterns.",
      "priority": "must",
      "children": [
        {
          "id": "how-internet-works",
          "title": "How the Internet Works",
          "description": "Understanding the full journey of a web request — from typing a URL to rendering pixels — is fundamental. This covers DNS resolution, TCP connections, HTTP semantics, TLS encryption, WebSocket upgrades, and the request-response lifecycle that every MERN app relies on.",
          "briefDescription": "The complete lifecycle of a web request from browser to server.",
          "priority": "must",
          "children": [
            {
              "id": "dns-resolution",
              "title": "DNS Resolution",
              "description": "When a user types a URL, the browser must resolve the domain name to an IP address. The query travels: browser cache → OS cache → recursive resolver → root nameserver → TLD nameserver → authoritative nameserver. Understanding DNS helps debug deployment issues, configure custom domains, and optimize with DNS prefetching.",
              "briefDescription": "How domain names are translated to IP addresses.",
              "priority": "must"
            },
            {
              "id": "tcp-ip-model",
              "title": "TCP/IP Model",
              "description": "The foundational networking model with four layers: Application (HTTP, DNS), Transport (TCP, UDP), Network (IP, routing), and Link (Ethernet, WiFi). Data is encapsulated going down and decapsulated going up. Understanding this model helps you reason about latency, packet loss, and connection management.",
              "briefDescription": "Four-layer networking model underpinning all internet communication.",
              "priority": "imp",
              "children": [
                {
                  "id": "tcp-ip-layers",
                  "title": "Layers (Application, Transport, Network, Link)",
                  "description": "Application layer handles HTTP/DNS, Transport layer handles TCP/UDP with ports, Network layer handles IP addressing and routing, Link layer handles physical transmission. Each layer adds headers during encapsulation. Understanding layers helps you debug at the right level — is it a DNS issue, a routing issue, or an application bug?",
                  "briefDescription": "The four layers and their responsibilities.",
                  "priority": "imp"
                },
                {
                  "id": "three-way-handshake",
                  "title": "Three-Way Handshake",
                  "description": "TCP connections begin with a three-way handshake: (1) Client sends SYN, (2) Server responds with SYN-ACK, (3) Client sends ACK. This establishes a reliable, ordered connection. Understanding this explains connection latency and why techniques like connection pooling and keep-alive headers improve performance.",
                  "briefDescription": "SYN → SYN-ACK → ACK: how TCP connections are established.",
                  "priority": "imp"
                }
              ]
            },
            {
              "id": "http-https",
              "title": "HTTP/HTTPS",
              "description": "HTTP is the protocol for web communication. It defines methods (GET, POST, PUT, DELETE), status codes (2xx success, 4xx client error, 5xx server error), and headers. HTTPS adds TLS encryption for security. Understanding HTTP semantics is essential for building correct REST APIs and debugging network issues.",
              "briefDescription": "The protocol powering all web communication.",
              "priority": "must",
              "children": [
                {
                  "id": "http-methods",
                  "title": "HTTP Methods",
                  "description": "GET retrieves data (idempotent, cacheable). POST creates resources (not idempotent). PUT replaces entire resources (idempotent). PATCH partially updates resources. DELETE removes resources (idempotent). OPTIONS is used for CORS preflight. HEAD retrieves headers only. Knowing the correct method for each operation is essential for RESTful API design.",
                  "briefDescription": "GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD and their semantics.",
                  "priority": "must"
                },
                {
                  "id": "status-codes",
                  "title": "Status Codes",
                  "description": "1xx: Informational. 2xx: Success (200 OK, 201 Created, 204 No Content). 3xx: Redirection (301 Moved, 304 Not Modified). 4xx: Client errors (400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 422 Unprocessable, 429 Too Many Requests). 5xx: Server errors (500 Internal Error, 502 Bad Gateway, 503 Unavailable).",
                  "briefDescription": "Meaning of HTTP response status code categories.",
                  "priority": "must"
                },
                {
                  "id": "http-versions",
                  "title": "HTTP/1.1 vs HTTP/2 vs HTTP/3",
                  "description": "HTTP/1.1 uses persistent connections but suffers from head-of-line blocking. HTTP/2 adds multiplexing (multiple requests on one connection), header compression (HPACK), and server push. HTTP/3 uses QUIC (over UDP) for faster connections and eliminates TCP head-of-line blocking. Modern MERN deployments benefit from HTTP/2+ which reduce latency significantly.",
                  "briefDescription": "Evolution of HTTP protocols and their performance improvements.",
                  "priority": "look"
                },
                {
                  "id": "tls-handshake",
                  "title": "HTTPS & TLS Handshake",
                  "description": "TLS secures HTTP by encrypting data in transit. The handshake: (1) Client sends supported cipher suites, (2) Server responds with certificate and chosen cipher, (3) Key exchange creates shared secret, (4) Encrypted communication begins. TLS 1.3 reduces this to one round-trip. Essential for protecting user data and API tokens.",
                  "briefDescription": "How HTTPS encrypts communication using TLS certificates.",
                  "priority": "imp"
                }
              ]
            },
            {
              "id": "websockets",
              "title": "WebSockets",
              "description": "WebSockets provide full-duplex, persistent connections between client and server. Unlike HTTP's request-response model, WebSockets allow bi-directional real-time data flow. The connection starts as an HTTP upgrade request. Used in chat apps, live dashboards, collaborative editing, and real-time notifications in MERN apps.",
              "briefDescription": "Full-duplex persistent connections for real-time communication.",
              "priority": "imp",
              "children": [
                {
                  "id": "ws-handshake",
                  "title": "Handshake Upgrade",
                  "description": "A WebSocket connection begins with an HTTP GET request with an 'Upgrade: websocket' header. The server responds with HTTP 101 Switching Protocols. After this, both sides communicate over the same TCP connection using WebSocket frames instead of HTTP messages.",
                  "briefDescription": "How HTTP upgrades to a WebSocket connection.",
                  "priority": "look"
                },
                {
                  "id": "full-duplex",
                  "title": "Full-Duplex Communication",
                  "description": "Unlike HTTP where the client initiates every exchange, WebSockets allow both client and server to send messages independently at any time. This eliminates polling overhead and enables true real-time features like live typing indicators, price tickers, and multiplayer game state sync.",
                  "briefDescription": "Both sides can send messages independently and simultaneously.",
                  "priority": "imp"
                },
                {
                  "id": "socketio-vs-native",
                  "title": "Socket.io vs Native WebSocket",
                  "description": "Native WebSocket API is built into browsers and Node.js. Socket.io is a library that adds automatic reconnection, rooms, namespaces, broadcasting, fallback to long-polling, and binary support on top of WebSockets. Use native for simple use cases; use Socket.io for production apps needing reliability features.",
                  "briefDescription": "When to use the native API vs Socket.io library.",
                  "priority": "imp"
                }
              ]
            },
            {
              "id": "request-response-cycle",
              "title": "Request-Response Cycle",
              "description": "The full cycle: (1) User action triggers request, (2) Browser resolves DNS, (3) TCP connection established, (4) TLS handshake if HTTPS, (5) HTTP request sent, (6) Server processes request (routing → middleware → controller → database → response), (7) Response sent back, (8) Browser parses and renders. Understanding this end-to-end flow helps debug any bottleneck.",
              "briefDescription": "Complete lifecycle from user action to rendered response.",
              "priority": "must"
            }
          ]
        },
        {
          "id": "os-basics",
          "title": "Operating System Basics",
          "description": "OS concepts appear in system design questions and help you understand Node.js internals. Processes, threads, memory management, concurrency, and file systems are foundational knowledge that explains how your MERN backend actually runs on a machine.",
          "briefDescription": "Processes, threads, memory, and concurrency fundamentals.",
          "priority": "imp",
          "children": [
            {
              "id": "processes-threads",
              "title": "Processes vs Threads",
              "description": "A process is an independent program with its own memory space. A thread is a lightweight unit of execution within a process that shares memory with other threads. Node.js runs on a single thread but uses worker threads and child processes for CPU-intensive tasks. Understanding this distinction is key for Node.js performance optimization.",
              "briefDescription": "Independent programs vs lightweight execution units sharing memory.",
              "priority": "imp"
            },
            {
              "id": "concurrency-parallelism",
              "title": "Concurrency vs Parallelism",
              "description": "Concurrency is managing multiple tasks that overlap in time (Node.js event loop handles I/O concurrently on one thread). Parallelism is executing multiple tasks simultaneously on multiple CPU cores (worker_threads, cluster module). Node.js is concurrent by default; parallelism requires explicit multi-threading or multi-process setup.",
              "briefDescription": "Overlapping task management vs simultaneous execution.",
              "priority": "imp"
            },
            {
              "id": "memory-mgmt",
              "title": "Memory Management",
              "description": "The OS manages memory allocation for running programs. Understanding stack (function calls, local variables — fast, limited, auto-managed) vs heap (dynamic allocation — slower, larger, requires GC) is critical for debugging memory leaks in Node.js and understanding V8's garbage collector behavior.",
              "briefDescription": "Stack, heap, virtual memory, and garbage collection.",
              "priority": "imp",
              "children": [
                {
                  "id": "stack-heap",
                  "title": "Stack vs Heap",
                  "description": "Stack stores function call frames and local variables in LIFO order. It's fast but limited in size. Heap stores dynamically allocated objects. In JavaScript, primitives live on the stack, objects live on the heap. Stack overflow happens with deep recursion; heap issues cause memory leaks.",
                  "briefDescription": "Fast stack for calls vs flexible heap for dynamic objects.",
                  "priority": "imp"
                },
                {
                  "id": "virtual-memory",
                  "title": "Virtual Memory",
                  "description": "Virtual memory gives each process the illusion of having its own contiguous address space. The OS maps virtual addresses to physical RAM using page tables. When RAM is full, inactive pages are swapped to disk. This enables running programs larger than physical memory but swapping causes performance degradation.",
                  "briefDescription": "Abstraction that lets processes use more memory than physical RAM.",
                  "priority": "look"
                },
                {
                  "id": "paging-segmentation",
                  "title": "Paging & Segmentation",
                  "description": "Paging divides memory into fixed-size blocks (pages) for efficient allocation. Segmentation divides memory into variable-size logical segments (code, data, stack). Modern OSes use paging with segmentation for protection. Page faults occur when accessed pages aren't in RAM, triggering disk reads.",
                  "briefDescription": "Fixed-size pages vs variable-size logical segments.",
                  "priority": "skip"
                }
              ]
            },
            {
              "id": "deadlocks",
              "title": "Deadlocks",
              "description": "A deadlock occurs when two or more processes are waiting for each other to release resources, creating a circular dependency. Four conditions must hold simultaneously: mutual exclusion, hold and wait, no preemption, circular wait. Prevention strategies include resource ordering, timeout-based release, and lock-free algorithms.",
              "briefDescription": "Circular resource dependencies that freeze processes.",
              "priority": "look",
              "children": [
                {
                  "id": "deadlock-conditions",
                  "title": "Conditions for Deadlock",
                  "description": "All four must be true simultaneously: (1) Mutual Exclusion — resources can't be shared, (2) Hold and Wait — process holds one resource while waiting for another, (3) No Preemption — resources can't be forcibly taken, (4) Circular Wait — circular chain of processes each waiting for the next. Break any one condition to prevent deadlocks.",
                  "briefDescription": "The four necessary conditions for deadlocks.",
                  "priority": "look"
                },
                {
                  "id": "deadlock-prevention",
                  "title": "Prevention & Avoidance",
                  "description": "Prevention eliminates one of the four conditions (e.g., enforce resource ordering to break circular wait). Avoidance uses algorithms like Banker's Algorithm to check if granting a request leads to an unsafe state. Detection uses resource allocation graphs to find cycles, then resolves by terminating or rolling back a process.",
                  "briefDescription": "Strategies to prevent, avoid, or detect deadlocks.",
                  "priority": "skip"
                }
              ]
            },
            {
              "id": "file-systems",
              "title": "File Systems",
              "description": "File systems organize data on storage devices into files and directories. Understanding file systems helps when working with Node.js fs module, Docker volumes, and server deployments. Key concepts: inodes, file descriptors, permissions (rwx), symlinks, and how Node's fs.watch detects changes.",
              "briefDescription": "How data is organized and accessed on storage devices.",
              "priority": "look"
            }
          ]
        },
        {
          "id": "database-fundamentals",
          "title": "Database Fundamentals",
          "description": "Core database theory that applies regardless of whether you use MongoDB or PostgreSQL. Covers SQL vs NoSQL tradeoffs, ACID vs BASE, CAP theorem, normalization, indexing, transactions, and scaling patterns. Essential for schema design and system design interview questions.",
          "briefDescription": "Database theory: ACID, CAP, indexing, transactions, scaling.",
          "priority": "must",
          "children": [
            {
              "id": "sql-nosql",
              "title": "SQL vs NoSQL",
              "description": "SQL databases (PostgreSQL, MySQL) store data in tables with fixed schemas, support JOIN operations, enforce referential integrity, and use SQL for queries. NoSQL databases (MongoDB, Redis, DynamoDB) offer flexible schemas, horizontal scaling, and different data models (document, key-value, graph, column-family). Choose based on data structure, query patterns, and scale requirements.",
              "briefDescription": "Structured relational databases vs flexible non-relational databases.",
              "priority": "must"
            },
            {
              "id": "acid",
              "title": "ACID Properties",
              "description": "Atomicity — transactions are all-or-nothing. Consistency — database moves from one valid state to another. Isolation — concurrent transactions don't interfere. Durability — committed data survives crashes. SQL databases are ACID-compliant by default. MongoDB supports ACID transactions since v4.0 for multi-document operations.",
              "briefDescription": "Atomicity, Consistency, Isolation, Durability guarantees.",
              "priority": "must"
            },
            {
              "id": "base",
              "title": "BASE Properties",
              "description": "Basically Available — system guarantees availability. Soft State — state may change over time without input. Eventually Consistent — data will become consistent given enough time. BASE is the NoSQL counterpart to ACID, favoring availability and partition tolerance over strong consistency. Used in distributed systems like DynamoDB and Cassandra.",
              "briefDescription": "NoSQL's availability-first alternative to ACID guarantees.",
              "priority": "imp"
            },
            {
              "id": "cap-theorem",
              "title": "CAP Theorem",
              "description": "In a distributed system, you can only guarantee two of three: Consistency (every read gets the latest write), Availability (every request gets a response), Partition Tolerance (system works despite network failures). Since network partitions are inevitable, you choose between CP (MongoDB) or AP (DynamoDB, Cassandra). Essential for system design interviews.",
              "briefDescription": "Pick two: Consistency, Availability, Partition Tolerance.",
              "priority": "must"
            },
            {
              "id": "normalization",
              "title": "Normalization (1NF, 2NF, 3NF, BCNF)",
              "description": "Normalization reduces data redundancy. 1NF: atomic values, no repeating groups. 2NF: 1NF + no partial dependencies. 3NF: 2NF + no transitive dependencies. BCNF: stronger version of 3NF. Over-normalization hurts read performance. In MongoDB, denormalization is common for read-heavy workloads with embedded documents.",
              "briefDescription": "Progressive steps to eliminate data redundancy.",
              "priority": "imp"
            },
            {
              "id": "denormalization",
              "title": "Denormalization",
              "description": "Intentionally adding redundant data to improve read performance. Instead of JOINing multiple tables/collections, embed related data together. Common in MongoDB where you embed user profile data in posts to avoid $lookup. Tradeoff: faster reads but more complex write logic to keep duplicated data in sync.",
              "briefDescription": "Trading write complexity for faster reads via data duplication.",
              "priority": "imp"
            },
            {
              "id": "indexing-basics",
              "title": "Indexing Basics",
              "description": "Indexes are data structures (typically B-trees) that speed up query lookups at the cost of slower writes and extra storage. Without indexes, MongoDB performs collection scans. Proper indexing can turn O(n) lookups into O(log n). Understanding when and what to index is a critical interview skill.",
              "briefDescription": "Data structures that dramatically speed up database queries.",
              "priority": "must",
              "children": [
                {
                  "id": "btree-index",
                  "title": "B-Tree Index",
                  "description": "B-Trees are balanced trees where each node can have many children, keeping the tree height small. Most database indexes use B-Trees or B+ Trees. They support range queries efficiently (find all users where age > 25) and maintain sorted order. MongoDB's default index type is B-Tree based.",
                  "briefDescription": "Balanced tree structure enabling efficient range queries.",
                  "priority": "imp"
                },
                {
                  "id": "hash-index",
                  "title": "Hash Index",
                  "description": "Hash indexes map keys through a hash function for O(1) exact-match lookups. They don't support range queries or sorting. MongoDB offers hashed indexes for shard keys. Useful when you only need equality comparisons (e.g., lookup by exact ID or email).",
                  "briefDescription": "O(1) lookups for exact matches, no range query support.",
                  "priority": "look"
                }
              ]
            },
            {
              "id": "transactions",
              "title": "Transactions",
              "description": "A transaction groups multiple operations into a single atomic unit — either all succeed or all fail. Critical for operations like transferring money between accounts. MongoDB supports multi-document transactions (since v4.0) using sessions. Use transactions sparingly as they add overhead and lock contention.",
              "briefDescription": "Atomic multi-operation units that succeed or fail together.",
              "priority": "imp",
              "children": [
                {
                  "id": "isolation-levels",
                  "title": "Isolation Levels",
                  "description": "Isolation levels control how concurrent transactions see each other's changes. Read Uncommitted (dirty reads), Read Committed (no dirty reads), Repeatable Read (consistent reads within a transaction), Serializable (full isolation, slowest). Higher isolation = more correctness but lower throughput. MongoDB uses snapshot isolation by default.",
                  "briefDescription": "Tradeoffs between consistency and performance in concurrent transactions.",
                  "priority": "look"
                }
              ]
            },
            {
              "id": "sharding-replication",
              "title": "Sharding vs Replication",
              "description": "Replication copies data across multiple servers for high availability and read scaling (primary-secondary model). Sharding partitions data across multiple servers for write scaling and handling large datasets. MongoDB supports both: replica sets for HA, and sharded clusters for horizontal scaling. Key system design interview topic.",
              "briefDescription": "Data copying for availability vs data partitioning for scale.",
              "priority": "imp"
            }
          ]
        },
        {
          "id": "oop",
          "title": "Object-Oriented Programming",
          "description": "OOP organizes code around objects that combine data and behavior. While JavaScript is prototype-based rather than class-based, OOP concepts are heavily tested in interviews. Understanding encapsulation, inheritance, polymorphism, SOLID principles, and design patterns is essential for writing maintainable, scalable code.",
          "briefDescription": "OOP principles, SOLID, and design patterns for clean code.",
          "priority": "must",
          "children": [
            {
              "id": "classes-objects",
              "title": "Classes & Objects",
              "description": "A class is a blueprint; an object is an instance. In JavaScript, ES6 classes are syntactic sugar over prototypal inheritance. Classes define constructor, methods, and properties. Objects are created with 'new'. Understanding this distinction helps you design component hierarchies and service layers in MERN apps.",
              "briefDescription": "Blueprints (classes) and their instances (objects).",
              "priority": "must"
            },
            {
              "id": "encapsulation",
              "title": "Encapsulation",
              "description": "Encapsulation bundles data and methods that operate on that data within a single unit, restricting direct access to internals. In JavaScript, use closures, private class fields (#), or module pattern to hide implementation details. This prevents external code from depending on internal structure, making changes safer.",
              "briefDescription": "Bundling data with methods and hiding internal details.",
              "priority": "imp"
            },
            {
              "id": "abstraction",
              "title": "Abstraction",
              "description": "Abstraction hides complex implementation behind a simple interface. Users of a class or module only interact with its public API without knowing internal details. Example: Mongoose's Model.find() hides the MongoDB driver query building. Good abstraction reduces cognitive load and makes code easier to use and maintain.",
              "briefDescription": "Hiding complexity behind simple interfaces.",
              "priority": "imp"
            },
            {
              "id": "inheritance",
              "title": "Inheritance",
              "description": "Inheritance allows a class to inherit properties and methods from a parent class. JavaScript supports single inheritance through 'extends'. Prototype-based inheritance uses the prototype chain. Multilevel inheritance creates deeper hierarchies. Prefer composition over inheritance when possible to avoid tight coupling and the fragile base class problem.",
              "briefDescription": "Deriving new classes from existing ones to reuse behavior.",
              "priority": "must"
            },
            {
              "id": "polymorphism",
              "title": "Polymorphism",
              "description": "Polymorphism allows objects of different types to be treated through a common interface. In JavaScript, method overriding (subclass provides its own implementation) is common. Duck typing ('if it walks like a duck...') is JavaScript's form of polymorphism. This enables flexible, extensible code in Express middleware and React component patterns.",
              "briefDescription": "Same interface, different implementations.",
              "priority": "imp"
            },
            {
              "id": "solid-principles",
              "title": "SOLID Principles",
              "description": "Five design principles for maintainable OOP code. These principles guide how you structure classes, modules, and services in a MERN application. Following SOLID leads to code that's easier to test, extend, and refactor.",
              "briefDescription": "Five principles for clean, maintainable object-oriented design.",
              "priority": "must",
              "children": [
                {
                  "id": "srp",
                  "title": "Single Responsibility Principle",
                  "description": "A class/module should have only one reason to change. In MERN: separate route handlers from business logic from data access. A UserController handles HTTP, a UserService handles business rules, a UserModel handles database. This makes each piece independently testable and replaceable.",
                  "briefDescription": "One class, one job, one reason to change.",
                  "priority": "must"
                },
                {
                  "id": "ocp",
                  "title": "Open/Closed Principle",
                  "description": "Classes should be open for extension but closed for modification. Add new behavior through inheritance or composition, not by changing existing code. In Express, middleware is a perfect example — you extend the pipeline by adding middleware functions without modifying existing ones.",
                  "briefDescription": "Extend behavior without modifying existing code.",
                  "priority": "imp"
                },
                {
                  "id": "lsp",
                  "title": "Liskov Substitution Principle",
                  "description": "Subtypes must be substitutable for their base types without breaking the program. If your code expects a Logger, any subclass (FileLogger, ConsoleLogger, CloudLogger) should work without special handling. Violations lead to brittle code with type-checking conditionals everywhere.",
                  "briefDescription": "Subclasses must work wherever parent classes are expected.",
                  "priority": "look"
                },
                {
                  "id": "isp",
                  "title": "Interface Segregation Principle",
                  "description": "Don't force clients to depend on interfaces they don't use. Instead of one large interface, create smaller, focused ones. In TypeScript, split large interfaces into smaller ones. In Node.js, create focused middleware instead of one massive middleware that does everything.",
                  "briefDescription": "Prefer many small interfaces over one large one.",
                  "priority": "look"
                },
                {
                  "id": "dip",
                  "title": "Dependency Inversion Principle",
                  "description": "High-level modules shouldn't depend on low-level modules; both should depend on abstractions. In MERN: your service layer should depend on a database interface, not directly on Mongoose. This allows swapping MongoDB for PostgreSQL without changing business logic. Enables easy testing with mock implementations.",
                  "briefDescription": "Depend on abstractions, not concrete implementations.",
                  "priority": "imp"
                }
              ]
            },
            {
              "id": "design-patterns",
              "title": "Design Patterns",
              "description": "Reusable solutions to common software design problems. Patterns provide a shared vocabulary for developers. In MERN apps, you encounter these patterns constantly — Singleton for DB connections, Observer for event handling, Module for encapsulation, Factory for creating different response types.",
              "briefDescription": "Proven solutions to recurring software design problems.",
              "priority": "imp",
              "children": [
                { "id": "singleton", "title": "Singleton", "description": "Ensures a class has only one instance and provides global access to it. In MERN: database connection instance (mongoose.connect returns a singleton connection), Redis client instance, or a configuration manager. Prevents multiple connections being opened accidentally.", "briefDescription": "One instance, global access point.", "priority": "imp" },
                { "id": "factory", "title": "Factory", "description": "Creates objects without specifying the exact class. A factory function takes parameters and returns the appropriate object type. In MERN: creating different error response objects (NotFoundError, ValidationError, AuthError) from a single createError factory based on the error type.", "briefDescription": "Create objects without specifying their exact class.", "priority": "imp" },
                { "id": "observer", "title": "Observer", "description": "Defines a one-to-many dependency where multiple observers are notified when a subject changes state. Node.js EventEmitter is the Observer pattern. React's state updates triggering re-renders follow this pattern. Used extensively in real-time features and event-driven architectures.", "briefDescription": "Notify multiple listeners when state changes.", "priority": "imp" },
                { "id": "module", "title": "Module", "description": "Encapsulates related code into a self-contained unit with a public API and hidden internals. JavaScript modules (CommonJS, ESM) are the Module pattern. Closures create module-like encapsulation. Every file in a MERN project is a module with explicit exports.", "briefDescription": "Self-contained code units with public API.", "priority": "imp" },
                { "id": "strategy", "title": "Strategy", "description": "Defines a family of interchangeable algorithms. The client chooses which strategy to use at runtime. In MERN: different authentication strategies in Passport.js (local, JWT, Google OAuth), different caching strategies (cache-aside, write-through), or different payment processors.", "briefDescription": "Interchangeable algorithms selected at runtime.", "priority": "look" },
                { "id": "decorator", "title": "Decorator", "description": "Adds behavior to objects dynamically without modifying their structure. Express middleware decorates the request/response objects with additional properties and methods. Higher-Order Components in React wrap components to add functionality. TypeScript decorators annotate classes and methods.", "briefDescription": "Add behavior dynamically without changing class structure.", "priority": "look" },
                { "id": "proxy", "title": "Proxy", "description": "Provides a surrogate object that controls access to the original. JavaScript's Proxy object allows intercepting operations (get, set, delete). Used for validation, logging, lazy initialization, and caching. Mongoose uses proxies internally for model instances.", "briefDescription": "Surrogate controlling access to another object.", "priority": "look" }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "dsa",
      "title": "Data Structures & Algorithms",
      "description": "The backbone of technical interviews. Nearly every MERN developer interview includes DSA rounds. Mastering complexity analysis, core data structures, and algorithmic paradigms lets you write efficient code, optimize database queries, and ace whiteboard challenges. Focus on patterns rather than memorizing solutions.",
      "briefDescription": "Core data structures, algorithms, and problem-solving patterns.",
      "priority": "must",
      "children": [
        {
          "id": "big-o",
          "title": "Big O Notation",
          "description": "Big O describes the upper bound of an algorithm's growth rate as input size increases. It's the language of technical interviews — every solution discussion ends with 'What's the time and space complexity?' Understanding Big O lets you compare approaches and justify your design decisions.",
          "briefDescription": "Measuring algorithm efficiency as input grows.",
          "priority": "must",
          "children": [
            {
              "id": "time-complexity",
              "title": "Time Complexity",
              "description": "Measures how the number of operations grows with input size n. Common complexities: O(1) constant, O(log n) logarithmic, O(n) linear, O(n log n) linearithmic, O(n²) quadratic, O(2ⁿ) exponential. Interviewers expect you to analyze every solution's time complexity.",
              "briefDescription": "How execution time scales with input size.",
              "priority": "must",
              "children": [
                {
                  "id": "best-avg-worst",
                  "title": "Best, Average, Worst Case",
                  "description": "Best case is the minimum operations (e.g., element found at index 0 in linear search). Average case considers expected input distribution. Worst case is the maximum operations (element not found). Big O typically describes worst case. QuickSort: best/avg O(n log n), worst O(n²). Always discuss worst case in interviews.",
                  "briefDescription": "Analyzing algorithms across different input scenarios.",
                  "priority": "must"
                }
              ]
            },
            {
              "id": "space-complexity",
              "title": "Space Complexity",
              "description": "Measures how much additional memory an algorithm uses relative to input size. Includes auxiliary space (extra variables, data structures) but not the input itself. Recursive algorithms use O(call stack depth) space. In-place algorithms use O(1) extra space. Trade space for time is a common optimization strategy.",
              "briefDescription": "How memory usage scales with input size.",
              "priority": "must"
            },
            {
              "id": "amortized-analysis",
              "title": "Amortized Analysis",
              "description": "Averages the cost of operations over a sequence rather than looking at individual worst cases. Example: dynamic array append is O(1) amortized — most appends are O(1), but occasional resizing is O(n). Over n operations, total cost is O(n), so amortized cost per operation is O(1). Important for understanding ArrayList and hash table performance.",
              "briefDescription": "Average cost per operation over a sequence.",
              "priority": "imp"
            }
          ]
        },
        {
          "id": "arrays",
          "title": "Arrays",
          "description": "The most fundamental data structure and the most common in interviews. Arrays store elements in contiguous memory with O(1) random access. JavaScript arrays are dynamic (resizable). Master the key patterns: two pointers, sliding window, prefix sum, and Kadane's algorithm to solve 80% of array problems.",
          "briefDescription": "Contiguous memory storage with O(1) access — most common interview topic.",
          "priority": "must",
          "children": [
            {
              "id": "static-dynamic-arrays",
              "title": "Static vs Dynamic Arrays",
              "description": "Static arrays have fixed size (C-style). Dynamic arrays (JavaScript Array, Python list, Java ArrayList) resize automatically by allocating a larger array and copying elements when capacity is exceeded — typically doubling in size. This gives O(1) amortized append. JavaScript arrays are always dynamic and can hold mixed types.",
              "briefDescription": "Fixed-size vs auto-resizing arrays.",
              "priority": "imp"
            },
            {
              "id": "two-pointer",
              "title": "Two Pointer Technique",
              "description": "Use two pointers to traverse an array from different positions (start/end, or both from start at different speeds). Reduces O(n²) brute force to O(n). Classic problems: two sum in sorted array, container with most water, remove duplicates, three sum. Works best on sorted arrays or when comparing elements at distances.",
              "briefDescription": "Two indices traversing array to reduce time complexity.",
              "priority": "must"
            },
            {
              "id": "sliding-window",
              "title": "Sliding Window",
              "description": "Maintain a window (subarray) that slides through the array. Fixed window: move both ends together. Variable window: expand right, shrink left based on condition. Avoids recalculating overlapping subarrays. Classic problems: maximum subarray of size k, longest substring without repeating characters, minimum window substring.",
              "briefDescription": "Efficient subarray/substring processing by maintaining a moving window.",
              "priority": "must"
            },
            {
              "id": "kadanes-algorithm",
              "title": "Kadane's Algorithm",
              "description": "Finds the maximum sum contiguous subarray in O(n) time. Idea: at each index, either extend the current subarray or start fresh. Track current_sum = max(nums[i], current_sum + nums[i]) and global max. One of the most elegant DP algorithms and a frequent interview question.",
              "briefDescription": "O(n) maximum subarray sum using dynamic programming.",
              "priority": "imp"
            },
            {
              "id": "prefix-sum",
              "title": "Prefix Sum",
              "description": "Precompute cumulative sums so that any subarray sum can be calculated in O(1) using prefix[right] - prefix[left-1]. Useful for range queries, subarray sum equals k (using hash map), and 2D matrix sum queries. Build prefix array in O(n), then answer unlimited queries in O(1) each.",
              "briefDescription": "Precomputed cumulative sums for O(1) range queries.",
              "priority": "imp"
            },
            {
              "id": "matrix-2d",
              "title": "Matrix / 2D Array Problems",
              "description": "2D arrays represent grids, matrices, and board games. Common operations: spiral traversal, rotation (90°/180°), search in sorted matrix, island counting (DFS/BFS on grid). Complexity is typically O(m×n). Matrix problems combine array techniques with graph traversal and are very common in interviews.",
              "briefDescription": "Grid traversal, rotation, and search problems.",
              "priority": "imp"
            }
          ]
        },
        {
          "id": "strings",
          "title": "Strings",
          "description": "Strings are immutable sequences of characters in JavaScript. String problems are extremely common in interviews and often combine with hash maps and two pointers. Key topics: manipulation, palindromes, anagrams, pattern matching, and compression.",
          "briefDescription": "Character sequence problems — palindromes, anagrams, pattern matching.",
          "priority": "must",
          "children": [
            { "id": "string-manipulation", "title": "String Manipulation", "description": "Core string operations: reverse, split, join, slice, substring, trim, replace, toLowerCase/toUpperCase. In JavaScript, strings are immutable — every operation creates a new string. For heavy manipulation, convert to array, modify, then join back. Understanding immutability affects performance analysis.", "briefDescription": "Core operations on immutable character sequences.", "priority": "must" },
            { "id": "palindrome-checks", "title": "Palindrome Checks", "description": "A palindrome reads the same forwards and backwards. Check with two-pointer from both ends: O(n) time, O(1) space. Variations: longest palindromic substring (expand from center or Manacher's), palindrome partitioning (backtracking), valid palindrome with non-alphanumeric characters ignored.", "briefDescription": "Detecting strings that read the same in both directions.", "priority": "must" },
            { "id": "anagram-detection", "title": "Anagram Detection", "description": "Two strings are anagrams if they contain the same characters with the same frequencies. Detect using: (1) sort both and compare — O(n log n), (2) frequency counter hash map — O(n). Group anagrams by sorting each string as key. Common in interviews as it tests hash map skills.", "briefDescription": "Finding strings with identical character frequencies.", "priority": "imp" },
            {
              "id": "pattern-matching",
              "title": "Pattern Matching",
              "description": "Finding occurrences of a pattern string within a text string. Brute force is O(n×m). Advanced algorithms achieve O(n+m). Important for text search, log parsing, and understanding how regex engines work internally.",
              "briefDescription": "Efficiently finding substrings within larger strings.",
              "priority": "imp",
              "children": [
                { "id": "kmp", "title": "KMP Algorithm", "description": "Knuth-Morris-Pratt builds a failure function (LPS array) from the pattern that tells how far to skip on mismatch, avoiding re-scanning matched characters. Achieves O(n+m) time. The LPS array stores the length of the longest proper prefix that is also a suffix for each position in the pattern.", "briefDescription": "O(n+m) pattern matching using failure function.", "priority": "look" },
                { "id": "rabin-karp", "title": "Rabin-Karp", "description": "Uses rolling hash to compare pattern hash with substrings of text. If hashes match, verify character by character to handle collisions. Average case O(n+m), worst case O(n×m). Good for multi-pattern search. Rolling hash updates in O(1) by removing the leading character and adding the trailing one.", "briefDescription": "Rolling hash-based pattern matching.", "priority": "look" }
              ]
            },
            { "id": "string-compression", "title": "String Compression", "description": "Compress a string by replacing consecutive repeated characters with the character and count (e.g., 'aabbb' → 'a2b3'). Only use compressed form if shorter. Common interview question testing in-place modification and edge cases. Also relates to run-length encoding concepts.", "briefDescription": "Replacing repeated characters with character + count.", "priority": "imp" }
          ]
        },
        {
          "id": "linked-lists",
          "title": "Linked Lists",
          "description": "A linear data structure where elements (nodes) are connected via pointers rather than stored contiguously. Each node contains data and a reference to the next node. Linked lists excel at O(1) insertion/deletion at known positions but have O(n) access. Classic interview topic testing pointer manipulation skills.",
          "briefDescription": "Pointer-connected nodes — insertion/deletion in O(1), access in O(n).",
          "priority": "must",
          "children": [
            { "id": "singly-ll", "title": "Singly Linked List", "description": "Each node has data and a 'next' pointer. Traversal is forward-only. Operations: insert at head O(1), insert at tail O(n) without tail pointer, delete O(n) to find, search O(n). Simpler than doubly linked lists but less flexible. Foundation for stacks and queues.", "briefDescription": "Forward-only linked list with next pointers.", "priority": "must" },
            { "id": "doubly-ll", "title": "Doubly Linked List", "description": "Each node has 'prev' and 'next' pointers enabling bidirectional traversal. Deletion at a known node is O(1) since you can access both neighbors. Used in LRU cache (combined with hash map), browser history, and undo/redo. More memory per node but more flexible operations.", "briefDescription": "Bidirectional traversal with prev and next pointers.", "priority": "imp" },
            { "id": "circular-ll", "title": "Circular Linked List", "description": "The last node points back to the first, forming a cycle. Useful for round-robin scheduling, circular buffers, and multiplayer game turns. Traverse by checking if current.next === head. Can be singly or doubly circular.", "briefDescription": "Last node links back to first, forming a loop.", "priority": "look" },
            { "id": "fast-slow-ptrs", "title": "Fast & Slow Pointers (Floyd's)", "description": "Two pointers moving at different speeds. Slow moves 1 step, fast moves 2 steps per iteration. If there's a cycle, they'll meet. To find cycle start: reset one to head, move both at 1 step until they meet. Also used to find the middle of a list (when fast reaches end, slow is at middle).", "briefDescription": "Two-speed pointers for cycle detection and midpoint finding.", "priority": "must" },
            { "id": "reverse-ll", "title": "Reverse a Linked List", "description": "Iteratively: use three pointers (prev, current, next). At each step: save next, point current to prev, advance prev and current. O(n) time, O(1) space. Recursively: reverse rest of list, then fix pointers. One of the most commonly asked interview questions; master both approaches.", "briefDescription": "The quintessential linked list interview question.", "priority": "must" },
            { "id": "detect-cycle", "title": "Detect Cycle", "description": "Use Floyd's cycle detection (fast/slow pointers). If fast and slow meet, a cycle exists. To find cycle length: count steps from meeting point back to itself. To find cycle start: reset one pointer to head, advance both at same speed until they meet. O(n) time, O(1) space.", "briefDescription": "Floyd's algorithm to find and locate cycles.", "priority": "must" },
            { "id": "merge-sorted-lists", "title": "Merge Two Sorted Lists", "description": "Use a dummy head and compare nodes from both lists, appending the smaller one. When one list is exhausted, append the remainder of the other. O(n+m) time, O(1) space (iterative). This is the merge step of merge sort and a building block for merge k sorted lists.", "briefDescription": "Combine two sorted lists into one sorted list.", "priority": "imp" }
          ]
        },
        {
          "id": "stacks",
          "title": "Stacks",
          "description": "LIFO (Last In, First Out) data structure. Push adds to top, pop removes from top, peek views top — all O(1). Stacks model function call stacks, undo operations, expression evaluation, and are used in DFS. Monotonic stacks solve a class of problems involving 'next greater/smaller element.'",
          "briefDescription": "LIFO structure — push, pop, peek in O(1).",
          "priority": "must",
          "children": [
            { "id": "stack-impl", "title": "Implementation (Array & Linked List)", "description": "Array-based: push appends, pop removes last element. Simple and cache-friendly. Linked list-based: push adds to head, pop removes head. No capacity limits. In JavaScript, use an array with push()/pop() for a stack. Both give O(1) for all operations.", "briefDescription": "Array-based vs linked-list-based stack implementations.", "priority": "imp" },
            { "id": "monotonic-stack", "title": "Monotonic Stack", "description": "A stack that maintains elements in sorted order (increasing or decreasing). When pushing, pop elements that violate the order. Solves problems like: next greater element, daily temperatures, largest rectangle in histogram, stock span. Reduces O(n²) brute force to O(n). Critical interview pattern.", "briefDescription": "Stack maintaining sorted order for next-greater-element problems.", "priority": "must" },
            { "id": "balanced-parens", "title": "Balanced Parentheses", "description": "Push opening brackets onto stack. For each closing bracket, check if stack top matches. If stack is empty at end, brackets are balanced. Handle multiple types: (), {}, []. Classic stack problem testing basic stack operations and edge case handling.", "briefDescription": "Verify matching opening and closing brackets.", "priority": "must" },
            { "id": "next-greater", "title": "Next Greater Element", "description": "For each element, find the next element to its right that is greater. Brute force O(n²). Monotonic decreasing stack: traverse right to left, pop elements smaller than current (they can't be NGE for anyone), stack top is the answer, push current. O(n) time.", "briefDescription": "Find the next larger element to the right using monotonic stack.", "priority": "imp" },
            { "id": "min-stack", "title": "Min Stack", "description": "Design a stack supporting push, pop, top, and getMin — all in O(1). Approach: maintain a parallel stack tracking minimums. Each push stores the current minimum alongside the value. Alternative: store the difference from minimum to save space.", "briefDescription": "Stack with O(1) push, pop, and getMin operations.", "priority": "imp" },
            { "id": "infix-prefix-postfix", "title": "Infix, Prefix, Postfix Conversion", "description": "Infix: A + B (human-readable). Prefix: + A B (Polish notation). Postfix: A B + (Reverse Polish, used by calculators). Conversion uses stacks respecting operator precedence and associativity. Postfix evaluation with a stack: push operands, pop two when operator encountered, push result.", "briefDescription": "Expression notation conversions using stacks.", "priority": "look" }
          ]
        },
        {
          "id": "queues",
          "title": "Queues",
          "description": "FIFO (First In, First Out) data structure. Enqueue adds to rear, dequeue removes from front — both O(1). Queues are essential for BFS, job scheduling, message queues, and rate limiting. Variations include priority queues and deques.",
          "briefDescription": "FIFO structure — enqueue, dequeue in O(1).",
          "priority": "must",
          "children": [
            { "id": "queue-impl", "title": "Implementation (Array, Linked List, Circular)", "description": "Array-based: use front/rear indices, but dequeue from front is O(n) with shifting (circular array fixes this). Linked list-based: enqueue at tail, dequeue from head — both O(1) with tail pointer. Circular array: front and rear wrap around using modulo, achieving O(1) for both operations.", "briefDescription": "Different queue implementations and their tradeoffs.", "priority": "imp" },
            { "id": "priority-queue", "title": "Priority Queue", "description": "Elements are dequeued based on priority, not insertion order. Typically implemented with a binary heap. Insert: O(log n), extract-min/max: O(log n). Used in Dijkstra's algorithm, task scheduling, and top-k problems. JavaScript lacks a built-in PQ — implement with a min/max heap.", "briefDescription": "Dequeue by priority using a heap — O(log n) operations.", "priority": "must" },
            { "id": "deque", "title": "Deque (Double-Ended Queue)", "description": "Supports insertion and deletion at both front and rear in O(1). Used in sliding window maximum (monotonic deque), palindrome checking, and work-stealing algorithms. Can implement both stack and queue behaviors. JavaScript's array with push/pop/shift/unshift acts as a deque (though shift/unshift are O(n)).", "briefDescription": "Insert and remove from both ends in O(1).", "priority": "imp" },
            { "id": "bfs-queue", "title": "BFS with Queue", "description": "Breadth-First Search uses a queue to explore nodes level by level. Enqueue the start node, then repeatedly dequeue a node, process it, and enqueue all unvisited neighbors. Guarantees shortest path in unweighted graphs. Used in shortest path, level-order tree traversal, and word ladder problems.", "briefDescription": "Level-by-level graph/tree exploration using a queue.", "priority": "must" }
          ]
        },
        {
          "id": "hash-maps",
          "title": "Hash Maps / Hash Tables",
          "description": "Key-value store with average O(1) lookup, insert, and delete. JavaScript's Map and plain objects are hash maps. The most versatile data structure in interviews — used for frequency counting, caching, deduplication, and converting O(n²) solutions to O(n). Understanding collision handling is key to analyzing worst-case performance.",
          "briefDescription": "O(1) average key-value lookups — the most versatile interview tool.",
          "priority": "must",
          "children": [
            { "id": "hash-functions", "title": "Hash Functions", "description": "A hash function maps keys to array indices. Good hash functions distribute keys uniformly, are deterministic, and are fast to compute. For strings, polynomial rolling hash is common. JavaScript engines handle hashing internally for Map and object property access. Collisions are inevitable by pigeonhole principle.", "briefDescription": "Converting keys to array indices uniformly.", "priority": "imp" },
            {
              "id": "collision-handling",
              "title": "Collision Handling",
              "description": "When two keys hash to the same index, collisions must be resolved. Two main strategies: chaining and open addressing. The choice affects performance characteristics and cache behavior.",
              "briefDescription": "Resolving when multiple keys map to the same index.",
              "priority": "imp",
              "children": [
                { "id": "chaining", "title": "Chaining", "description": "Each bucket stores a linked list (or other collection) of entries. Colliding keys are appended to the same bucket's list. Lookup scans the list at the hashed index. Average O(1) with good hash function and low load factor. Worst case O(n) if all keys hash to same bucket.", "briefDescription": "Store colliding entries in a linked list at each bucket.", "priority": "imp" },
                { "id": "open-addressing", "title": "Open Addressing", "description": "All entries stored in the array itself. On collision, probe for the next empty slot using: linear probing (next slot), quadratic probing (i² offsets), or double hashing (second hash function). Better cache performance than chaining but suffers from clustering. Load factor must stay below ~0.7.", "briefDescription": "Probe for empty slots within the array on collision.", "priority": "look" }
              ]
            },
            { "id": "freq-counting", "title": "Frequency Counting", "description": "Count occurrences of elements using a hash map. Iterate through data, using elements as keys and counts as values. O(n) time, O(k) space where k is unique elements. Solves: most frequent element, first non-repeating character, valid anagram, and many more. The bread and butter of hash map problems.", "briefDescription": "Count element occurrences in O(n) using a hash map.", "priority": "must" },
            { "id": "two-sum-pattern", "title": "Two Sum Pattern", "description": "For each element, check if its complement (target - element) exists in the hash map. If yes, return the pair. If no, add current element to the map. O(n) time, O(n) space vs O(n²) brute force. Extends to three sum, four sum, and subarray sum equals k (with prefix sum).", "briefDescription": "Find pairs summing to target using complement lookup.", "priority": "must" },
            { "id": "group-anagrams", "title": "Group Anagrams", "description": "Group strings that are anagrams of each other. Key insight: sort each string to create a canonical form, use it as hash map key, and group strings with the same key. O(n × k log k) where n is number of strings and k is max string length. Alternative: use character frequency as key for O(n × k).", "briefDescription": "Group strings by sorted form or character frequency.", "priority": "imp" }
          ]
        },
        {
          "id": "trees",
          "title": "Trees",
          "description": "Hierarchical data structures with a root node and children. Trees are everywhere: DOM, file systems, database indexes, syntax trees. Binary trees, BSTs, and tries are the most commonly tested. Master traversals, BST operations, and tree DP to handle the wide variety of tree problems in interviews.",
          "briefDescription": "Hierarchical structures — traversals, BSTs, tries.",
          "priority": "must",
          "children": [
            {
              "id": "binary-tree",
              "title": "Binary Tree",
              "description": "Each node has at most two children (left and right). Binary trees are the foundation for BSTs, heaps, and expression trees. Most interview tree problems are on binary trees. Key operations are the four traversals, height/depth calculation, diameter, and lowest common ancestor.",
              "briefDescription": "Nodes with at most two children — the foundation of tree problems.",
              "priority": "must",
              "children": [
                { "id": "tree-traversals", "title": "Traversals (Inorder, Preorder, Postorder, Level-order)", "description": "Inorder (left-root-right): gives sorted order for BST. Preorder (root-left-right): used to serialize/copy trees. Postorder (left-right-root): used to delete trees or evaluate expressions. Level-order: BFS using queue, gives nodes level by level. Know both recursive and iterative (stack-based) implementations.", "briefDescription": "Four ways to visit every node in a binary tree.", "priority": "must" },
                { "id": "tree-height-depth", "title": "Height / Depth", "description": "Height of a node is the longest path from that node to a leaf. Depth of a node is the path length from root to that node. Tree height = height of root = max depth of any node. Calculate recursively: height = 1 + max(height(left), height(right)). Base case: null node has height -1 (or 0 depending on convention).", "briefDescription": "Longest path to leaf vs distance from root.", "priority": "must" },
                { "id": "tree-diameter", "title": "Diameter", "description": "The longest path between any two nodes in the tree (may or may not pass through root). At each node, diameter through that node = height(left) + height(right) + 2. Track global maximum. Calculate in O(n) by computing height bottom-up and updating diameter at each node.", "briefDescription": "Longest path between any two nodes.", "priority": "imp" },
                { "id": "lca", "title": "Lowest Common Ancestor", "description": "The deepest node that is an ancestor of both given nodes. For binary tree: if current node is p or q, return it. Recursively search left and right subtrees. If both return non-null, current node is LCA. If only one returns non-null, that's the LCA. O(n) time. For BST: use BST property to go left/right.", "briefDescription": "Deepest shared ancestor of two given nodes.", "priority": "imp" }
              ]
            },
            {
              "id": "bst",
              "title": "Binary Search Tree (BST)",
              "description": "A binary tree where left child < parent < right child for every node. This property enables O(log n) search, insert, and delete in balanced trees. BSTs degrade to O(n) when unbalanced (essentially a linked list). Understanding BST invariant is crucial for validation and search problems.",
              "briefDescription": "Ordered binary tree with O(log n) search when balanced.",
              "priority": "must",
              "children": [
                { "id": "bst-operations", "title": "Insert, Delete, Search", "description": "Search: compare with root, go left if smaller, right if larger. O(log n) balanced, O(n) worst. Insert: search for position, add as leaf. Delete has 3 cases: leaf (remove), one child (replace with child), two children (replace with inorder successor/predecessor). All O(h) where h is height.", "briefDescription": "Core BST operations and their complexity.", "priority": "must" },
                { "id": "validate-bst", "title": "Validate BST", "description": "Check if a binary tree satisfies BST property. Naive check (node.left < node < node.right) is wrong — must check entire subtree range. Correct approach: pass min/max bounds down recursively. Or do inorder traversal and verify it's strictly increasing. O(n) time.", "briefDescription": "Verify every node satisfies BST ordering property.", "priority": "must" },
                { "id": "kth-smallest", "title": "Kth Smallest Element", "description": "Inorder traversal of BST gives sorted order. Either: (1) do inorder, return kth element — O(n), or (2) augment each node with left subtree size for O(log n) lookup. Follow-up: what if BST is modified frequently? Use order-statistic tree.", "briefDescription": "Find kth smallest using BST's inorder property.", "priority": "imp" }
              ]
            },
            { "id": "avl-tree", "title": "AVL Tree", "description": "Self-balancing BST where the height difference between left and right subtrees (balance factor) is at most 1 for every node. Rebalances using rotations (left, right, left-right, right-left) after insertions and deletions. Guarantees O(log n) for all operations. Stricter balancing than Red-Black trees but faster lookups.", "briefDescription": "Self-balancing BST with strict height balance.", "priority": "look" },
            { "id": "red-black-tree", "title": "Red-Black Tree", "description": "Self-balancing BST with color properties: root is black, leaves (null) are black, red nodes have black children, all paths from node to leaves have equal black nodes. Less strictly balanced than AVL but fewer rotations on insert/delete. Used in Java TreeMap, C++ std::map. Guarantees O(log n) operations.", "briefDescription": "Self-balancing BST used in most language standard libraries.", "priority": "look" },
            {
              "id": "trie",
              "title": "Trie (Prefix Tree)",
              "description": "A tree where each node represents a character, and paths from root to nodes represent prefixes. Used for efficient string operations: autocomplete, spell check, IP routing. Insert and search are O(m) where m is word length, regardless of how many words are stored.",
              "briefDescription": "Character-level tree for prefix-based string operations.",
              "priority": "imp",
              "children": [
                { "id": "trie-operations", "title": "Insert, Search, StartsWith", "description": "Insert: traverse/create nodes for each character, mark last node as word end. Search: traverse nodes, return true if path exists and last node is word end. StartsWith: like search but don't require word end marker. Each operation is O(m) where m is the string length.", "briefDescription": "Core trie operations in O(word length) time.", "priority": "imp" },
                { "id": "autocomplete", "title": "Autocomplete", "description": "Given a prefix, find all words starting with it. Traverse trie to prefix end node, then DFS/BFS to collect all complete words in that subtree. Add frequency counts to nodes for ranking suggestions. Used in search engines, IDEs, and mobile keyboards.", "briefDescription": "Finding all words matching a given prefix.", "priority": "imp" }
              ]
            },
            { "id": "segment-tree", "title": "Segment Tree", "description": "A binary tree for efficient range queries (sum, min, max) and point/range updates on an array. Build in O(n), query and update in O(log n). Each node stores the result for a segment of the array. Useful for competitive programming and problems involving frequent range operations.", "briefDescription": "O(log n) range queries and updates on arrays.", "priority": "skip" },
            { "id": "fenwick-tree", "title": "Fenwick Tree / BIT", "description": "Binary Indexed Tree provides O(log n) prefix sum queries and point updates using clever bit manipulation. Simpler to implement than segment trees but less flexible (primarily for prefix sums, not arbitrary ranges without modification). Uses array where index i stores sum of elements based on its lowest set bit.", "briefDescription": "Simpler alternative to segment tree for prefix queries.", "priority": "skip" }
          ]
        },
        {
          "id": "heaps",
          "title": "Heaps",
          "description": "A complete binary tree satisfying the heap property: in a min-heap, parent ≤ children; in a max-heap, parent ≥ children. Implemented as an array. Insert and extract-min/max are O(log n). Heaps are the backbone of priority queues and are essential for top-k problems and stream processing.",
          "briefDescription": "Complete binary tree for efficient min/max extraction.",
          "priority": "must",
          "children": [
            { "id": "min-max-heap", "title": "Min Heap / Max Heap", "description": "Min heap: root is minimum, each parent ≤ children. Max heap: root is maximum, each parent ≥ children. Array representation: parent at i, children at 2i+1 and 2i+2. Heapify-up after insert (bubble up), heapify-down after extract (bubble down). Build heap from array in O(n) using bottom-up heapify.", "briefDescription": "Array-based trees maintaining min or max at root.", "priority": "must" },
            { "id": "heap-sort", "title": "Heap Sort", "description": "Build a max heap from the array in O(n). Repeatedly extract max (swap with last element, reduce heap size, heapify down). O(n log n) guaranteed — no worst-case degradation like quicksort. In-place but not stable. Used when guaranteed O(n log n) is needed and stability doesn't matter.", "briefDescription": "O(n log n) guaranteed sorting using a heap.", "priority": "imp" },
            { "id": "top-k", "title": "Top K Elements", "description": "Find k largest/smallest elements. Approach 1: sort entire array O(n log n). Approach 2: min-heap of size k — iterate through array, push element, pop if heap size > k. O(n log k). Approach 3: quickselect O(n) average. Heap approach is best for streaming data where n is unknown.", "briefDescription": "Efficiently find k largest/smallest using a heap.", "priority": "must" },
            { "id": "median-stream", "title": "Median of Stream", "description": "Maintain two heaps: max-heap for the lower half and min-heap for the upper half. Keep them balanced (size difference ≤ 1). Median is either the max-heap's top (odd count) or average of both tops (even count). Insert is O(log n), get median is O(1). Classic heap interview problem.", "briefDescription": "Real-time median tracking with two heaps.", "priority": "imp" }
          ]
        },
        {
          "id": "graphs",
          "title": "Graphs",
          "description": "Vertices connected by edges — the most general data structure. Graphs model networks, social connections, dependencies, maps, and state machines. Master BFS, DFS, shortest path algorithms, topological sort, and union-find. Graph problems are considered the hardest in interviews but follow recognizable patterns.",
          "briefDescription": "Vertices and edges — BFS, DFS, shortest path, topological sort.",
          "priority": "must",
          "children": [
            { "id": "graph-repr", "title": "Representation (Adjacency List, Matrix)", "description": "Adjacency list: array of arrays/sets, each index stores its neighbors. Space O(V+E), good for sparse graphs. Adjacency matrix: 2D array where matrix[i][j]=1 if edge exists. Space O(V²), good for dense graphs and O(1) edge lookup. Most interview problems use adjacency list.", "briefDescription": "Adjacency list for sparse, matrix for dense graphs.", "priority": "must" },
            { "id": "bfs", "title": "BFS (Breadth-First Search)", "description": "Explore nodes level by level using a queue. Start from source, visit all neighbors before moving to next level. O(V+E) time. Guarantees shortest path in unweighted graphs. Used for shortest path, level-order traversal, word ladder, rotten oranges, and multi-source BFS problems.", "briefDescription": "Level-by-level exploration guaranteeing shortest unweighted path.", "priority": "must" },
            { "id": "dfs", "title": "DFS (Depth-First Search)", "description": "Explore as deep as possible before backtracking, using recursion or explicit stack. O(V+E) time. Used for cycle detection, topological sort, connected components, path finding, and tree traversals. Recursive DFS is cleaner; iterative avoids stack overflow for deep graphs.", "briefDescription": "Depth-first exploration using recursion or stack.", "priority": "must" },
            { "id": "topological-sort", "title": "Topological Sort", "description": "Linear ordering of vertices in a DAG such that for every edge u→v, u comes before v. Two approaches: (1) DFS-based — add to result in reverse post-order, (2) Kahn's algorithm — BFS using in-degree, repeatedly remove nodes with in-degree 0. Used for build systems, course prerequisites, task scheduling.", "briefDescription": "Linear ordering respecting directed dependencies.", "priority": "imp" },
            { "id": "dijkstra", "title": "Dijkstra's Algorithm", "description": "Finds shortest path from source to all vertices in a weighted graph with non-negative edges. Uses a priority queue: always process the closest unvisited vertex, relax its neighbors. O((V+E) log V) with binary heap. Fails with negative edges (use Bellman-Ford). Most commonly asked shortest path algorithm.", "briefDescription": "Shortest path in non-negative weighted graphs using priority queue.", "priority": "imp" },
            { "id": "bellman-ford", "title": "Bellman-Ford", "description": "Finds shortest path from source handling negative edge weights. Relaxes all edges V-1 times. An Nth relaxation that reduces distance indicates a negative cycle. O(V×E) time — slower than Dijkstra but more versatile. Used when negative weights exist or to detect negative cycles.", "briefDescription": "Shortest path handling negative edges, detects negative cycles.", "priority": "look" },
            { "id": "floyd-warshall", "title": "Floyd-Warshall", "description": "Finds shortest paths between ALL pairs of vertices. Uses dynamic programming with a 3D table compressed to 2D. O(V³) time, O(V²) space. For each intermediate vertex k, check if path through k is shorter. Handles negative edges but not negative cycles. Good for small dense graphs.", "briefDescription": "All-pairs shortest path in O(V³).", "priority": "look" },
            { "id": "union-find", "title": "Union-Find / Disjoint Set", "description": "Tracks elements partitioned into disjoint sets. Supports union (merge two sets) and find (determine which set an element belongs to). With path compression and union by rank, both operations are nearly O(1) amortized (inverse Ackermann). Used for cycle detection, Kruskal's MST, and connected components.", "briefDescription": "Near-O(1) set merging and membership queries.", "priority": "imp" },
            {
              "id": "mst",
              "title": "Minimum Spanning Tree",
              "description": "A subset of edges connecting all vertices with minimum total weight and no cycles. Two classic algorithms: Kruskal's (sort edges, add if no cycle using union-find) and Prim's (grow tree from vertex using priority queue). Both produce optimal MST.",
              "briefDescription": "Connect all vertices with minimum total edge weight.",
              "priority": "look",
              "children": [
                { "id": "kruskals", "title": "Kruskal's Algorithm", "description": "Sort all edges by weight. Iterate through edges: add edge if it doesn't create a cycle (check using union-find). Stop when V-1 edges are added. O(E log E) for sorting. Works well for sparse graphs. The greedy choice (smallest edge that doesn't create cycle) always leads to optimal MST.", "briefDescription": "Sort edges, greedily add if no cycle using union-find.", "priority": "look" },
                { "id": "prims", "title": "Prim's Algorithm", "description": "Start from any vertex. Repeatedly add the cheapest edge connecting the tree to a non-tree vertex using a priority queue. O((V+E) log V) with binary heap. Similar to Dijkstra but tracks edge weight instead of path distance. Better for dense graphs.", "briefDescription": "Grow MST by adding cheapest edge to nearest non-tree vertex.", "priority": "look" }
              ]
            },
            {
              "id": "cycle-detection",
              "title": "Cycle Detection",
              "description": "Detecting cycles is fundamental for topological sort (only works on DAGs), deadlock detection, and validating tree structures. Different approaches for directed and undirected graphs.",
              "briefDescription": "Finding loops in directed and undirected graphs.",
              "priority": "imp",
              "children": [
                { "id": "cycle-directed", "title": "Directed Graphs", "description": "Use DFS with three states: unvisited, in-progress (on current DFS path), and completed. If you visit an in-progress node, a cycle exists (back edge). Alternatively, if topological sort doesn't include all nodes, a cycle exists. Kahn's algorithm detects cycles when queue empties before all nodes are processed.", "briefDescription": "Three-state DFS or Kahn's algorithm for directed cycle detection.", "priority": "imp" },
                { "id": "cycle-undirected", "title": "Undirected Graphs", "description": "DFS: if you visit an already-visited node that isn't the parent, a cycle exists. Union-Find: for each edge, if both vertices are in the same set, adding the edge creates a cycle. BFS can also detect cycles by tracking parent nodes. Simpler than directed graph cycle detection.", "briefDescription": "DFS with parent tracking or union-find for undirected cycles.", "priority": "imp" }
              ]
            },
            { "id": "sccs", "title": "Strongly Connected Components", "description": "In a directed graph, an SCC is a maximal set of vertices where every vertex is reachable from every other vertex. Kosaraju's algorithm: (1) DFS to get finish order, (2) transpose graph, (3) DFS in reverse finish order. Tarjan's algorithm uses a single DFS with a stack. Both O(V+E).", "briefDescription": "Maximal sets of mutually reachable vertices in directed graphs.", "priority": "skip" }
          ]
        },
        {
          "id": "recursion-backtracking",
          "title": "Recursion & Backtracking",
          "description": "Recursion solves problems by breaking them into smaller subproblems. Backtracking extends recursion by exploring all possible solutions and abandoning (pruning) paths that can't lead to valid solutions. Essential for combinatorial problems, constraint satisfaction, and generating all permutations/combinations.",
          "briefDescription": "Solve by dividing into subproblems and pruning invalid paths.",
          "priority": "must",
          "children": [
            { "id": "base-recursive-case", "title": "Base Case & Recursive Case", "description": "Every recursive function needs: (1) Base case — the simplest input that returns directly without recurse (prevents infinite recursion), (2) Recursive case — breaks the problem into smaller instances that move toward the base case. Common mistake: forgetting base case or not making progress toward it.", "briefDescription": "The two essential components of every recursive function.", "priority": "must" },
            { "id": "memoization-rec", "title": "Memoization", "description": "Cache results of expensive recursive calls to avoid redundant computation. Store results in a hash map keyed by function arguments. Transforms exponential recursion into polynomial time (e.g., Fibonacci from O(2ⁿ) to O(n)). The top-down approach to dynamic programming.", "briefDescription": "Cache recursive results to avoid redundant computation.", "priority": "must" },
            { "id": "n-queens", "title": "N-Queens", "description": "Place N queens on an N×N board such that no two queens attack each other (same row, column, or diagonal). Use backtracking: place queens row by row, for each row try all columns, check safety, recurse to next row, backtrack if stuck. Classic interview problem demonstrating pure backtracking.", "briefDescription": "Place N non-attacking queens on a board using backtracking.", "priority": "imp" },
            { "id": "sudoku-solver", "title": "Sudoku Solver", "description": "Fill a 9×9 grid with digits 1-9 such that each row, column, and 3×3 box contains all digits. Backtracking: find empty cell, try digits 1-9, check if valid (no conflicts in row/column/box), recurse, backtrack if no valid digit works. Constraint propagation can significantly prune the search space.", "briefDescription": "Fill the grid satisfying row, column, and box constraints.", "priority": "look" },
            { "id": "perms-combos", "title": "Permutations & Combinations", "description": "Permutations: all orderings of elements (n! results). Use backtracking with a used[] array or swap elements. Combinations: all subsets of size k (nCk results). Use backtracking with a start index to avoid duplicates. Handle duplicates by sorting and skipping same elements at the same level.", "briefDescription": "Generate all orderings or k-sized subsets.", "priority": "must" },
            { "id": "subset-sum", "title": "Subset Sum", "description": "Find a subset of numbers that sums to a target. Backtracking: for each element, include it or exclude it, recurse with remaining elements and updated target. Prune branches where current sum exceeds target (if all positive). Can be optimized to DP for pseudo-polynomial time O(n × target).", "briefDescription": "Find subsets summing to a target value.", "priority": "imp" }
          ]
        },
        {
          "id": "dynamic-programming",
          "title": "Dynamic Programming",
          "description": "Optimization technique for problems with overlapping subproblems and optimal substructure. Two approaches: top-down (recursion + memoization) and bottom-up (tabulation). DP is considered the hardest interview topic. Master the core patterns: knapsack, LCS, LIS, coin change, and grid DP to handle most problems.",
          "briefDescription": "Optimize problems with overlapping subproblems — hardest interview topic.",
          "priority": "must",
          "children": [
            { "id": "top-down-dp", "title": "Top-Down (Memoization)", "description": "Start from the main problem, recursively solve subproblems, and cache results. Natural extension of recursive thinking — write the recursive solution first, then add a cache. Easier to conceptualize but may have stack overhead. Use when subproblem space is sparse (not all states are computed).", "briefDescription": "Recursive approach with caching for repeated subproblems.", "priority": "must" },
            { "id": "bottom-up-dp", "title": "Bottom-Up (Tabulation)", "description": "Solve smallest subproblems first, build up to the main problem using a table (array). No recursion, no stack overflow risk. Iterative and usually faster in practice. Requires understanding the order of subproblem dependencies. Space optimization often possible by keeping only the previous row/state.", "briefDescription": "Iterative approach building from smallest subproblems up.", "priority": "must" },
            { "id": "knapsack", "title": "0/1 Knapsack", "description": "Given items with weights and values, maximize total value without exceeding capacity. Each item is taken or not (0/1). DP state: dp[i][w] = max value using first i items with capacity w. Transition: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i]). O(n×W) time. Space-optimizable to O(W).", "briefDescription": "Maximize value under weight constraint — classic DP problem.", "priority": "must" },
            { "id": "lcs", "title": "Longest Common Subsequence", "description": "Find the longest subsequence common to two strings. dp[i][j] = LCS of first i chars of s1 and first j chars of s2. If chars match: dp[i][j] = dp[i-1][j-1] + 1. Else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]). O(n×m) time and space. Used in diff algorithms and DNA analysis.", "briefDescription": "Longest shared subsequence between two strings.", "priority": "imp" },
            { "id": "lis", "title": "Longest Increasing Subsequence", "description": "Find the longest strictly increasing subsequence. DP approach: dp[i] = length of LIS ending at index i. For each i, check all j < i where nums[j] < nums[i]. O(n²). Optimized: use patience sorting with binary search for O(n log n). Very commonly asked.", "briefDescription": "Find longest strictly increasing subsequence — O(n²) or O(n log n).", "priority": "imp" },
            { "id": "coin-change", "title": "Coin Change", "description": "Given coin denominations, find minimum coins to make a target amount. dp[i] = minimum coins for amount i. For each amount, try each coin: dp[i] = min(dp[i], dp[i-coin] + 1). O(amount × coins) time. Variant: count the number of ways to make the amount (change-making problem).", "briefDescription": "Minimum coins to reach a target amount.", "priority": "must" },
            { "id": "edit-distance", "title": "Edit Distance", "description": "Minimum operations (insert, delete, replace) to transform one string into another. dp[i][j] = edit distance between first i chars of s1 and first j chars of s2. If chars match: dp[i-1][j-1]. Else: 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]). O(n×m). Used in spell checkers and DNA alignment.", "briefDescription": "Minimum insertions, deletions, replacements between strings.", "priority": "imp" },
            { "id": "matrix-chain", "title": "Matrix Chain Multiplication", "description": "Find the optimal parenthesization of matrix multiplications to minimize total scalar multiplications. dp[i][j] = minimum cost to multiply matrices i through j. Try all split points k: dp[i][j] = min(dp[i][k] + dp[k+1][j] + cost(i,k,j)). O(n³) time. Classic interval DP problem.", "briefDescription": "Optimal ordering of matrix multiplications — interval DP.", "priority": "look" },
            { "id": "dp-trees", "title": "DP on Trees", "description": "Dynamic programming where the subproblem structure follows tree edges. Process nodes bottom-up (post-order). Examples: diameter of tree, maximum path sum, house robber on tree, minimum vertex cover. State at each node depends on states of its children. DFS naturally gives bottom-up processing.", "briefDescription": "DP following tree structure with bottom-up processing.", "priority": "look" },
            { "id": "dp-grids", "title": "DP on Grids", "description": "Problems on 2D grids where movement is restricted (e.g., only right and down). dp[i][j] = optimal value to reach cell (i,j). Examples: unique paths, minimum path sum, dungeon game, maximal square. Transition uses dp[i-1][j] and dp[i][j-1]. Space-optimizable to O(columns) using a single row.", "briefDescription": "2D DP for grid traversal and optimization problems.", "priority": "imp" }
          ]
        },
        {
          "id": "sorting",
          "title": "Sorting Algorithms",
          "description": "Organizing data in a specific order. Understanding sorting algorithms reveals fundamental CS concepts: divide & conquer, in-place vs extra space, stability, and time complexity tradeoffs. Interviewers may ask you to implement merge sort or quicksort, or choose the right sort for a scenario.",
          "briefDescription": "Core sorting algorithms, their tradeoffs, and when to use each.",
          "priority": "imp",
          "children": [
            { "id": "bubble-sort", "title": "Bubble Sort", "description": "Repeatedly swap adjacent elements if they're in the wrong order. After each pass, the largest unsorted element 'bubbles' to its correct position. O(n²) average/worst, O(n) best (already sorted with early termination). Stable, in-place. Only useful for educational purposes; never optimal in practice.", "briefDescription": "O(n²) swap-adjacent sorting — educational only.", "priority": "look" },
            { "id": "selection-sort", "title": "Selection Sort", "description": "Find the minimum element in unsorted portion, swap it with the first unsorted element. O(n²) always (no best case optimization). Not stable, in-place. Minimizes the number of swaps (exactly n-1). Useful when memory writes are expensive.", "briefDescription": "O(n²) find-minimum sorting with minimal swaps.", "priority": "look" },
            { "id": "insertion-sort", "title": "Insertion Sort", "description": "Build sorted array one element at a time by inserting each element into its correct position in the sorted portion. O(n²) average/worst, O(n) best (nearly sorted). Stable, in-place, adaptive. Excellent for small arrays (used as base case in hybrid sorts like Timsort).", "briefDescription": "O(n) for nearly-sorted data — used in hybrid algorithms.", "priority": "imp" },
            { "id": "merge-sort", "title": "Merge Sort", "description": "Divide & conquer: split array in half, recursively sort each half, merge the sorted halves. O(n log n) guaranteed for all cases. Stable but requires O(n) extra space. The merge step is the key — compare elements from both halves and place smaller one first. JavaScript's sort uses Timsort (merge sort + insertion sort).", "briefDescription": "O(n log n) guaranteed, stable, divide-and-conquer sorting.", "priority": "must" },
            {
              "id": "quick-sort",
              "title": "Quick Sort",
              "description": "Divide & conquer: choose a pivot, partition array so elements < pivot are left and > pivot are right, recursively sort partitions. O(n log n) average, O(n²) worst (bad pivot). In-place, not stable. Fastest in practice due to cache efficiency. Choosing a good pivot (median-of-three, random) avoids worst case.",
              "briefDescription": "O(n log n) average, fastest in practice, in-place.",
              "priority": "must",
              "children": [
                { "id": "partition-schemes", "title": "Partition Schemes (Lomuto, Hoare)", "description": "Lomuto: single pointer from left, pivot is last element, simpler but more swaps. Hoare: two pointers from both ends, fewer swaps, more efficient. Hoare doesn't place pivot in final position. Both are O(n) per partition call. Three-way partition handles many duplicates efficiently (Dutch National Flag).", "briefDescription": "Different strategies for partitioning around the pivot.", "priority": "imp" }
              ]
            },
            { "id": "heap-sort-algo", "title": "Heap Sort", "description": "Build a max-heap from the array, repeatedly extract maximum and place at end. O(n log n) guaranteed, in-place, not stable. Combines heap property with sorting. Worse cache performance than quicksort but guaranteed O(n log n) without extra space (unlike merge sort).", "briefDescription": "O(n log n) guaranteed, in-place, uses heap property.", "priority": "imp" },
            { "id": "counting-sort", "title": "Counting Sort", "description": "Count occurrences of each value, then place elements based on counts. O(n + k) where k is the range of values. Not comparison-based — breaks the O(n log n) lower bound. Only works for integers in a known range. Stable if implemented correctly. Used as a subroutine in radix sort.", "briefDescription": "O(n+k) non-comparison sort for bounded integer ranges.", "priority": "look" },
            { "id": "radix-sort", "title": "Radix Sort", "description": "Sort numbers digit by digit (LSD or MSD) using a stable sort (counting sort) at each digit position. O(d × (n + k)) where d is number of digits and k is the base. Not comparison-based. Very efficient for fixed-length keys like phone numbers, IPs. Requires a stable intermediate sort.", "briefDescription": "Sort digit-by-digit using a stable subroutine.", "priority": "look" },
            { "id": "bucket-sort", "title": "Bucket Sort", "description": "Distribute elements into buckets based on value range. Sort each bucket individually (often with insertion sort). Works best when input is uniformly distributed. O(n + k) average when data is uniform, O(n²) worst. Not a general-purpose sort but excellent for specific distributions.", "briefDescription": "Distribute into buckets, sort each — O(n) for uniform data.", "priority": "skip" }
          ]
        },
        {
          "id": "searching",
          "title": "Searching Algorithms",
          "description": "Finding elements or optimal values efficiently. Binary search is the most important — it applies far beyond sorted arrays. 'Binary search on answer' is a meta-pattern where you binary search over the solution space rather than the input. Master the template to handle edge cases cleanly.",
          "briefDescription": "Linear, binary, and advanced search techniques.",
          "priority": "must",
          "children": [
            { "id": "linear-search", "title": "Linear Search", "description": "Scan each element sequentially until found. O(n) time, O(1) space. Works on unsorted data. Use when data is small, unsorted, or you need to find all occurrences. In JavaScript, Array.find(), Array.indexOf(), Array.includes() perform linear search internally.", "briefDescription": "O(n) sequential scan — simplest search.", "priority": "imp" },
            {
              "id": "binary-search",
              "title": "Binary Search",
              "description": "Halve the search space each step by comparing with the middle element. Requires sorted data. O(log n) time, O(1) space. The most important search algorithm. Key implementation detail: use left + (right - left) / 2 to avoid overflow, and be precise about inclusive/exclusive bounds.",
              "briefDescription": "O(log n) search by halving — the most important search algorithm.",
              "priority": "must",
              "children": [
                { "id": "lower-upper-bound", "title": "Lower Bound / Upper Bound", "description": "Lower bound: first position where element could be inserted maintaining order (first element ≥ target). Upper bound: first position after all equal elements (first element > target). These handle duplicates which basic binary search can't. Crucial for range queries and counting occurrences.", "briefDescription": "Finding insertion points for handling duplicates.", "priority": "imp" },
                { "id": "rotated-sorted", "title": "Search in Rotated Sorted Array", "description": "A sorted array rotated at some pivot. One half is always sorted. Compare target with mid and sorted half to decide which side to search. O(log n). Key insight: check if left half or right half is sorted, then check if target lies in the sorted half. Handle duplicates separately.", "briefDescription": "Binary search on a rotated sorted array.", "priority": "must" },
                { "id": "bs-on-answer", "title": "Binary Search on Answer", "description": "Instead of searching in the input, binary search over the solution space. Define a feasibility function that checks if a candidate answer works. Binary search finds the optimal feasible answer. Examples: minimum capacity to ship packages in D days, Koko eating bananas, split array largest sum. Very powerful pattern.", "briefDescription": "Search the solution space using a feasibility check.", "priority": "must" }
              ]
            },
            { "id": "ternary-search", "title": "Ternary Search", "description": "Divides search space into three parts to find the maximum/minimum of a unimodal function. Compare function values at two mid points to eliminate one third per step. O(log₃ n) comparisons but each step has more comparisons than binary search. Rarely needed — binary search on derivative is usually better.", "briefDescription": "Search for extrema of unimodal functions.", "priority": "skip" }
          ]
        },
        {
          "id": "greedy",
          "title": "Greedy Algorithms",
          "description": "Make the locally optimal choice at each step hoping to find the global optimum. Greedy works when the problem has the greedy choice property (local optimum leads to global optimum) and optimal substructure. Simpler than DP when applicable. Key: prove the greedy choice is safe.",
          "briefDescription": "Locally optimal choices leading to global solutions.",
          "priority": "imp",
          "children": [
            { "id": "activity-selection", "title": "Activity Selection", "description": "Select the maximum number of non-overlapping activities. Greedy: sort by end time, always pick the activity that finishes earliest and doesn't conflict with previously selected. This greedy choice provably gives optimal solution. O(n log n) for sorting + O(n) for selection. Foundation for interval scheduling.", "briefDescription": "Pick maximum non-overlapping activities by earliest end time.", "priority": "imp" },
            { "id": "fractional-knapsack", "title": "Fractional Knapsack", "description": "Unlike 0/1 knapsack, you can take fractions of items. Greedy: sort by value/weight ratio descending, take items greedily until capacity is full. O(n log n). This works because the greedy choice property holds for fractional items. Contrast with 0/1 knapsack which requires DP.", "briefDescription": "Take highest value-per-weight items, allowing fractions.", "priority": "imp" },
            { "id": "huffman-coding", "title": "Huffman Coding", "description": "Build an optimal prefix-free encoding by merging the two least frequent characters repeatedly into a tree. Characters with higher frequency get shorter codes. Uses a min-heap to efficiently find the two smallest. Results in variable-length encoding with no ambiguity. Foundation of data compression.", "briefDescription": "Optimal variable-length encoding using frequency-based tree.", "priority": "look" },
            { "id": "interval-scheduling", "title": "Interval Scheduling", "description": "Schedule the maximum number of non-overlapping intervals, or find the minimum number of resources needed for all intervals. Sort by start or end time. Merge overlapping intervals by comparing current start with previous end. Common variants: meeting rooms, insert interval, non-overlapping intervals.", "briefDescription": "Optimize scheduling using sorted intervals.", "priority": "imp" }
          ]
        }
      ]
    },
    {
      "id": "javascript-core",
      "title": "JavaScript (Core Language)",
      "description": "JavaScript is the backbone of MERN development. Deep understanding of its runtime behavior, scoping rules, asynchronous patterns, and prototype-based inheritance is essential. Interviewers probe execution context, closures, the event loop, promises, and ES6+ features to gauge true language mastery.",
      "briefDescription": "Core JavaScript concepts: scope, closures, async, prototypes, ES6+.",
      "priority": "must",
      "children": [
        {
          "id": "execution-context",
          "title": "Execution Context",
          "description": "When JavaScript code runs, an execution context is created. It holds the environment in which code is executed, including variable bindings, `this` reference, and the scope chain. Understanding execution contexts explains hoisting, closures, and how `this` behaves in different scenarios.",
          "briefDescription": "The environment in which JavaScript code is evaluated and executed.",
          "priority": "must",
          "children": [
            { "id": "global-execution-context", "title": "Global Execution Context", "description": "Created when the script first runs. Only one exists per program. Sets up the global object (window in browsers, global in Node) and `this` pointing to it. All top-level variables and functions are stored here. Understanding this context is key to knowing why variables 'leak' to global scope.", "briefDescription": "The default context created when a script starts.", "priority": "must" },
            { "id": "function-execution-context", "title": "Function Execution Context", "description": "Created each time a function is invoked. Contains the function's local variables, parameters, and a reference to the outer environment. Each invocation creates a new context, which is why recursive calls don't share state. Popped from the stack when the function returns.", "briefDescription": "A new context created for each function call.", "priority": "must" },
            { "id": "execution-stack", "title": "Execution Stack (Call Stack)", "description": "A LIFO stack that tracks execution contexts. The global context sits at the bottom. When a function is called, its context is pushed; when it returns, it's popped. Stack overflow occurs when the stack exceeds its limit (e.g., infinite recursion). The call stack is what debuggers display during breakpoints.", "briefDescription": "LIFO stack tracking the order of function executions.", "priority": "must" }
          ]
        },
        {
          "id": "hoisting",
          "title": "Hoisting",
          "description": "JavaScript's behavior of moving declarations to the top of their scope during compilation. Variables declared with `var` are hoisted and initialized to undefined, while `let` and `const` are hoisted but remain in the Temporal Dead Zone until their declaration is reached. Function declarations are fully hoisted.",
          "briefDescription": "Declaration hoisting behavior and the Temporal Dead Zone.",
          "priority": "must",
          "children": [
            { "id": "var-hoisting", "title": "Variable Hoisting (var vs let/const)", "description": "`var` declarations are hoisted to the top of their function scope and initialized to undefined — so accessing before declaration gives undefined. `let` and `const` are block-scoped and hoisted but NOT initialized — accessing before declaration throws ReferenceError. This difference is critical for interview questions.", "briefDescription": "var initializes to undefined; let/const throw in TDZ.", "priority": "must" },
            { "id": "function-hoisting", "title": "Function Hoisting", "description": "Function declarations are fully hoisted — both the name and body are moved to the top. You can call a function before its declaration in code. Function expressions (assigned to variables) follow the hoisting rules of their variable type (var, let, const). Arrow functions are never hoisted as declarations.", "briefDescription": "Function declarations are fully hoisted; expressions are not.", "priority": "must" },
            { "id": "temporal-dead-zone", "title": "Temporal Dead Zone (TDZ)", "description": "The period between entering a scope and the actual declaration of a let/const variable. Accessing the variable during TDZ throws a ReferenceError, not undefined. TDZ exists specifically to catch errors earlier and enforce better coding practices. It applies to let, const, and class declarations.", "briefDescription": "The zone where let/const exist but cannot be accessed.", "priority": "imp" }
          ]
        },
        {
          "id": "scope",
          "title": "Scope",
          "description": "Scope determines the visibility and accessibility of variables. JavaScript uses lexical (static) scoping, meaning scope is determined at write-time, not runtime. Mastering scope is essential for closures, module patterns, and avoiding unintended variable access or pollution.",
          "briefDescription": "Variable visibility rules: global, function, block, lexical.",
          "priority": "must",
          "children": [
            { "id": "global-scope", "title": "Global Scope", "description": "Variables declared outside any function or block. Accessible from anywhere in the code. In browsers, global variables attach to the window object. Global scope pollution is a common anti-pattern — use modules or IIFE to avoid it. `var` at the top level creates globals; `let`/`const` do not attach to window.", "briefDescription": "Top-level scope accessible everywhere.", "priority": "must" },
            { "id": "function-scope", "title": "Function Scope", "description": "Variables declared with `var` inside a function are scoped to that function. They're not accessible outside. Each function creates its own scope. This is why closures work — inner functions retain access to outer function's variables even after the outer function returns.", "briefDescription": "Variables scoped to the containing function.", "priority": "must" },
            { "id": "block-scope", "title": "Block Scope", "description": "Introduced with ES6 `let` and `const`. Variables are scoped to the nearest enclosing block (if, for, while, or just {}). Unlike `var`, they don't leak outside the block. This makes code more predictable and is the reason `let` is preferred in modern JavaScript.", "briefDescription": "let/const scoped to the nearest block.", "priority": "must" },
            { "id": "lexical-scope", "title": "Lexical Scope", "description": "Scope is determined by where functions are written in the source code, not where they are called. Inner functions can access variables from outer functions. This is the foundation of closures. JavaScript always looks up the scope chain to resolve variable references.", "briefDescription": "Scope determined at author-time, not runtime.", "priority": "must" },
            { "id": "scope-chain", "title": "Scope Chain", "description": "When a variable is referenced, JavaScript searches the current scope, then outer scopes, up to the global scope. This chain is established when functions are created. Each execution context has a reference to its outer environment, forming the chain. Variable shadowing occurs when a local variable has the same name as an outer one.", "briefDescription": "The chain JavaScript traverses to resolve variables.", "priority": "imp" }
          ]
        },
        {
          "id": "closures",
          "title": "Closures",
          "description": "A closure is a function that retains access to its lexical scope even when executed outside that scope. This is one of the most powerful features in JavaScript, enabling data privacy, factory functions, currying, and maintaining state in asynchronous operations.",
          "briefDescription": "Functions that remember their lexical environment.",
          "priority": "must",
          "children": [
            { "id": "closure-use-cases", "title": "Practical Use Cases", "description": "Closures are everywhere: callbacks in async operations, event handlers, factory functions, iterators, memoization, and partial application. React Hooks rely heavily on closures. Common interview patterns: create a counter with private state, implement throttle/debounce, explain why setTimeout in a loop prints the same value.", "briefDescription": "Real-world applications of closures.", "priority": "must" },
            { "id": "closure-memory-leaks", "title": "Memory Leaks with Closures", "description": "Closures keep their enclosing scope alive. If a closure references large objects or DOM elements, they can't be garbage collected. Common leak: event handlers on removed DOM elements. Solution: nullify references, use WeakMap, or explicitly clean up. Understanding this is critical for performance-sensitive applications.", "briefDescription": "How closures can prevent garbage collection.", "priority": "imp" },
            { "id": "module-pattern", "title": "Module Pattern", "description": "Pre-ES6 pattern using closures to create private state. Return an object with public methods that access private variables via closure. This encapsulation pattern influenced ES6 modules. Example: IIFE returning an object with get/set methods while keeping internal state private.", "briefDescription": "Using closures to create private module state.", "priority": "imp" },
            { "id": "data-privacy", "title": "Data Privacy", "description": "JavaScript doesn't have traditional private members, but closures provide true privacy. Variables in the enclosing function are not accessible from outside — only through the returned function. ES2022 introduced #private fields, but closure-based privacy is still widely used and understood differently.", "briefDescription": "Achieving true encapsulation with closures.", "priority": "imp" },
            { "id": "currying-closures", "title": "Currying with Closures", "description": "Currying transforms a function with multiple arguments into a sequence of functions each taking one argument. Each function returns another function via closure until all arguments are collected. Enables partial application and function composition. Example: curry(add)(2)(3) returns 5.", "briefDescription": "Transform multi-arg functions into chains of single-arg functions.", "priority": "imp" }
          ]
        },
        {
          "id": "this-keyword",
          "title": "`this` Keyword",
          "description": "The `this` keyword refers to the object that is executing the current function. Its value depends on HOW the function is called, not where it's defined — except for arrow functions, which inherit `this` lexically. Mastering `this` is essential for object-oriented patterns and event handling.",
          "briefDescription": "Dynamic binding rules for the this keyword.",
          "priority": "must",
          "children": [
            { "id": "this-global", "title": "In Global Context", "description": "In the global context (outside any function), `this` refers to the global object (window in browsers, globalThis in ES2020). In strict mode, `this` is undefined at the top level of modules. This is why you can accidentally create global variables by assigning to this.property in the global scope.", "briefDescription": "this in global scope points to the global object.", "priority": "imp" },
            { "id": "this-object-methods", "title": "In Object Methods", "description": "When a function is called as a method of an object, `this` refers to that object. The key insight: it's the object before the dot at call time. However, if you extract the method and call it standalone, `this` is lost. This is the common 'lost this' bug in callbacks.", "briefDescription": "this refers to the object calling the method.", "priority": "must" },
            { "id": "this-arrow-functions", "title": "In Arrow Functions", "description": "Arrow functions do NOT have their own `this`. They lexically inherit `this` from the enclosing scope at definition time. This makes them perfect for callbacks and event handlers inside methods. They cannot be used as constructors or with call/apply/bind to change `this`.", "briefDescription": "Arrow functions inherit this lexically.", "priority": "must" },
            { "id": "call-apply-bind", "title": "call(), apply(), bind()", "description": "Methods to explicitly set `this`. `call(thisArg, arg1, arg2)` calls the function immediately with given `this` and arguments. `apply(thisArg, [args])` is the same but takes an array. `bind(thisArg)` returns a new function with `this` permanently bound. Use bind for callbacks that would lose `this`.", "briefDescription": "Explicit methods to control the this value.", "priority": "must" },
            { "id": "this-event-handlers", "title": "`this` in Event Handlers", "description": "In traditional event handlers, `this` refers to the DOM element that received the event. With arrow functions in React, `this` inherits from the component class. Using class fields with arrow functions auto-binds `this`. In modern React with hooks, class-based `this` issues are avoided entirely.", "briefDescription": "Event handler this behavior in DOM and React.", "priority": "imp" },
            { "id": "this-classes", "title": "`this` in Classes", "description": "In class constructors and methods, `this` refers to the instance being created or operated on. Arrow function class fields auto-bind `this` to the instance. Traditional methods lose `this` when passed as callbacks — must be bound in constructor or use arrow function syntax.", "briefDescription": "this behavior in ES6 class constructors and methods.", "priority": "imp" }
          ]
        },
        {
          "id": "prototypes-inheritance",
          "title": "Prototypes & Inheritance",
          "description": "JavaScript uses prototype-based inheritance, not classical inheritance. Every object has a hidden [[Prototype]] link to another object. Property lookup follows this prototype chain. ES6 classes are syntactic sugar over prototypes. Understanding this is crucial for interviews and advanced patterns.",
          "briefDescription": "Prototype chain, ES6 classes, and inheritance patterns.",
          "priority": "must",
          "children": [
            { "id": "prototype-chain", "title": "Prototype Chain", "description": "When accessing a property, JavaScript first checks the object itself, then its prototype, then the prototype's prototype, up to Object.prototype (which has null as its prototype). This chain enables inheritance. Objects inherit methods without copying them — they share via the chain.", "briefDescription": "Property lookup traverses the prototype chain.", "priority": "must" },
            { "id": "proto-vs-prototype", "title": "`__proto__` vs `prototype`", "description": "`__proto__` (deprecated, use Object.getPrototypeOf) is the actual link in the prototype chain — every object has it. `prototype` is a property only on functions, used to set the [[Prototype]] of objects created with `new`. Understanding this distinction is a classic interview question.", "briefDescription": "Instance property vs constructor property.", "priority": "must" },
            { "id": "object-create", "title": "Object.create()", "description": "Creates a new object with the specified prototype. Allows creating objects without constructors. Object.create(null) creates an object with no prototype — a truly empty object, useful for dictionaries. More explicit than constructor functions for prototype setup.", "briefDescription": "Create objects with a specified prototype.", "priority": "imp" },
            { "id": "constructor-functions", "title": "Constructor Functions", "description": "Functions intended to be used with `new`. By convention, capitalized. `new` creates an empty object, sets its prototype to Constructor.prototype, runs the function with `this` bound to the new object, and returns the object. This is how objects were created before ES6 classes.", "briefDescription": "Pre-ES6 pattern for creating object instances.", "priority": "imp" },
            {
              "id": "es6-classes",
              "title": "ES6 Classes",
              "description": "Syntactic sugar over prototypes. Provide familiar class-based syntax with constructor, methods, static members, and inheritance. Under the hood, they work exactly like constructor functions and prototypes. Classes are not hoisted (unlike function declarations).",
              "briefDescription": "Modern class syntax — syntactic sugar over prototypes.",
              "priority": "must",
              "children": [
                { "id": "class-constructor", "title": "Constructor", "description": "The constructor method is called when creating a new instance with `new`. Initialize instance properties here. Only one constructor per class. If not defined, an empty constructor is used. Super() must be called first in derived class constructors before accessing `this`.", "briefDescription": "Instance initialization method called with new.", "priority": "must" },
                { "id": "class-methods", "title": "Methods", "description": "Defined inside the class body without the function keyword. They're added to the prototype, so all instances share them. Methods have access to `this` (the instance). Unlike object literals, no commas between methods. Methods are non-enumerable by default.", "briefDescription": "Instance methods shared via the prototype.", "priority": "must" },
                { "id": "static-methods", "title": "Static Methods", "description": "Defined with the static keyword. Called on the class itself, not instances. Used for utility functions, factory methods, or class-level operations. Static methods don't have access to instance `this`. Example: Array.isArray(), Object.keys().", "briefDescription": "Methods called on the class, not instances.", "priority": "imp" },
                { "id": "private-fields", "title": "Private Fields (#)", "description": "ES2022 added true private fields with # prefix. They're not accessible outside the class — not even via reflection. Unlike closure-based privacy, private fields are per-instance and type-checked at runtime. Private methods and accessors are also supported.", "briefDescription": "True privacy with the # prefix syntax.", "priority": "imp" },
                { "id": "getters-setters", "title": "Getters & Setters", "description": "Define properties with get and set keywords. Getters compute on access, setters validate/transform on assignment. Look like properties but are methods internally. Useful for derived properties, validation, and triggering side effects. Common pattern for computed values.", "briefDescription": "Property accessors with custom logic.", "priority": "imp" }
              ]
            },
            { "id": "class-inheritance", "title": "Class Inheritance (extends, super)", "description": "Use `extends` to create a child class. The child inherits all properties and methods from the parent. `super()` in the constructor calls the parent constructor — must be called before using `this`. super.method() calls parent methods. JavaScript only supports single inheritance.", "briefDescription": "extends for subclassing, super for parent access.", "priority": "must" },
            { "id": "mixins", "title": "Mixins", "description": "Pattern to add functionality from multiple sources without multiple inheritance. Use Object.assign() or spread to copy methods from mixin objects into a class prototype. Composition over inheritance — combine behaviors from multiple sources. Popular in frameworks and utility libraries.", "briefDescription": "Composing behavior from multiple sources.", "priority": "look" }
          ]
        },
        {
          "id": "data-types-coercion",
          "title": "Data Types & Coercion",
          "description": "JavaScript has 7 primitive types and reference types (objects). Understanding type coercion — how JavaScript automatically converts between types — is essential for avoiding bugs and acing interview questions about == vs ===, truthy/falsy values, and type checking.",
          "briefDescription": "Primitives, references, and automatic type conversion.",
          "priority": "must",
          "children": [
            { "id": "primitive-types", "title": "Primitive Types", "description": "7 primitives: string, number, bigint, boolean, undefined, null, symbol. Primitives are immutable and compared by value. null and undefined are often confused — undefined means 'no value assigned', null means 'intentionally empty'. BigInt (ES2020) handles integers beyond Number.MAX_SAFE_INTEGER.", "briefDescription": "The 7 primitive types and their characteristics.", "priority": "must" },
            { "id": "reference-types", "title": "Reference Types", "description": "Objects, arrays, functions — stored by reference. Variables hold a pointer to the memory location, not the value itself. Assigning to another variable creates a reference, not a copy. Changing one affects the other. Use spread, Object.assign, or structuredClone for shallow/deep copies.", "briefDescription": "Objects stored by reference, not value.", "priority": "must" },
            {
              "id": "type-coercion",
              "title": "Type Coercion",
              "description": "JavaScript automatically converts types in certain operations. Understanding coercion explains why [] == false is true. Know the abstract equality algorithm and ToNumber/ToString/ToBoolean abstract operations. Interviewers love tricky coercion questions.",
              "briefDescription": "Automatic type conversion rules.",
              "priority": "must",
              "children": [
                { "id": "implicit-explicit-coercion", "title": "Implicit vs Explicit", "description": "Implicit coercion happens automatically ('5' - 2 = 3). Explicit coercion is intentional (Number('5'), String(5), Boolean(1)). Prefer explicit for clarity. Common implicit: + with strings = concatenation, - with strings = subtraction, ! for boolean. Know the quirks.", "briefDescription": "Automatic vs intentional type conversion.", "priority": "must" },
                { "id": "double-vs-triple-equals", "title": "== vs ===", "description": "=== (strict equality) checks type AND value — no coercion. == (abstract equality) allows type coercion before comparison. 1 == '1' is true, 1 === '1' is false. Always prefer ===. The == algorithm is complex (11 steps!) and leads to unintuitive results.", "briefDescription": "Strict vs loose equality operators.", "priority": "must" },
                { "id": "truthy-falsy", "title": "Truthy & Falsy Values", "description": "Falsy values: false, 0, -0, 0n (BigInt), '', null, undefined, NaN. Everything else is truthy (including '0', 'false', [], {}). Important for conditionals. || returns the first truthy or last value. && returns the first falsy or last value. ?? (nullish coalescing) only checks null/undefined.", "briefDescription": "Values that coerce to true or false in boolean context.", "priority": "must" }
              ]
            },
            { "id": "typeof-instanceof", "title": "typeof & instanceof", "description": "typeof returns a string: 'string', 'number', 'boolean', 'undefined', 'object', 'function', 'symbol', 'bigint'. typeof null === 'object' is a famous bug. instanceof checks the prototype chain. Array.isArray() is preferred for arrays. typeof works for primitives, instanceof for objects.", "briefDescription": "Type checking operators and their quirks.", "priority": "imp" },
            {
              "id": "symbol",
              "title": "Symbol",
              "description": "Unique, immutable primitive introduced in ES6. Used for unique property keys that won't clash. Symbols are not enumerable by default. Well-known symbols customize built-in behaviors. Symbol.for() creates/retrieves global symbols.",
              "briefDescription": "Unique identifier primitive for object keys.",
              "priority": "imp",
              "children": [
                { "id": "well-known-symbols", "title": "Well-known Symbols", "description": "Built-in symbols that customize object behavior. Symbol.iterator defines iteration behavior. Symbol.toStringTag customizes Object.prototype.toString. Symbol.hasInstance customizes instanceof. Symbol.toPrimitive controls type coercion. These enable powerful meta-programming patterns.", "briefDescription": "Built-in symbols for customizing object behavior.", "priority": "look" },
                { "id": "symbol-iterator", "title": "Symbol.iterator", "description": "Defines how an object is iterated. The method returns an iterator with a next() method. Implement Symbol.iterator to make any object work with for...of, spread, and destructuring. This is how arrays, strings, maps, and sets are iterable by default.", "briefDescription": "Make any object iterable with for...of.", "priority": "imp" }
              ]
            }
          ]
        },
        {
          "id": "functions",
          "title": "Functions",
          "description": "Functions are first-class citizens in JavaScript — they can be passed as arguments, returned from functions, and assigned to variables. Understanding function types, higher-order patterns, and generator functions is essential for functional programming and async patterns.",
          "briefDescription": "First-class functions, HOFs, generators, and advanced patterns.",
          "priority": "must",
          "children": [
            { "id": "function-declaration-expression", "title": "Function Declaration vs Expression", "description": "Declarations use the function keyword and are fully hoisted: function foo() {}. Expressions assign an anonymous/named function to a variable: const foo = function() {}. Expressions follow the hoisting rules of their variable. Named function expressions are useful for recursion and stack traces.", "briefDescription": "Hoisting and syntax differences between declaration styles.", "priority": "must" },
            { "id": "arrow-functions", "title": "Arrow Functions", "description": "Concise syntax with lexical `this` binding: (params) => expression or (params) => { statements }. Cannot be used as constructors, don't have arguments object, don't have their own `this`, super, or new.target. Ideal for callbacks and functional patterns.", "briefDescription": "Concise syntax with lexical this — ideal for callbacks.", "priority": "must" },
            { "id": "iife", "title": "IIFE (Immediately Invoked Function Expression)", "description": "A function that executes immediately after creation: (function() { ... })() or (() => { ... })(). Creates a new scope to avoid polluting global namespace. Was essential pre-ES6 for modules. Still useful for one-time initialization and async IIFEs.", "briefDescription": "Execute a function immediately upon definition.", "priority": "imp" },
            { "id": "higher-order-functions", "title": "Higher-Order Functions", "description": "Functions that take functions as arguments or return functions. Array methods like map, filter, reduce are HOFs. Custom HOFs enable composition, decoration, and abstraction. The foundation of functional programming in JavaScript. Essential for understanding React and middleware patterns.", "briefDescription": "Functions that operate on other functions.", "priority": "must" },
            { "id": "callback-functions", "title": "Callback Functions", "description": "Functions passed to other functions to be called later. The original async pattern in JavaScript. Callbacks become hard to manage when nested (callback hell). Promises and async/await address this. Still used in event handlers, array methods, and some Node APIs.", "briefDescription": "Functions passed to be invoked later.", "priority": "must" },
            { "id": "pure-functions", "title": "Pure Functions", "description": "Functions with no side effects that always return the same output for the same input. Don't modify external state, don't use mutable global variables. Essential for React state updates, Redux reducers, and predictable code. Easier to test, debug, and optimize.", "briefDescription": "Deterministic functions without side effects.", "priority": "imp" },
            { "id": "function-composition", "title": "Function Composition", "description": "Combining simple functions to create complex ones: compose(f, g)(x) = f(g(x)). Each function takes the output of the previous. pipe() applies left-to-right, compose() applies right-to-left. Enables declarative code and reusable building blocks. Common in functional libraries.", "briefDescription": "Combine small functions into larger pipelines.", "priority": "imp" },
            { "id": "rest-spread-params", "title": "Rest & Spread Parameters", "description": "Rest (...args) gathers remaining arguments into an array. Spread (...array) expands an array into individual elements. Rest is in function definitions, spread is in function calls and literals. Use spread for shallow copying arrays/objects and merging.", "briefDescription": "... for gathering and expanding elements.", "priority": "must" },
            { "id": "default-parameters", "title": "Default Parameters", "description": "Set default values for function parameters: function foo(x = 10). Defaults apply when argument is undefined (not null). Default expressions are evaluated at call time. Can reference earlier parameters. Can even call functions as defaults.", "briefDescription": "Fallback values for undefined arguments.", "priority": "imp" },
            { "id": "arguments-object", "title": "Arguments Object", "description": "Array-like object containing all arguments passed to a non-arrow function. Available in traditional functions, not in arrow functions. Has length but no array methods. Use Array.from(arguments) or [...arguments] to convert. Rest parameters are the modern replacement.", "briefDescription": "Legacy array-like object of all passed arguments.", "priority": "look" },
            {
              "id": "generator-functions",
              "title": "Generator Functions",
              "description": "Functions declared with function* that can pause and resume execution using yield. Return an iterator. Valuable for lazy evaluation, infinite sequences, and managing async flow. Used internally by async/await. Understanding generators deepens knowledge of iterators and coroutines.",
              "briefDescription": "Pausable functions using yield for iterators.",
              "priority": "imp",
              "children": [
                { "id": "yield-keyword", "title": "yield", "description": "Pauses function execution and returns a value. When next() is called, execution resumes from the yield. yield* delegates to another generator or iterable. yield can also receive values passed to next(value). This enables two-way communication with the generator.", "briefDescription": "Pause execution and emit a value.", "priority": "imp" },
                { "id": "iterators-iterables", "title": "Iterators & Iterables", "description": "Iterator: object with next() returning { value, done }. Iterable: object with Symbol.iterator method returning an iterator. Generators automatically create both. for...of works with any iterable. Understanding this protocol enables custom iteration patterns.", "briefDescription": "The iteration protocol powering for...of.", "priority": "imp" },
                { "id": "for-of", "title": "for...of", "description": "Iterates over iterable objects (arrays, strings, maps, sets, generators). Unlike for...in (which iterates over keys), for...of iterates over values. Works with any object implementing Symbol.iterator. Can be used with destructuring for entries().", "briefDescription": "Loop over values of any iterable object.", "priority": "imp" }
              ]
            }
          ]
        },
        {
          "id": "promises-async",
          "title": "Promises & Async",
          "description": "Promises represent eventual completion or failure of async operations. Async/await is syntactic sugar over promises for cleaner code. Understanding promise states, chaining, error handling, and the microtask queue is critical for writing correct async code and acing interview questions.",
          "briefDescription": "Promise API, async/await, and async error handling.",
          "priority": "must",
          "children": [
            { "id": "promise-states", "title": "Promise States", "description": "A promise is in one of three states: pending (initial), fulfilled (success), or rejected (failure). State transitions are one-way and irreversible. Once settled (fulfilled or rejected), a promise's state and value are fixed. Calling resolve() or reject() twice has no effect.", "briefDescription": "pending → fulfilled or rejected (irreversible).", "priority": "must" },
            { "id": "then-catch-finally", "title": ".then(), .catch(), .finally()", "description": ".then(onFulfilled, onRejected) registers handlers for success/failure. Returns a new promise for chaining. .catch(onRejected) is shorthand for .then(null, onRejected). .finally(callback) runs regardless of outcome, useful for cleanup. Each returns a promise, enabling chains.", "briefDescription": "Handler methods for promise resolution and rejection.", "priority": "must" },
            { "id": "promise-all", "title": "Promise.all()", "description": "Takes an iterable of promises, returns a single promise that fulfills with an array of results when ALL succeed, or rejects immediately when ANY fails (fail-fast). Order of results matches input order. Use when you need all results and any failure is fatal.", "briefDescription": "Wait for all promises; fail-fast on any rejection.", "priority": "must" },
            { "id": "promise-allsettled", "title": "Promise.allSettled()", "description": "Wait for all promises to settle (fulfilled or rejected). Never short-circuits. Returns array of { status, value } or { status, reason } objects. Use when you want results from all promises regardless of individual failures. Added in ES2020.", "briefDescription": "Wait for all promises to complete, regardless of outcome.", "priority": "imp" },
            { "id": "promise-race", "title": "Promise.race()", "description": "Returns a promise that settles as soon as any promise settles (first to resolve OR reject). Use for timeouts: race your fetch against a timeout promise. The result is the fastest promise's value/reason. Useful for 'fastest wins' scenarios.", "briefDescription": "Settle with the first promise to resolve or reject.", "priority": "imp" },
            { "id": "promise-any", "title": "Promise.any()", "description": "Returns the first promise to fulfill. Ignores rejections unless all promises reject (then throws AggregateError). Opposite of race for rejections. Use when you want the first success and can tolerate some failures. Added in ES2021.", "briefDescription": "Resolve with the first fulfilled promise.", "priority": "look" },
            {
              "id": "async-await",
              "title": "Async/Await",
              "description": "Syntactic sugar over promises. async functions always return promises. await pauses execution until a promise settles, returning the value. Enables writing async code that reads synchronously. Must handle errors with try/catch.",
              "briefDescription": "Synchronous-style syntax for async operations.",
              "priority": "must",
              "children": [
                { "id": "async-try-catch", "title": "Error Handling with try/catch", "description": "wrap await calls in try/catch to handle rejections. Unhandled rejections in async functions propagate to the returned promise. Catch at the appropriate level. Consider a higher-order wrapper function for repetitive try/catch. Finally blocks work as expected.", "briefDescription": "Handle async errors with try/catch blocks.", "priority": "must" },
                { "id": "sequential-parallel", "title": "Sequential vs Parallel Execution", "description": "Sequential: await each promise one by one. Parallel: use Promise.all() with multiple awaits. const [a, b] = await Promise.all([fetchA(), fetchB()]). Sequential is simpler but slower when operations are independent. Know when to use each pattern.", "briefDescription": "await one-by-one vs Promise.all for parallelism.", "priority": "must" },
                { "id": "top-level-await", "title": "Top-Level Await", "description": "ES2022 allows await at the top level of ES modules (not CommonJS). The module's execution pauses until the awaited promise resolves. Other modules importing it wait for the async initialization. Useful for async configuration loading.", "briefDescription": "Use await outside async functions in ES modules.", "priority": "look" }
              ]
            },
            { "id": "microtask-macrotask", "title": "Microtask Queue vs Macrotask Queue", "description": "Microtasks (promise callbacks, queueMicrotask, MutationObserver) run before rendering and before the next macrotask. Macrotasks (setTimeout, setInterval, I/O) run one per event loop iteration. Microtasks have priority. Understanding this explains why Promise.then runs before setTimeout.", "briefDescription": "Microtasks execute before macrotasks.", "priority": "must" }
          ]
        },
        {
          "id": "event-loop",
          "title": "Event Loop",
          "description": "JavaScript's concurrency model. The event loop continuously checks the call stack and, when empty, moves tasks from the queues to the stack. Understanding this mechanism is crucial for predicting execution order and writing performant async code. A top interview topic.",
          "briefDescription": "JavaScript's concurrency model and task scheduling.",
          "priority": "must",
          "children": [
            { "id": "call-stack", "title": "Call Stack", "description": "A LIFO stack of execution contexts. When a function is called, it's pushed; when it returns, it's popped. JavaScript is single-threaded — only one stack. Long-running synchronous code blocks the stack. The stack must be empty before the event loop can process new tasks.", "briefDescription": "LIFO stack tracking synchronous execution.", "priority": "must" },
            { "id": "web-apis", "title": "Web APIs", "description": "Browser-provided APIs (setTimeout, fetch, DOM events) that run outside the JavaScript engine. When invoked, the engine offloads work to these APIs, which push callbacks to the appropriate queue when ready. This is how JavaScript achieves async behavior despite being single-threaded.", "briefDescription": "Browser APIs that enable async operations.", "priority": "must" },
            { "id": "callback-queue", "title": "Callback Queue (Task Queue)", "description": "Holds callbacks from macrotasks (setTimeout, setInterval, I/O, UI events). The event loop moves one task at a time to the call stack when the stack is empty. Each iteration of the event loop processes one macrotask plus all queued microtasks.", "briefDescription": "Queue for macrotask callbacks.", "priority": "must" },
            { "id": "microtask-queue", "title": "Microtask Queue", "description": "Higher-priority queue for promise callbacks, queueMicrotask(), and MutationObserver. After each macrotask and after the call stack empties, ALL microtasks are processed before any macrotask or rendering. This is why promise chains complete before setTimeout.", "briefDescription": "High-priority queue processed before macrotasks.", "priority": "must" },
            { "id": "rendering-pipeline", "title": "Rendering Pipeline", "description": "The browser's rendering cycle: Style → Layout → Paint → Composite. Rendering happens between event loop iterations, after microtasks, roughly every 16.6ms (60fps). Long tasks block rendering, causing jank. requestAnimationFrame callbacks run before rendering, ensuring smooth animations.", "briefDescription": "How rendering fits into the event loop.", "priority": "imp" },
            { "id": "settimeout-setinterval", "title": "setTimeout / setInterval", "description": "setTimeout schedules a callback after at least the specified delay (not exactly). setInterval repeats the callback. The delay is a minimum — if the call stack is busy, execution is delayed. Use clearTimeout/clearInterval to cancel. Nested setTimeout is more reliable than setInterval for consistent intervals.", "briefDescription": "Schedule callbacks after a minimum delay.", "priority": "must" },
            { "id": "requestanimationframe", "title": "requestAnimationFrame", "description": "Schedules a callback before the next repaint (~60fps). Automatically pauses in inactive tabs. Use for animations instead of setTimeout for smoother, battery-efficient animations. Returns an ID for cancelAnimationFrame. Callback receives a high-resolution timestamp.", "briefDescription": "Schedule animations synced to display refresh.", "priority": "imp" },
            { "id": "queuemicrotask", "title": "queueMicrotask", "description": "Adds a microtask directly to the microtask queue. Similar to Promise.resolve().then() but more explicit and slightly lighter. Use when you need microtask scheduling without creating a promise. Runs before setTimeout, before rendering, before requestAnimationFrame.", "briefDescription": "Directly add a callback to the microtask queue.", "priority": "look" }
          ]
        },
        {
          "id": "error-handling",
          "title": "Error Handling",
          "description": "Proper error handling prevents crashes, aids debugging, and improves user experience. Understand synchronous try/catch, async error patterns, custom errors, and global error handlers. Interviewers probe edge cases around promise rejections and error propagation.",
          "briefDescription": "try/catch, custom errors, and async error patterns.",
          "priority": "must",
          "children": [
            { "id": "try-catch-finally", "title": "try/catch/finally", "description": "try block contains code that might throw. catch block handles errors. finally always runs (even after return). Only catches synchronous errors — can't catch errors in callbacks unless wrapped. In async functions, use try/catch around await to catch rejections.", "briefDescription": "Synchronous exception handling blocks.", "priority": "must" },
            { "id": "custom-error-classes", "title": "Custom Error Classes", "description": "Extend Error to create domain-specific error types: class ValidationError extends Error {}. Set this.name = 'ValidationError'. Capture stack trace with Error.captureStackTrace (Node). Custom errors enable specific catch handling and better error categorization in logs.", "briefDescription": "Create domain-specific error types by extending Error.", "priority": "imp" },
            { "id": "error-types", "title": "Error Types", "description": "Built-in error types: TypeError (wrong type), ReferenceError (undefined variable), SyntaxError (parsing), RangeError (out of range), URIError (malformed URI), EvalError (eval issues). TypeError and ReferenceError are most common. Know what triggers each.", "briefDescription": "Built-in error types and when they occur.", "priority": "imp" },
            { "id": "error-propagation", "title": "Error Propagation", "description": "Errors bubble up the call stack until caught. Uncaught errors terminate synchronous execution. In the browser, uncaught errors fire the window 'error' event. In promises, uncaught rejections trigger unhandledrejection event. Always handle errors at an appropriate level.", "briefDescription": "How errors traverse the call stack.", "priority": "imp" },
            { "id": "unhandled-promise-rejections", "title": "Unhandled Promise Rejections", "description": "Promises without a .catch() or try/catch around await. In Node.js, unhandled rejections will terminate the process in future versions. Use process.on('unhandledRejection') to catch. In browsers, window.addEventListener('unhandledrejection'). Always chain a .catch() or wrap in try/catch.", "briefDescription": "Promise rejections without error handlers.", "priority": "imp" }
          ]
        },
        {
          "id": "array-methods",
          "title": "Array Methods",
          "description": "JavaScript arrays come with powerful built-in methods. Knowing which methods mutate and which return new arrays is essential for immutable patterns (React, Redux). Master map, filter, reduce, find, and their use cases.",
          "briefDescription": "Mutating vs non-mutating array operations.",
          "priority": "must",
          "children": [
            { "id": "mutating-methods", "title": "Mutating Methods", "description": "push, pop (end), shift, unshift (start), splice (anywhere), sort, reverse, fill. These modify the original array. In React state, avoid using these directly — clone first. push/pop are O(1), shift/unshift are O(n). sort mutates in-place, which catches many by surprise.", "briefDescription": "Methods that change the original array.", "priority": "must" },
            { "id": "non-mutating-methods", "title": "Non-Mutating Methods", "description": "map (transform), filter (subset), reduce (aggregate), find/findIndex (search), some/every (boolean test), includes, flat, flatMap, slice, concat, toSorted, toReversed. Return new arrays, leaving the original unchanged. Essential for functional and immutable patterns.", "briefDescription": "Methods that return new arrays.", "priority": "must" },
            { "id": "array-static-methods", "title": "Array.from(), Array.of(), Array.isArray()", "description": "Array.from(iterable) creates array from array-like or iterable (NodeList, arguments, Set). Array.of(elements) creates array from arguments (unlike Array() constructor quirks). Array.isArray() reliably checks if value is an array (typeof returns 'object'). Know when to use each.", "briefDescription": "Static methods for creating and checking arrays.", "priority": "imp" },
            { "id": "array-destructuring", "title": "Destructuring", "description": "Extract elements into variables: const [a, b] = [1, 2]. Skip elements: const [, , c] = [1, 2, 3]. Rest pattern: const [first, ...rest] = arr. Default values: const [a = 10] = []. Swap variables: [a, b] = [b, a]. Essential modern JavaScript syntax.", "briefDescription": "Extract array elements into variables.", "priority": "must" }
          ]
        },
        {
          "id": "object-methods",
          "title": "Object Methods",
          "description": "Master object manipulation for data transformation and state management. Object.keys/values/entries for iteration, spread and destructuring for copying and extracting, optional chaining and nullish coalescing for safe access.",
          "briefDescription": "Object iteration, copying, and safe access patterns.",
          "priority": "must",
          "children": [
            { "id": "keys-values-entries", "title": "Object.keys(), values(), entries()", "description": "Object.keys(obj) returns array of own enumerable string keys. Object.values(obj) returns values. Object.entries(obj) returns [key, value] pairs. Use with for...of or array methods to iterate objects. Only includes own properties, not inherited. Symbols are excluded.", "briefDescription": "Convert object to arrays for iteration.", "priority": "must" },
            { "id": "object-assign", "title": "Object.assign()", "description": "Copies enumerable own properties from source objects to target. Object.assign({}, obj) for shallow cloning. Mutates the target object. Later sources overwrite earlier ones. Does not copy inherited properties. Spread syntax {...obj} is often preferred for cleaner code.", "briefDescription": "Shallow copy properties between objects.", "priority": "imp" },
            { "id": "freeze-seal", "title": "Object.freeze(), Object.seal()", "description": "freeze: no adding, removing, or modifying properties (shallow — nested objects can still change). seal: no adding or removing, but can modify existing properties. isFrozen() and isSealed() check status. Use for truly immutable constants.", "briefDescription": "Prevent object modifications.", "priority": "imp" },
            { "id": "computed-property-names", "title": "Computed Property Names", "description": "Use expressions as property names: { [expression]: value }. Common with variables: { [key]: value } or dynamic keys: { [`prefix_${id}`]: data }. Essential for dynamic object creation and Redux action types.", "briefDescription": "Dynamic property keys using expressions.", "priority": "imp" },
            { "id": "optional-chaining", "title": "Optional Chaining (?.)", "description": "Safely access nested properties: obj?.prop?.nested. Short-circuits and returns undefined if any part is null/undefined. Works with methods: obj?.method(), bracket notation: obj?.[key], and function calls: func?.(). Essential for handling potentially missing data.", "briefDescription": "Safe property access without null checks.", "priority": "must" },
            { "id": "nullish-coalescing", "title": "Nullish Coalescing (??)", "description": "Returns the right operand only when left is null or undefined (not for other falsy values like 0 or ''). a ?? b is like a !== null && a !== undefined ? a : b. Unlike ||, it preserves '' and 0. Pair with ?. for safe defaults: obj?.value ?? 'default'.", "briefDescription": "Default values for null/undefined only.", "priority": "must" },
            { "id": "object-destructuring", "title": "Destructuring", "description": "Extract properties: const { name, age } = obj. Rename: const { name: n } = obj. Default: const { x = 10 } = obj. Nested: const { a: { b } } = obj. Rest: const { x, ...rest } = obj. Essential for function parameters and React props.", "briefDescription": "Extract object properties into variables.", "priority": "must" },
            { "id": "object-spread", "title": "Spread Operator", "description": "Shallow copy: { ...obj }. Merge: { ...obj1, ...obj2 }. Override: { ...obj, key: newValue }. Later properties override earlier. Essential for immutable updates in React/Redux. Remember: it's shallow, so nested objects are still references.", "briefDescription": "Clone and merge objects with spread syntax.", "priority": "must" },
            { "id": "property-shorthand", "title": "Property Shorthand", "description": "When property name equals variable name: { name } instead of { name: name }. Also works with methods: { greet() {} } instead of { greet: function() {} }. Cleaner syntax for object literals, especially common with ES6 modules and React components.", "briefDescription": "Shorthand for matching property/variable names.", "priority": "imp" }
          ]
        },
        {
          "id": "map-set-weakmap-weakset",
          "title": "Map, Set, WeakMap, WeakSet",
          "description": "ES6 introduced proper collection types. Map allows any key type (not just strings), Set stores unique values, Weak variants allow garbage collection of keys. Know when to use each over plain objects and arrays.",
          "briefDescription": "ES6 collection types for specialized use cases.",
          "priority": "imp",
          "children": [
            { "id": "map-vs-object", "title": "Map vs Object", "description": "Map advantages: any key type (objects, primitives), maintains insertion order, has size property, no prototype pollution, better for frequent add/delete. Object advantages: JSON serialization, property access syntax, smaller for small datasets. Use Map for dictionaries, Object for records.", "briefDescription": "When to choose Map over plain objects.", "priority": "imp" },
            { "id": "set-vs-array", "title": "Set vs Array", "description": "Set stores only unique values. has() is O(1) vs array.includes() O(n). No index access. Use for deduplication: [...new Set(arr)]. Use for membership testing. Size property works directly. Maintains insertion order. Iteration is in insertion order.", "briefDescription": "Unique value collection with O(1) lookup.", "priority": "imp" },
            { "id": "weakmap-gc", "title": "WeakMap (Garbage Collection)", "description": "Keys must be objects and are held weakly — if no other references exist, the entry can be garbage collected. Not iterable, no size, no clear(). Use for private data, metadata without preventing GC, or associating data with DOM elements without memory leaks.", "briefDescription": "Object-keyed map that allows garbage collection.", "priority": "imp" },
            { "id": "weakset", "title": "WeakSet", "description": "Like WeakMap but for unique object values (not key-value pairs). Objects can be garbage collected if no other references. Not iterable, no size. Use cases: tracking visited objects, flagging objects without modifying them. Less common than WeakMap.", "briefDescription": "Object collection allowing garbage collection.", "priority": "look" }
          ]
        },
        {
          "id": "modules",
          "title": "Modules",
          "description": "Modules organize code into reusable, encapsulated units. ES Modules (ESM) are the standard. Understanding the difference between CommonJS and ESM, dynamic imports, and tree shaking is essential for modern JavaScript development and optimization.",
          "briefDescription": "ES Modules, CommonJS, and code organization.",
          "priority": "must",
          "children": [
            { "id": "commonjs", "title": "CommonJS (require/module.exports)", "description": "Node.js's original module system. require() is synchronous and dynamic — can appear anywhere. module.exports defines a module's public API. Runs code on first require(), caches the result. Not suitable for browsers without bundlers.", "briefDescription": "Node's synchronous module system.", "priority": "imp" },
            { "id": "es-modules", "title": "ES Modules (import/export)", "description": "The ECMAScript standard. import/export are static (hoisted to top). Enables tree shaking. export default for single main export, export { } for named exports. Use .mjs extension in Node or \"type\": \"module\" in package.json. Now supported natively in browsers.", "briefDescription": "The standard module system for JavaScript.", "priority": "must" },
            { "id": "default-named-exports", "title": "Default vs Named Exports", "description": "Default: one per module, import with any name. Named: multiple per module, import by exact name (or alias with 'as'). Can mix both. Prefer named exports for discoverability and tree shaking. React components often use default exports.", "briefDescription": "Exporting single vs multiple values from modules.", "priority": "must" },
            { "id": "dynamic-import", "title": "Dynamic Import()", "description": "import('module') returns a promise. Loads modules dynamically at runtime — enables code splitting and lazy loading. Supported in both ESM and CommonJS. Use for route-based splitting in React: const Component = lazy(() => import('./Component')).", "briefDescription": "Load modules on-demand at runtime.", "priority": "imp" },
            { "id": "tree-shaking", "title": "Tree Shaking", "description": "Bundlers (Webpack, Rollup) eliminate dead code from bundles. Only works with ESM static imports/exports. Named exports enable more granular tree shaking than default exports. Side effects (code that runs on import) can prevent tree shaking — mark in package.json's sideEffects field.", "briefDescription": "Remove unused exports during bundling.", "priority": "imp" },
            { "id": "circular-dependencies", "title": "Circular Dependencies", "description": "Module A imports B, B imports A. ESM handles this better than CommonJS due to live bindings. In CommonJS, you might get undefined on first access. Best practice: avoid circular dependencies by refactoring shared code into a third module.", "briefDescription": "When modules import each other.", "priority": "look" }
          ]
        },
        {
          "id": "dom-manipulation",
          "title": "DOM Manipulation",
          "description": "Understanding native DOM APIs remains relevant even with frameworks. Interviewers test event handling, delegation, performance implications of reflows, and knowledge of IntersectionObserver. These concepts underpin how frameworks like React work internally.",
          "briefDescription": "Native DOM APIs, events, and performance.",
          "priority": "imp",
          "children": [
            { "id": "selecting-elements", "title": "Selecting Elements", "description": "document.querySelector(selector) — returns first match. document.querySelectorAll(selector) — returns static NodeList. Faster legacy methods: getElementById, getElementsByClassName, getElementsByTagName. querySelector is versatile but getElementById is faster for IDs.", "briefDescription": "querySelector and legacy selection methods.", "priority": "imp" },
            { "id": "creating-removing-elements", "title": "Creating & Removing Elements", "description": "document.createElement(tag) creates an element. element.appendChild(), element.append(), element.prepend() add children. element.remove(), parent.removeChild(child) remove elements. element.replaceWith() replaces. Manipulate in a documentFragment for batch operations to minimize reflows.", "briefDescription": "Create, add, and remove DOM nodes.", "priority": "imp" },
            {
              "id": "event-handling",
              "title": "Event Handling",
              "description": "addEventListener attaches handlers. Understanding the event lifecycle (capture, target, bubble) and delegation pattern is essential for efficient event handling. Know when to use stopPropagation and preventDefault.",
              "briefDescription": "Event listeners, bubbling, and delegation.",
              "priority": "must",
              "children": [
                { "id": "addeventlistener", "title": "addEventListener", "description": "element.addEventListener(type, handler, options). Options: capture (capture phase), once (remove after one call), passive (never calls preventDefault, improves scroll performance). Returns void — use removeEventListener with same function reference to remove.", "briefDescription": "Attach event handlers with options.", "priority": "must" },
                { "id": "bubbling-capturing", "title": "Event Bubbling & Capturing", "description": "Events have three phases: capture (root to target), target (at the element), bubble (target to root). By default, handlers fire in bubble phase. Set capture: true to handle during capture. Useful for intercepting events before they reach the target.", "briefDescription": "Events travel down then up the DOM tree.", "priority": "must" },
                { "id": "event-delegation", "title": "Event Delegation", "description": "Attach one handler to a parent to handle events from many children. Use event.target to identify which child triggered it. More efficient than attaching handlers to each child. Essential for dynamic content (e.g., lists). Works because of event bubbling.", "briefDescription": "Single handler on parent for many children.", "priority": "must" },
                { "id": "stop-prevent", "title": "stopPropagation & preventDefault", "description": "stopPropagation() prevents the event from propagating further (bubbling or capture). stopImmediatePropagation() also stops other handlers on the same element. preventDefault() cancels the default browser action (e.g., link navigation, form submission). Neither affects event flow in the opposite direction.", "briefDescription": "Control event flow and default behavior.", "priority": "must" }
              ]
            },
            { "id": "dom-traversal", "title": "DOM Traversal", "description": "Navigate the DOM tree: parentNode, children, firstChild, lastChild, nextSibling, previousSibling. Element-only: parentElement, childNodes vs children, firstElementChild. closest(selector) finds ancestor matching selector. Use querySelector on elements to scope queries.", "briefDescription": "Navigate parent, child, and sibling relationships.", "priority": "imp" },
            { "id": "reflow-repaint", "title": "Reflow & Repaint", "description": "Reflow: recalculates layout (positions, sizes). Expensive — triggered by reading offsetWidth, modifying dimensions, adding/removing elements. Repaint: redraws pixels (colors, visibility). Batch DOM reads together, then writes. Use requestAnimationFrame for animations. Avoid forced synchronous layouts.", "briefDescription": "Performance costs of layout recalculation.", "priority": "imp" },
            { "id": "mutationobserver", "title": "MutationObserver", "description": "Observe DOM changes asynchronously. new MutationObserver(callback). observer.observe(element, config). Callback receives array of MutationRecords. Configure to watch: childList, attributes, characterData, subtree. Use for reacting to DOM changes made by third-party code.", "briefDescription": "Watch for DOM mutations asynchronously.", "priority": "look" },
            { "id": "intersectionobserver", "title": "IntersectionObserver", "description": "Efficiently detect when elements enter/exit the viewport (or other containers). Use for lazy loading images, infinite scroll, or triggering animations on scroll. Replaces scroll event listeners with better performance. Configure thresholds and root margins.", "briefDescription": "Efficiently detect element visibility.", "priority": "imp" }
          ]
        },
        {
          "id": "regular-expressions",
          "title": "Regular Expressions",
          "description": "Regex is powerful for pattern matching, validation, and text manipulation. Know the syntax, flags, and common patterns. Interviewers may ask to write or debug regex for emails, URLs, or extraction tasks.",
          "briefDescription": "Pattern matching syntax and common patterns.",
          "priority": "imp",
          "children": [
            { "id": "regex-syntax", "title": "Pattern Syntax", "description": "Characters: . (any), \\d (digit), \\w (word char), \\s (whitespace). Quantifiers: * (0+), + (1+), ? (0-1), {n,m}. Anchors: ^ (start), $ (end), \\b (word boundary). Character classes: [abc], [^abc] (negation). Alternation: |. Know escaping: \\. \\$ \\^ etc.", "briefDescription": "Basic regex syntax and metacharacters.", "priority": "imp" },
            { "id": "regex-flags", "title": "Flags (g, i, m, s, u, y)", "description": "g: global (find all matches). i: case-insensitive. m: multiline (^ $ match line start/end). s: dotAll (. matches newlines). u: Unicode mode. y: sticky (match at lastIndex only). Flags are added after the closing /: /pattern/gi.", "briefDescription": "Modifiers that change regex behavior.", "priority": "imp" },
            { "id": "regex-groups", "title": "Groups & Capture", "description": "(pattern) creates a capture group. (?:pattern) is non-capturing. Access captures via match result array or replace $1, $2. Named groups: (?<name>pattern), access via groups.name. Use for extracting parts of matches.", "briefDescription": "Capture and reference matched substrings.", "priority": "imp" },
            { "id": "lookahead-lookbehind", "title": "Lookahead & Lookbehind", "description": "Lookahead: (?=pattern) positive, (?!pattern) negative. Match only if followed/not followed by pattern. Lookbehind: (?<=pattern) positive, (?<!pattern) negative. Match only if preceded/not preceded. Zero-width — don't consume characters.", "briefDescription": "Match based on surrounding context.", "priority": "look" },
            { "id": "common-patterns", "title": "Common Patterns (email, URL, phone)", "description": "Email (simplified): /^[\\w.-]+@[\\w.-]+\\.[a-z]{2,}$/i. URL (basic): /https?:\\/\\/[\\w.-]+(?:\\.[a-z]{2,})(?:\\/\\S*)?/i. Phone varies by region. Real-world validation often uses libraries. Know that 'perfect' email regex is impractical — basic validation is sufficient.", "briefDescription": "Practical regex patterns for validation.", "priority": "imp" }
          ]
        },
        {
          "id": "storage-apis",
          "title": "Storage APIs",
          "description": "Browser storage options for persisting data. Know the differences between localStorage, sessionStorage, cookies, and IndexedDB — their limits, security implications, and when to use each.",
          "briefDescription": "localStorage, sessionStorage, cookies, IndexedDB.",
          "priority": "imp",
          "children": [
            { "id": "localstorage", "title": "localStorage", "description": "Key-value storage (~5MB) that persists indefinitely until cleared. stringOnly: must JSON.stringify objects. Synchronous API. Same-origin policy. No expiration. Accessible from any tab. Triggers 'storage' event on other tabs. Use for user preferences, non-sensitive data.", "briefDescription": "Persistent key-value storage (~5MB).", "priority": "must" },
            { "id": "sessionstorage", "title": "sessionStorage", "description": "Like localStorage but per-session, per-tab. Cleared when tab closes. Not shared between tabs. ~5MB. Use for temporary data that shouldn't persist (e.g., form drafts, wizard state). Same synchronous string-only API.", "briefDescription": "Per-tab storage cleared on close.", "priority": "imp" },
            {
              "id": "cookies",
              "title": "Cookies",
              "description": "Small data (~4KB) sent with every HTTP request to the same origin. Can be set by server (Set-Cookie) or client (document.cookie). Have expiration, path, domain. Security flags are critical.",
              "briefDescription": "Small data sent with every HTTP request.",
              "priority": "must",
              "children": [
                { "id": "cookie-flags", "title": "HttpOnly, Secure, SameSite", "description": "HttpOnly: inaccessible to JavaScript, mitigates XSS. Secure: only sent over HTTPS. SameSite: Strict (same-origin only), Lax (top-level navigation), None (cross-site, requires Secure). For auth tokens, use HttpOnly + Secure + SameSite=Strict.", "briefDescription": "Security flags for cookies.", "priority": "must" }
              ]
            },
            { "id": "indexeddb", "title": "IndexedDB", "description": "Low-level async API for large structured data (hundreds of MB). Key-value store with indexes. Transaction-based. Complex API — often used with wrappers like Dexie.js. Use for offline apps, large datasets, binary data (blobs). Not suitable for small, simple storage.", "briefDescription": "Large-scale, async, indexed storage.", "priority": "look" }
          ]
        },
        {
          "id": "web-workers",
          "title": "Web Workers",
          "description": "Workers run JavaScript in background threads, enabling true parallelism. Interviewers test understanding of the main thread bottleneck and when to offload work. Know the types: Dedicated, Shared, and Service Workers.",
          "briefDescription": "Background threads for parallelism.",
          "priority": "imp",
          "children": [
            { "id": "dedicated-workers", "title": "Dedicated Workers", "description": "new Worker('script.js') creates a dedicated worker owned by one script. Communicate via postMessage/onmessage. Data is copied (structured clone) unless using Transferable. No DOM access. Good for CPU-intensive tasks: parsing, crypto, image processing.", "briefDescription": "Single-owner background threads.", "priority": "imp" },
            { "id": "shared-workers", "title": "Shared Workers", "description": "new SharedWorker('script.js') can be shared across tabs/windows of the same origin. Communicate via ports. Good for shared state or reducing resource duplication. Less widely supported than dedicated workers. Connection management is more complex.", "briefDescription": "Workers shared across tabs.", "priority": "look" },
            { "id": "service-workers", "title": "Service Workers", "description": "Proxy between the web app and network. Enable offline support (caching), push notifications, and background sync. Lifecycle: install → activate → fetch. Registered via navigator.serviceWorker.register(). HTTPS required. Foundation of Progressive Web Apps.", "briefDescription": "Network proxy for offline and caching.", "priority": "imp" },
            { "id": "transferable-objects", "title": "Transferable Objects", "description": "ArrayBuffer, MessagePort, ImageBitmap, OffscreenCanvas can be transferred (zero-copy) between main thread and workers instead of copied. postMessage(data, [transferable]). The transferred object becomes unusable in the sender. Crucial for performance with large binary data.", "briefDescription": "Zero-copy transfer of large data to workers.", "priority": "look" }
          ]
        },
        {
          "id": "memory-management",
          "title": "Memory Management",
          "description": "JavaScript uses automatic garbage collection, but memory leaks still occur. Understanding how memory works helps write performant code and debug memory issues. Know common leak patterns and profiling techniques.",
          "briefDescription": "Garbage collection, leaks, and profiling.",
          "priority": "imp",
          "children": [
            {
              "id": "garbage-collection",
              "title": "Garbage Collection",
              "description": "JavaScript automatically frees memory that's no longer reachable. Understanding the algorithms helps explain why certain patterns cause leaks and how to structure code for efficient GC.",
              "briefDescription": "How JavaScript automatically frees memory.",
              "priority": "imp",
              "children": [
                { "id": "mark-and-sweep", "title": "Mark-and-Sweep", "description": "The modern GC algorithm. Starting from roots (global object, call stack), traverse and 'mark' all reachable objects. Anything not marked is unreachable and 'swept' (freed). This is why nullifying references can free memory. Runs periodically, not immediately.", "briefDescription": "Modern GC traverses from roots, sweeps unreachable.", "priority": "imp" },
                { "id": "reference-counting", "title": "Reference Counting", "description": "Legacy approach: track reference count per object, free when count hits zero. Problem: circular references never reach zero. JavaScript engines use mark-and-sweep, but reference cycles in older browsers caused leaks. Understanding this explains historical IE bugs.", "briefDescription": "Legacy algorithm with circular reference issues.", "priority": "look" }
              ]
            },
            {
              "id": "memory-leaks",
              "title": "Memory Leaks",
              "description": "When memory is retained unintentionally. Common causes: detached DOM elements, forgotten event listeners, global variables, closures holding large objects, timers not cleared. Detection requires profiling.",
              "briefDescription": "Unintentional memory retention.",
              "priority": "imp",
              "children": [
                { "id": "common-leak-causes", "title": "Common Causes", "description": "1) Event listeners on removed DOM elements. 2) Closures capturing large objects. 3) Forgotten timers (setInterval). 4) Global variables or window properties. 5) Detached DOM: storing references to elements no longer in the DOM. 6) Circular references in closures.", "briefDescription": "Frequent sources of memory leaks.", "priority": "imp" },
                { "id": "leak-detection", "title": "Detection & Profiling", "description": "Chrome DevTools → Memory tab. Heap Snapshots: compare snapshots to find growing objects. Allocation Timeline: see object creation over time. Performance Monitor: watch heap size. Look for 'detached' in snapshots for DOM leaks. Set breakpoints before/after actions.", "briefDescription": "Using DevTools to find and fix leaks.", "priority": "imp" }
              ]
            },
            { "id": "weakref-finalizationregistry", "title": "WeakRef & FinalizationRegistry", "description": "ES2021 features. WeakRef holds a weak reference to an object — doesn't prevent GC. deref() returns object or undefined if collected. FinalizationRegistry runs a callback when a registered object is collected. Use sparingly — adds complexity. Useful for caches and resource management.", "briefDescription": "Advanced APIs for observing garbage collection.", "priority": "skip" }
          ]
        }
      ]
    },
    {
      "id": "typescript",
      "title": "TypeScript",
      "description": "TypeScript adds static type checking to JavaScript. It catches type errors at compile time, improves IDE support with autocomplete and refactoring, and serves as documentation. Essential for large MERN codebases. Interviewers expect knowledge of generics, utility types, and advanced type patterns.",
      "briefDescription": "Static typing, generics, utility types, and advanced patterns.",
      "priority": "must",
      "children": [
        {
          "id": "ts-basic-types",
          "title": "Basic Types",
          "description": "TypeScript's foundational types for primitives and common structures. Understanding when to use any vs unknown, the nuances of never and void, and how enums work is essential for writing type-safe code.",
          "briefDescription": "Primitives, any, unknown, never, tuples, enums.",
          "priority": "must",
          "children": [
            { "id": "ts-primitives", "title": "Primitives (string, number, boolean)", "description": "The basic primitive types matching JavaScript: string, number (includes floats and NaN), boolean. Type annotations: let name: string = 'John'. TypeScript infers types when possible, but explicit annotations improve clarity and catch errors earlier.", "briefDescription": "Basic string, number, and boolean types.", "priority": "must" },
            { "id": "ts-any-unknown-never-void", "title": "any, unknown, never, void", "description": "any: opts out of type checking — avoid when possible. unknown: type-safe any — must check before using. void: absence of return value (functions), undefined or nothing. never: values that never occur (throwing functions, infinite loops, exhaustive checks). Know when to use each.", "briefDescription": "Special types for edge cases and safety.", "priority": "must" },
            { "id": "ts-literal-types", "title": "Literal Types", "description": "Narrow types to specific values: let direction: 'left' | 'right' | 'up' | 'down'. Combine with union for enumerations without enums. Literal inference with 'as const'. Template literal types create complex string patterns. Powerful for type-safe APIs.", "briefDescription": "Types constrained to specific values.", "priority": "imp" },
            { "id": "ts-tuple-types", "title": "Tuple Types", "description": "Fixed-length arrays with specific types at each position: let pair: [string, number] = ['age', 30]. Optional elements: [string, number?]. Rest elements: [string, ...number[]]. Useful for function return values, coordinates, and structured data.", "briefDescription": "Fixed-length arrays with positional types.", "priority": "imp" },
            {
              "id": "ts-enum",
              "title": "Enum",
              "description": "Named constants grouped together. TypeScript provides numeric, string, and const enums with different compile behaviors.",
              "briefDescription": "Named constant groups with numeric or string values.",
              "priority": "imp",
              "children": [
                { "id": "ts-numeric-enum", "title": "Numeric Enum", "description": "enum Direction { Up, Down, Left, Right }. Values auto-increment from 0 (or custom start). Can reverse-map: Direction[0] === 'Up'. Compiled to an object. Use when values don't matter, just identity.", "briefDescription": "Auto-incrementing numeric values.", "priority": "imp" },
                { "id": "ts-string-enum", "title": "String Enum", "description": "enum Status { Active = 'ACTIVE', Inactive = 'INACTIVE' }. Explicit string values, no auto-increment. More readable in logs and debugging. No reverse mapping. Preferred when values are meaningful.", "briefDescription": "Explicit string values for readability.", "priority": "imp" },
                { "id": "ts-const-enum", "title": "const Enum", "description": "const enum Direction { Up, Down }. Inlined at compile time — no runtime object. Smaller bundle size. Cannot use computed members. preserveConstEnums flag keeps runtime object for debugging. Use for purely compile-time constants.", "briefDescription": "Inlined at compile time for zero runtime cost.", "priority": "look" }
              ]
            }
          ]
        },
        {
          "id": "ts-annotations-inference",
          "title": "Type Annotations & Inference",
          "description": "TypeScript balances explicit annotations with automatic inference. Know when to rely on inference (most cases) and when to annotate explicitly (function parameters, public APIs, complex expressions).",
          "briefDescription": "Explicit types vs automatic type inference.",
          "priority": "must",
          "children": [
            { "id": "ts-variable-annotations", "title": "Variable Annotations", "description": "let count: number = 5; const name: string = 'John'. Usually unnecessary — TypeScript infers from initializers. Use when: no initializer, initializer is ambiguous (like []), or for documentation. const infers literal types by default.", "briefDescription": "Typing variables explicitly when needed.", "priority": "must" },
            { "id": "ts-function-types", "title": "Function Parameters & Return Types", "description": "Always type parameters: function greet(name: string): string. Return types are inferred but explicit annotations improve clarity and catch errors. Arrow function syntax: (x: number) => number. Use ? for optional params, = for defaults.", "briefDescription": "Type function inputs and outputs.", "priority": "must" },
            { "id": "ts-contextual-typing", "title": "Contextual Typing", "description": "TypeScript infers parameter types from context. Array methods: nums.map(n => n * 2) — n is inferred as number. Event handlers: onClick={(e) => { }} — e is inferred as React.MouseEvent. Reduces annotation burden significantly.", "briefDescription": "Type inference from surrounding context.", "priority": "imp" }
          ]
        },
        {
          "id": "ts-interfaces-types",
          "title": "Interfaces vs Types",
          "description": "Both define object shapes, but with differences. Interfaces are extendable and mergeable; type aliases are more flexible with unions and primitives. Know when to use each.",
          "briefDescription": "Interfaces for objects, types for flexibility.",
          "priority": "must",
          "children": [
            { "id": "ts-interface-declaration", "title": "Interface Declaration", "description": "interface User { name: string; age: number; greet(): void; }. Can have optional properties (?), readonly properties, and methods. Interfaces describe the shape of objects. Used for object types, class contracts, and public API boundaries.", "briefDescription": "Object shape with properties and methods.", "priority": "must" },
            { "id": "ts-type-alias", "title": "Type Alias", "description": "type User = { name: string; age: number }. Can alias any type: primitives, unions, tuples, functions. More versatile than interfaces. Cannot be re-opened (no declaration merging). Use for complex type expressions.", "briefDescription": "Alias for any type, not just objects.", "priority": "must" },
            { "id": "ts-extending-interfaces", "title": "Extending Interfaces", "description": "interface Admin extends User { permissions: string[] }. Multiple inheritance: interface C extends A, B { }. Classes can implement interfaces: class Employee implements User { }. Extension creates a subtype relationship.", "briefDescription": "Create subtypes by extending interfaces.", "priority": "imp" },
            { "id": "ts-intersection-types", "title": "Intersection Types (&)", "description": "Combine types: type Admin = User & { permissions: string[] }. The resulting type has all properties from both. Used for mixins and combining types. Unlike union, intersection requires all properties to be present.", "briefDescription": "Combine multiple types into one.", "priority": "must" },
            { "id": "ts-union-types", "title": "Union Types (|)", "description": "type Result = Success | Error. Value can be any type in the union. Access only common properties unless narrowed with type guards. Discriminated unions use a common 'tag' property for narrowing. Essential for modeling real-world variations.", "briefDescription": "One of several possible types.", "priority": "must" },
            { "id": "ts-declaration-merging", "title": "Declaration Merging", "description": "Interface declarations with the same name are merged: interface Box { x: number } interface Box { y: number } results in Box having x and y. Types don't merge — duplicate declarations error. Used to augment library types.", "briefDescription": "Multiple interface declarations combine.", "priority": "imp" },
            { "id": "ts-when-to-use", "title": "When to Use Which", "description": "Use interfaces for: object shapes, class contracts, library APIs (extensible), declaration merging. Use type aliases for: unions, intersections, primitive aliases, tuples, complex expressions, mapped types. Default to interface for objects; switch to type when needed.", "briefDescription": "Guidelines for choosing interface vs type.", "priority": "imp" }
          ]
        },
        {
          "id": "ts-generics",
          "title": "Generics",
          "description": "Generics enable reusable, type-safe code that works with multiple types. They're essential for utility functions, data structures, and API responses. Understanding generics, constraints, and conditional types is key for advanced TypeScript.",
          "briefDescription": "Type parameters for reusable, type-safe code.",
          "priority": "must",
          "children": [
            { "id": "ts-generic-functions", "title": "Generic Functions", "description": "function identity<T>(arg: T): T { return arg; }. T is a type parameter inferred from the argument. Preserves type information through the function. Can have multiple type params: function pair<T, U>(a: T, b: U): [T, U].", "briefDescription": "Functions that work with any type.", "priority": "must" },
            { "id": "ts-generic-interfaces", "title": "Generic Interfaces", "description": "interface Box<T> { value: T }. Use: const box: Box<string> = { value: 'hello' }. Common for containers, promises (Promise<T>), and API responses. Array<T> is a built-in generic interface.", "briefDescription": "Interfaces parameterized by type.", "priority": "must" },
            { "id": "ts-generic-classes", "title": "Generic Classes", "description": "class Stack<T> { private items: T[] = []; push(item: T) { this.items.push(item); } pop(): T | undefined { return this.items.pop(); } }. The type is specified when instantiating: new Stack<number>(). Static members cannot use the class's type parameter.", "briefDescription": "Classes parameterized by type.", "priority": "imp" },
            { "id": "ts-generic-constraints", "title": "Generic Constraints (extends)", "description": "function getLength<T extends { length: number }>(arg: T): number. Constrain T to types with a length property. T extends SomeType restricts what T can be. Enables accessing properties that the constraint guarantees.", "briefDescription": "Limit generics to specific shapes.", "priority": "must" },
            { "id": "ts-default-type-params", "title": "Default Type Parameters", "description": "interface Wrapper<T = string> { value: T }. If no type argument is provided, T defaults to string. Like default function params. Useful for backwards compatibility when adding type params to existing types.", "briefDescription": "Fallback types when not specified.", "priority": "look" },
            {
              "id": "ts-conditional-types",
              "title": "Conditional Types",
              "description": "T extends U ? X : Y — type-level ternary. Enables type transformations based on conditions. Combined with infer, creates powerful type manipulation. Foundation for many utility types.",
              "briefDescription": "Type-level conditionals for transformation.",
              "priority": "imp",
              "children": [
                { "id": "ts-infer-keyword", "title": "infer Keyword", "description": "Extract types inside conditionals: type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never. infer R captures the return type. Works in extends clauses only. Enables extracting nested type information.", "briefDescription": "Extract types within conditional expressions.", "priority": "imp" },
                { "id": "ts-distributive-conditionals", "title": "Distributive Conditional Types", "description": "When T is a union, T extends U ? X : Y distributes over each union member. Exclude<T, U> works this way: type Exclude<T, U> = T extends U ? never : T. Filtering unions is a common use case.", "briefDescription": "Conditionals apply to each union member.", "priority": "look" }
              ]
            }
          ]
        },
        {
          "id": "ts-utility-types",
          "title": "Utility Types",
          "description": "TypeScript provides built-in generic types for common transformations. Know Partial, Required, Pick, Omit, Record, and type extraction utilities. These reduce boilerplate and enable DRY type definitions.",
          "briefDescription": "Built-in type transformations and helpers.",
          "priority": "must",
          "children": [
            { "id": "ts-partial", "title": "Partial<T>", "description": "Makes all properties optional: Partial<User> = { name?: string; age?: number }. Useful for update functions where only some fields are provided. Common in form state and patch operations.", "briefDescription": "Make all properties optional.", "priority": "must" },
            { "id": "ts-required", "title": "Required<T>", "description": "Makes all properties required: Required<PartialUser>. Opposite of Partial. Useful when you have an optional type but need to ensure all fields are present (e.g., after validation).", "briefDescription": "Make all properties required.", "priority": "imp" },
            { "id": "ts-readonly", "title": "Readonly<T>", "description": "Makes all properties readonly: Readonly<User>. Prevents reassignment. Shallow — nested objects are still mutable. Use for immutable data structures and const assertions.", "briefDescription": "Make all properties immutable.", "priority": "imp" },
            { "id": "ts-pick", "title": "Pick<T, K>", "description": "Select specific properties: Pick<User, 'name' | 'email'>. Creates a subtype with only those properties. Useful for creating view models or DTOs that need a subset of fields.", "briefDescription": "Select a subset of properties.", "priority": "must" },
            { "id": "ts-omit", "title": "Omit<T, K>", "description": "Exclude specific properties: Omit<User, 'password'>. Opposite of Pick. Creates a type without the specified keys. Common for creating safe public types from internal types.", "briefDescription": "Exclude specific properties.", "priority": "must" },
            { "id": "ts-record", "title": "Record<K, V>", "description": "Object type with keys K and values V: Record<string, number> = { a: 1, b: 2 }. Record<'success' | 'error', string> restricts keys. Useful for dictionaries and lookup objects.", "briefDescription": "Object with specific key and value types.", "priority": "must" },
            { "id": "ts-exclude-extract-nonnullable", "title": "Exclude, Extract, NonNullable", "description": "Exclude<T, U>: remove types from union. Extract<T, U>: keep matching types. NonNullable<T>: remove null and undefined. Use for filtering union types. Exclude<'a' | 'b' | 'c', 'a'> = 'b' | 'c'.", "briefDescription": "Filter union types.", "priority": "imp" },
            { "id": "ts-returntype", "title": "ReturnType<T>", "description": "Extract the return type of a function: type Result = ReturnType<typeof fetchUser>. Works with function types. Useful when you don't control the function definition but need its return type.", "briefDescription": "Extract function return type.", "priority": "imp" },
            { "id": "ts-parameters", "title": "Parameters<T>", "description": "Extract parameter types as a tuple: Parameters<typeof fn> = [string, number]. Useful for wrapping functions or creating factory helpers. ConstructorParameters works for class constructors.", "briefDescription": "Extract function parameter types.", "priority": "look" },
            { "id": "ts-instancetype", "title": "InstanceType<T>", "description": "Extract the instance type of a constructor function: InstanceType<typeof MyClass>. Useful when working with class factories or dependency injection where you have the constructor but not the instance type.", "briefDescription": "Extract class instance type.", "priority": "look" }
          ]
        },
        {
          "id": "ts-advanced-types",
          "title": "Advanced Types",
          "description": "Sophisticated type patterns for complex scenarios. Mapped types transform types, template literal types work with strings, type guards narrow types at runtime. These patterns unlock TypeScript's full power.",
          "briefDescription": "Mapped types, type guards, and advanced patterns.",
          "priority": "imp",
          "children": [
            { "id": "ts-mapped-types", "title": "Mapped Types", "description": "Transform properties systematically: type Readonly<T> = { readonly [P in keyof T]: T[P] }. Iterate over keys with keyof. Modify with readonly, ?. Use as to rename keys. Foundation of many utility types.", "briefDescription": "Transform types by iterating over properties.", "priority": "imp" },
            { "id": "ts-template-literal-types", "title": "Template Literal Types", "description": "String types with embedded types: type EventName = `on${Capitalize<'click' | 'focus'>}`. Enables precise string pattern matching. Intrinsic string manipulation: Uppercase, Lowercase, Capitalize, Uncapitalize. Powerful for API typing.", "briefDescription": "String types with embedded expressions.", "priority": "look" },
            { "id": "ts-discriminated-unions", "title": "Discriminated Unions", "description": "Union types with a common 'tag' property for narrowing: type Result = { type: 'success'; data: Data } | { type: 'error'; error: Error }. Switch on the tag to narrow the type. Essential pattern for state machines and API responses.", "briefDescription": "Unions with a common type tag.", "priority": "must" },
            {
              "id": "ts-type-guards",
              "title": "Type Guards",
              "description": "Narrow types at runtime using checks. TypeScript understands typeof, instanceof, in operator, and custom guards. Essential for working with union types safely.",
              "briefDescription": "Runtime checks that narrow types.",
              "priority": "must",
              "children": [
                { "id": "ts-guard-typeof", "title": "typeof", "description": "if (typeof x === 'string') { /* x is string */ }. Works for primitives: 'string', 'number', 'boolean', 'symbol', 'undefined', 'object', 'function'. Note: typeof null === 'object' and typeof [] === 'object'.", "briefDescription": "Narrow using typeof checks.", "priority": "must" },
                { "id": "ts-guard-instanceof", "title": "instanceof", "description": "if (error instanceof TypeError) { /* error is TypeError */ }. Checks constructor in the prototype chain. Works with classes and constructor functions. Doesn't work across realms (iframes).", "briefDescription": "Narrow using prototype chain check.", "priority": "must" },
                { "id": "ts-guard-in", "title": "in operator", "description": "if ('email' in user) { /* user has email */ }. Check property existence. Combines with type guard behavior to narrow unions. Careful: checks prototype chain, use hasOwnProperty for own properties.", "briefDescription": "Narrow by checking property existence.", "priority": "imp" },
                { "id": "ts-guard-custom", "title": "Custom Type Guards (is)", "description": "function isUser(obj: any): obj is User { return 'name' in obj && 'age' in obj; }. Return type 'obj is User' tells TypeScript this function narrows the type. Enables complex validation with full type narrowing.", "briefDescription": "User-defined functions that narrow types.", "priority": "must" }
              ]
            },
            { "id": "ts-type-assertions", "title": "Type Assertions (as)", "description": "Override TypeScript's inferred type: const input = document.getElementById('input') as HTMLInputElement. Use when you know more than TypeScript. Dangerous if wrong — no runtime check. Prefer type guards when possible.", "briefDescription": "Override inferred types with as.", "priority": "imp" },
            { "id": "ts-index-signatures", "title": "Index Signatures", "description": "Type dynamic property names: interface Dict { [key: string]: number }. All values must match the signature type. Can combine with known properties. Use Record<K, V> for cleaner syntax in many cases.", "briefDescription": "Type objects with dynamic keys.", "priority": "imp" },
            { "id": "ts-keyof-typeof", "title": "keyof & typeof Operators", "description": "keyof T: union of all property names. typeof value: type of a value (different from runtime typeof). Combined: keyof typeof obj. Essential for type-safe property access and mapped types.", "briefDescription": "Extract keys and types at type level.", "priority": "must" }
          ]
        },
        {
          "id": "ts-decorators",
          "title": "Decorators",
          "description": "Decorators modify classes and members declaratively. Still experimental (Stage 3). Heavily used in frameworks like Angular and NestJS. Understand the patterns even if you don't use them directly.",
          "briefDescription": "Declarative class and method modification.",
          "priority": "look",
          "children": [
            { "id": "ts-class-decorators", "title": "Class Decorators", "description": "Applied to the class constructor: @decorator class MyClass {}. Receives the constructor as argument. Can modify or replace the constructor. Used for metadata, registration, and class enhancement.", "briefDescription": "Decorate entire classes.", "priority": "look" },
            { "id": "ts-method-decorators", "title": "Method Decorators", "description": "Applied to methods: @log greet() {}. Receives target, propertyKey, and descriptor. Can modify the method via the descriptor. Used for logging, validation, authorization checks.", "briefDescription": "Decorate class methods.", "priority": "look" },
            { "id": "ts-property-decorators", "title": "Property Decorators", "description": "Applied to properties: @validate name: string. Receives target and propertyKey. Cannot access the descriptor directly. Often used with Reflect.metadata for ORM mappings.", "briefDescription": "Decorate class properties.", "priority": "skip" },
            { "id": "ts-parameter-decorators", "title": "Parameter Decorators", "description": "Applied to parameters: greet(@required name: string). Receives target, propertyKey, and parameter index. Used with other decorators and metadata. Common in dependency injection frameworks.", "briefDescription": "Decorate method parameters.", "priority": "skip" },
            { "id": "ts-decorator-factories", "title": "Decorator Factories", "description": "Functions that return decorators, enabling parameterization: @IsString() name. The factory receives arguments and returns the actual decorator. Standard pattern for configurable decorators.", "briefDescription": "Parameterized decorator creators.", "priority": "look" }
          ]
        },
        {
          "id": "ts-module-system",
          "title": "Module System",
          "description": "TypeScript extends JavaScript modules with declaration files and enhanced resolution. Understanding tsconfig, @types packages, and module resolution is essential for setting up and maintaining TypeScript projects.",
          "briefDescription": "Module resolution, declaration files, tsconfig.",
          "priority": "imp",
          "children": [
            { "id": "ts-namespaces", "title": "Namespaces", "description": "Legacy feature for organizing code: namespace MyApp { export class User {} }. Pre-ES6 modules. Avoid in new code — use ES modules instead. May encounter in older codebases. Can be merged across files with reference comments.", "briefDescription": "Legacy code organization (prefer ES modules).", "priority": "look" },
            { "id": "ts-module-resolution", "title": "Module Resolution", "description": "How TypeScript finds module files. 'node' strategy mimics Node.js resolution. 'bundler' strategy for modern bundlers. Check package.json exports, tsconfig paths, and file extensions. moduleResolution option controls behavior.", "briefDescription": "How TypeScript locates imported modules.", "priority": "imp" },
            { "id": "ts-declaration-files", "title": "Declaration Files (.d.ts)", "description": "Type definitions for JavaScript libraries. Describe types without implementation. Auto-generated with declaration: true. Can write manually for untyped libraries. Live in @types packages or bundled with libraries.", "briefDescription": "Type definitions for JavaScript code.", "priority": "imp" },
            { "id": "ts-types-packages", "title": "@types Packages", "description": "DefinitelyTyped provides types for thousands of JS libraries. npm install @types/lodash. TypeScript automatically finds them. Check if a library bundles its own types before installing @types. Updates may lag behind library updates.", "briefDescription": "Community-maintained type packages.", "priority": "imp" },
            {
              "id": "ts-tsconfig",
              "title": "tsconfig.json",
              "description": "Configuration file for TypeScript projects. Controls compilation, type checking, and module resolution. Understanding key options is essential for project setup.",
              "briefDescription": "TypeScript project configuration.",
              "priority": "must",
              "children": [
                { "id": "ts-compiler-options", "title": "compilerOptions", "description": "Main configuration section. target: JavaScript version output. module: module system to use. lib: included type definitions. outDir: output directory. esModuleInterop: enables default imports. Dozens of options — know the important ones.", "briefDescription": "Core compilation settings.", "priority": "must" },
                { "id": "ts-strict-mode", "title": "strict Mode", "description": "Enables all strict type-checking options: strictNullChecks, strictFunctionTypes, strictPropertyInitialization, noImplicitAny, noImplicitThis, alwaysStrict. Always recommended for new projects. Catches more bugs at compile time.", "briefDescription": "Maximum type safety settings.", "priority": "must" },
                { "id": "ts-paths-baseurl", "title": "paths & baseUrl", "description": "Configure path aliases: baseUrl: '.', paths: { '@components/*': ['src/components/*'] }. Enables cleaner imports. Must configure bundler/runtime to match. Import aliases improve code organization and refactoring.", "briefDescription": "Import path aliases.", "priority": "imp" },
                { "id": "ts-target-module", "title": "target & module", "description": "target: ES version for output (ES2015, ES2020, ESNext). module: module format (CommonJS, ESNext, NodeNext). Match to your runtime. NodeNext for modern Node.js. ESNext with bundler for browsers.", "briefDescription": "Output JavaScript and module format.", "priority": "imp" }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "html-web-apis",
      "title": "HTML & Web APIs",
      "description": "HTML provides the structure of web pages, while Web APIs enable interaction with browsers and devices. Understanding semantic HTML, accessibility, forms, and browser APIs is fundamental for MERN developers. Interviewers test knowledge of SEO, a11y, and how modern web APIs work.",
      "briefDescription": "Semantic HTML, accessibility, forms, and browser APIs.",
      "priority": "must",
      "children": [
        {
          "id": "semantic-html",
          "title": "Semantic HTML",
          "description": "Using HTML elements according to their meaning, not just appearance. Semantic markup improves accessibility, SEO, and code readability. Screen readers and search engines rely on structure.",
          "briefDescription": "Meaningful HTML elements for structure and SEO.",
          "priority": "must",
          "children": [
            { "id": "semantic-elements", "title": "header, nav, main, section, article, aside, footer", "description": "header: introductory content. nav: navigation links. main: primary content (one per page). section: thematic grouping. article: self-contained, distributable content. aside: tangentially related content. footer: footer content. Use divs for non-semantic grouping only.", "briefDescription": "Core structural elements and their purposes.", "priority": "must" },
            { "id": "seo-importance", "title": "Importance for SEO", "description": "Search engines use semantic structure to understand content. Proper heading hierarchy (h1-h6) establishes document outline. main element identifies primary content. Structured data helps rich snippets. Semantic HTML is the foundation of technical SEO.", "briefDescription": "How semantics improve search engine visibility.", "priority": "imp" },
            { "id": "a11y-importance", "title": "Importance for Accessibility", "description": "Screen readers announce semantic elements, helping users navigate. Landmarks (nav, main, aside) provide jump points. Correct heading hierarchy aids understanding. Button vs div-as-button: native elements have built-in accessibility. Semantics are the first step in accessible development.", "briefDescription": "How semantics enable assistive technology.", "priority": "must" }
          ]
        },
        {
          "id": "forms",
          "title": "Forms",
          "description": "Forms are how users submit data. Understanding input types, validation, FormData API, and the relationship between HTML forms and React's controlled components is essential for full-stack development.",
          "briefDescription": "Input types, validation, FormData, submission handling.",
          "priority": "must",
          "children": [
            { "id": "input-types", "title": "Input Types", "description": "text, email, password, number, date, file, checkbox, radio, range, color, tel, url, search, datetime-local, time, week, month. Each has specific validation, keyboard, and picker behaviors. Use the right type for better UX and built-in validation.", "briefDescription": "Specialized input types for different data.", "priority": "must" },
            {
              "id": "form-validation",
              "title": "Form Validation",
              "description": "HTML5 provides built-in validation attributes. Custom validation with JavaScript. Understand both for progressive enhancement.",
              "briefDescription": "Built-in and custom form validation.",
              "priority": "must",
              "children": [
                { "id": "builtin-validation", "title": "Built-in Validation (required, pattern, etc.)", "description": "required: field must be filled. pattern: regex match. min/max: numeric range. minlength/maxlength: text length. type-specific validation (email, url). novalidate on form disables. Validation fires on submit and shows browser UI.", "briefDescription": "HTML5 constraint validation attributes.", "priority": "must" },
                { "id": "custom-validation", "title": "Custom Validation (setCustomValidity)", "description": "input.setCustomValidity('Custom message') adds custom validation. Empty string clears it. Check with input.checkValidity(). invalidevent fires on failed validation. Required for complex rules like password confirmation or async validation (username availability).", "briefDescription": "JavaScript-powered custom validation messages.", "priority": "imp" }
              ]
            },
            { "id": "formdata-api", "title": "FormData API", "description": "const formData = new FormData(formElement). Captures all form data including files. formData.get(), set(), append(), delete(), entries(). Can be sent directly with fetch. Automatically handles multipart encoding. Essential for file uploads and dynamic form handling.", "briefDescription": "JavaScript API for collecting form data.", "priority": "must" },
            { "id": "form-submission", "title": "Form Submission (action, method, enctype)", "description": "action: URL to submit to. method: GET (query params) or POST (body). enctype: application/x-www-form-urlencoded (default), multipart/form-data (files), text/plain. JavaScript can intercept with e.preventDefault(). Understanding native behavior helps with progressive enhancement.", "briefDescription": "HTML form submission mechanics.", "priority": "imp" },
            { "id": "controlled-uncontrolled", "title": "Controlled vs Uncontrolled (React context)", "description": "Controlled: React state is the source of truth — input value set by state, onChange updates state. Uncontrolled: DOM is the source of truth — use ref to access value. Controlled gives more control. Uncontrolled better for file inputs and integrating non-React libraries.", "briefDescription": "React form patterns: state-driven vs DOM-driven.", "priority": "must" }
          ]
        },
        {
          "id": "accessibility",
          "title": "Accessibility (a11y)",
          "description": "Making web content usable by everyone, including people with disabilities. Interviewers increasingly test a11y knowledge. React apps especially need attention to focus management and ARIA when replacing native elements.",
          "briefDescription": "ARIA, focus management, keyboard navigation, screen readers.",
          "priority": "must",
          "children": [
            { "id": "aria-roles", "title": "ARIA Roles", "description": "role attribute gives semantic meaning when HTML elements don't suffice. Roles: button, dialog, alert, navigation, tablist, tab, tabpanel, menu, menuitem. Don't override native semantics. First rule of ARIA: don't use ARIA if native HTML works.", "briefDescription": "Add semantic meaning with role attribute.", "priority": "imp" },
            { "id": "aria-attributes", "title": "ARIA Attributes", "description": "aria-label: accessible name. aria-describedby: links to description. aria-hidden: hides from assistive tech. aria-live: announces dynamic updates (polite, assertive). aria-expanded, aria-pressed, aria-selected for state. Use correctly or accessibility worsens.", "briefDescription": "Descriptive and state attributes for assistive tech.", "priority": "imp" },
            { "id": "focus-management", "title": "Focus Management", "description": "Focus should follow user actions. After modal opens, focus inside. After modal closes, focus returns. tabindex=0 adds to tab order, -1 makes focusable via JS only, positive values (avoid) reorder. React: useRef + focus(), focus trapping in modals.", "briefDescription": "Control keyboard focus for usability.", "priority": "must" },
            { "id": "keyboard-navigation", "title": "Keyboard Navigation", "description": "All interactive elements must be keyboard-accessible. Tab/Shift+Tab for navigation. Enter/Space for activation. Arrow keys for widgets (tabs, menus, sliders). Escape to close/cancel. No keyboard traps except modals (which trap intentionally with escape exit).", "briefDescription": "Full functionality without a mouse.", "priority": "must" },
            { "id": "screen-reader-support", "title": "Screen Reader Support", "description": "Screen readers announce element type, name, and state. Provide accessible names via label, aria-label, or aria-labelledby. Hide decorative content with aria-hidden or empty alt. Test with VoiceOver (Mac), NVDA (Windows), or browser extensions.", "briefDescription": "Ensuring content works with screen readers.", "priority": "imp" },
            { "id": "alt-text", "title": "Alt Text for Images", "description": "alt attribute describes image content. Decorative images: alt=\"\" (empty). Informative images: describe the content concisely. Functional images (links): describe the action. Complex images: short alt + longer description nearby. Missing alt is an accessibility violation.", "briefDescription": "Descriptive text for images.", "priority": "must" },
            { "id": "color-contrast", "title": "Color Contrast", "description": "WCAG requires minimum 4.5:1 contrast for normal text, 3:1 for large text. Tools: Chrome DevTools, Contrast Checker extensions. Don't rely on color alone for meaning — add text or icons. Consider colorblind users. Test with grayscale.", "briefDescription": "Sufficient contrast for readability.", "priority": "imp" }
          ]
        },
        {
          "id": "media-elements",
          "title": "Media Elements",
          "description": "HTML elements for images, video, and audio. Understanding responsive images, lazy loading, and modern image formats is essential for performance.",
          "briefDescription": "Images, video, audio, and responsive media.",
          "priority": "imp",
          "children": [
            { "id": "img-element", "title": "img (srcset, sizes, lazy loading)", "description": "srcset provides multiple image sources for different resolutions: srcset=\"img-320w.jpg 320w, img-640w.jpg 640w\". sizes tells browser which size to pick: sizes=\"(max-width: 600px) 100vw, 50vw\". loading=\"lazy\" defers off-screen images. Improve performance significantly.", "briefDescription": "Responsive images with srcset and lazy loading.", "priority": "must" },
            { "id": "video-audio", "title": "video & audio", "description": "<video> and <audio> with controls attribute. source element for multiple formats (WebM, MP4). autoplay requires muted. poster attribute for video thumbnail. preload: none, metadata, auto. JavaScript API: play(), pause(), currentTime, volume.", "briefDescription": "Native media playback elements.", "priority": "imp" },
            { "id": "picture-element", "title": "picture Element", "description": "<picture> contains <source> elements for art direction and format selection. Use media attribute for different crops at breakpoints. Use type for format fallbacks (WebP, AVIF with JPG fallback). More control than srcset.", "briefDescription": "Art direction and format selection for images.", "priority": "imp" },
            { "id": "responsive-images", "title": "Responsive Images", "description": "Serve appropriately sized images to avoid wasting bandwidth. srcset for resolution switching. picture for art direction. Modern formats (WebP, AVIF) for compression. CDN image optimization. Width and height attributes prevent layout shift.", "briefDescription": "Serve optimized images for device and viewport.", "priority": "imp" }
          ]
        },
        {
          "id": "meta-seo",
          "title": "Meta Tags & SEO",
          "description": "Meta tags provide information about the page to browsers and search engines. Essential for social sharing, search rankings, and proper rendering.",
          "briefDescription": "Meta tags, Open Graph, structured data.",
          "priority": "imp",
          "children": [
            { "id": "open-graph", "title": "Open Graph Tags", "description": "og:title, og:description, og:image, og:url, og:type. Control how links appear when shared on Facebook, LinkedIn, etc. Image should be at least 1200x630px. Essential for social media visibility.", "briefDescription": "Control social media link previews.", "priority": "imp" },
            { "id": "twitter-cards", "title": "Twitter Card Tags", "description": "twitter:card (summary, summary_large_image), twitter:title, twitter:description, twitter:image. Falls back to Open Graph if not specified. Test with Twitter Card Validator. Large image cards get more engagement.", "briefDescription": "Twitter-specific link previews.", "priority": "look" },
            { "id": "viewport-meta", "title": "Viewport Meta", "description": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">. Essential for responsive design. Without it, mobile browsers render at desktop width. Never use maximum-scale=1 (breaks zoom accessibility).", "briefDescription": "Enable responsive behavior on mobile.", "priority": "must" },
            { "id": "canonical-url", "title": "Canonical URL", "description": "<link rel=\"canonical\" href=\"\">. Tells search engines which URL is the authoritative version. Prevents duplicate content issues. Essential when same content appears at multiple URLs (query params, http/https, www/non-www).", "briefDescription": "Specify the authoritative page URL.", "priority": "imp" },
            { "id": "robots-txt", "title": "robots.txt", "description": "Tells crawlers which pages not to access. Located at site root. Disallow: /admin, Allow: /. Not enforced — just polite request. Don't block CSS/JS needed for rendering. Sitemap directive points to sitemap location.", "briefDescription": "Crawler access directives.", "priority": "look" },
            { "id": "sitemap", "title": "Sitemap", "description": "XML file listing all pages for search engines. Includes lastmod, changefreq, priority. Submit to Google Search Console. Essential for large sites or sites with poor internal linking. Auto-generate from routes.", "briefDescription": "XML list of pages for crawlers.", "priority": "look" },
            { "id": "structured-data", "title": "Structured Data / JSON-LD", "description": "<script type=\"application/ld+json\">. Provides machine-readable data about page content. Types: Article, Product, FAQPage, BreadcrumbList, Organization. Enables rich snippets in search results (stars, prices, FAQs). Test with Google's Rich Results Tool.", "briefDescription": "Machine-readable page data for rich snippets.", "priority": "imp" }
          ]
        },
        {
          "id": "web-apis",
          "title": "Web APIs",
          "description": "Browser-provided APIs that extend JavaScript capabilities. From making HTTP requests to accessing device sensors. Know the common APIs and when to use them.",
          "briefDescription": "Browser APIs for advanced functionality.",
          "priority": "must",
          "children": [
            {
              "id": "fetch-api",
              "title": "Fetch API",
              "description": "Modern replacement for XMLHttpRequest. Promise-based, supports streaming, works with Service Workers. The standard for HTTP requests in the browser.",
              "briefDescription": "Modern promise-based HTTP requests.",
              "priority": "must",
              "children": [
                { "id": "request-response-objects", "title": "Request/Response Objects", "description": "new Request(url, options) and Response objects. Options: method, headers, body, mode (cors, no-cors, same-origin), credentials (include, omit, same-origin). Response: ok, status, headers, json(), text(), blob(), clone(). Understand the full object model.", "briefDescription": "Request configuration and Response handling.", "priority": "must" },
                { "id": "abortcontroller", "title": "AbortController", "description": "const controller = new AbortController(); fetch(url, { signal: controller.signal }). controller.abort() cancels the request. Essential for cleanup: cancel pending requests when component unmounts. AbortError is thrown on abort.", "briefDescription": "Cancel fetch requests programmatically.", "priority": "imp" },
                { "id": "streaming-responses", "title": "Streaming Responses", "description": "response.body is a ReadableStream. Can read in chunks for large files or real-time data. response.body.getReader() returns a reader. Useful for progress indicators and processing data as it arrives.", "briefDescription": "Process response data as it streams.", "priority": "look" }
              ]
            },
            { "id": "web-storage-api", "title": "Web Storage API (localStorage, sessionStorage)", "description": "localStorage persists across sessions, sessionStorage clears on tab close. Both: getItem(), setItem(), removeItem(), clear(). Synchronous, ~5MB limit. Store strings only — JSON.stringify/parse for objects. Storage event for cross-tab sync. See JavaScript section for details.", "briefDescription": "Persistent and session-based key-value storage.", "priority": "must" },
            { "id": "history-api", "title": "History API (pushState, replaceState, popstate)", "description": "history.pushState(state, title, url) adds to history without reload. replaceState() modifies current entry. popstate event fires on back/forward. Foundation of client-side routing. window.location for actual navigation with reload.", "briefDescription": "Manipulate browser history for SPA routing.", "priority": "imp" },
            { "id": "geolocation-api", "title": "Geolocation API", "description": "navigator.geolocation.getCurrentPosition(success, error, options). Options: enableHighAccuracy, timeout, maximumAge. Returns coords.latitude, coords.longitude, accuracy. watchPosition() for continuous tracking. Requires HTTPS. User must grant permission.", "briefDescription": "Access device location with user permission.", "priority": "look" },
            { "id": "notification-api", "title": "Notification API", "description": "Notification.requestPermission() prompts user. new Notification(title, { body, icon }) shows notification. Requires permission and HTTPS. Use for important updates. Don't abuse — users will block. Service Workers enable push notifications.", "briefDescription": "Show system notifications.", "priority": "look" },
            { "id": "clipboard-api", "title": "Clipboard API", "description": "navigator.clipboard.writeText(text) for copying. navigator.clipboard.readText() for pasting (needs permission). Async, promise-based. Replaces deprecated document.execCommand('copy'). Clears after user navigates away for security.", "briefDescription": "Read and write to system clipboard.", "priority": "imp" },
            { "id": "drag-drop-api", "title": "Drag & Drop API", "description": "draggable=\"true\" makes elements draggable. Events: dragstart, drag, dragend (source), dragenter, dragover, dragleave, drop (target). dataTransfer object passes data. preventDefault() on dragover/drop required. Native API is complex — consider libraries.", "briefDescription": "Native drag and drop functionality.", "priority": "look" },
            { "id": "file-api", "title": "File API / FileReader", "description": "input type=\"file\" gives File objects. FileReader: readAsText(), readAsDataURL(), readAsArrayBuffer(). onload event has result. Use for previewing images, parsing CSVs, uploading files. Blob for arbitrary binary data.", "briefDescription": "Read file contents in the browser.", "priority": "imp" },
            { "id": "canvas-api", "title": "Canvas API (basics)", "description": "<canvas> element with 2D rendering context: ctx = canvas.getContext('2d'). Methods: fillRect(), strokeRect(), fillText(), drawImage(), beginPath(), arc(), lineTo(). For games, charts, image manipulation. For complex work, use libraries.", "briefDescription": "2D drawing and graphics.", "priority": "look" },
            { "id": "web-speech-api", "title": "Web Speech API", "description": "Two parts: SpeechRecognition (speech-to-text) and SpeechSynthesis (text-to-speech). Recognition: new SpeechRecognition(), onresult event. Synthesis: speechSynthesis.speak(utterance). Limited browser support. Use for voice interfaces.", "briefDescription": "Speech recognition and synthesis.", "priority": "skip" },
            {
              "id": "performance-api",
              "title": "Performance API",
              "description": "Measure and analyze application performance. Essential for optimization and debugging.",
              "briefDescription": "Measure and observe performance metrics.",
              "priority": "imp",
              "children": [
                { "id": "performance-now", "title": "performance.now()", "description": "High-resolution timestamp in milliseconds since page load. More precise than Date.now() (sub-millisecond). Use for measuring code execution time. Returns DOMHighResTimeStamp. Not affected by clock skew.", "briefDescription": "High-precision timing.", "priority": "imp" },
                { "id": "performance-observer", "title": "Performance Observer", "description": "new PerformanceObserver(callback).observe({ entryTypes: ['resource', 'paint', 'longtask'] }). Monitor performance entries as they occur. Better than polling performance.getEntries(). Essential for monitoring Core Web Vitals.", "briefDescription": "Observe performance entries asynchronously.", "priority": "look" },
                { "id": "navigation-timing", "title": "Navigation Timing", "description": "performance.getEntriesByType('navigation')[0]. Provides timing for page load phases: DNS, TCP, request, response, DOM processing. Calculate TTFB, DOM ready time, full load time. Essential for diagnosing load performance.", "briefDescription": "Page load timing breakdown.", "priority": "look" }
              ]
            },
            { "id": "resize-observer", "title": "Resize Observer", "description": "new ResizeObserver(callback).observe(element). Fires when element size changes. More efficient than window resize event for element-level changes. Callback receives contentRect with width/height. Use for responsive components.", "briefDescription": "Observe element size changes.", "priority": "imp" },
            { "id": "intersection-observer", "title": "Intersection Observer", "description": "new IntersectionObserver(callback, { root, rootMargin, threshold }).observe(element). Fires when element enters/exits viewport (or custom root). Use for lazy loading, infinite scroll, analytics, animations. Much more efficient than scroll listeners.", "briefDescription": "Efficiently detect element visibility.", "priority": "must" },
            { "id": "mutation-observer", "title": "Mutation Observer", "description": "new MutationObserver(callback).observe(node, { attributes, childList, characterData, subtree }). Fires when DOM changes. Callback receives MutationRecord array. Use for watching third-party DOM changes or polyfilling features.", "briefDescription": "Watch for DOM mutations.", "priority": "imp" }
          ]
        },
        {
          "id": "shadow-dom-web-components",
          "title": "Shadow DOM & Web Components",
          "description": "Native browser APIs for building encapsulated, reusable components. While React handles most use cases, understanding Web Components is valuable for library authors and framework-agnostic code.",
          "briefDescription": "Custom elements, shadow DOM, HTML templates.",
          "priority": "look",
          "children": [
            { "id": "custom-elements", "title": "Custom Elements", "description": "class MyElement extends HTMLElement { connectedCallback(), disconnectedCallback(), attributeChangedCallback() }. customElements.define('my-element', MyElement). Create new HTML tags with custom behavior. Must include hyphen in name.", "briefDescription": "Define new HTML elements with JavaScript.", "priority": "look" },
            { "id": "shadow-dom", "title": "Shadow DOM", "description": "this.attachShadow({ mode: 'open' }). Creates encapsulated DOM subtree. Styles don't leak in or out. Enables true encapsulation. Mode 'open' allows external access, 'closed' blocks it. Used by native elements like <video>.", "briefDescription": "Encapsulated DOM with style isolation.", "priority": "look" },
            { "id": "html-templates", "title": "HTML Templates", "description": "<template> element holds inert HTML. Content is not rendered until cloned and inserted. template.content returns DocumentFragment. Combine with custom elements for efficient component patterns.", "briefDescription": "Inert, reusable HTML fragments.", "priority": "look" },
            { "id": "slots", "title": "Slots", "description": "<slot> in shadow DOM is a placeholder for light DOM content. Named slots: <slot name=\"header\">. Content with slot=\"header\" fills it. Default content shows if no content provided. Enables component composition.", "briefDescription": "Content projection into shadow DOM.", "priority": "look" }
          ]
        },
        {
          "id": "iframe-embedding",
          "title": "iframe & Embedding",
          "description": "Embedding external content securely. Understanding same-origin policy and cross-origin communication is essential for integrating third-party widgets and implementing secure iframes.",
          "briefDescription": "Secure iframe embedding and cross-origin communication.",
          "priority": "imp",
          "children": [
            { "id": "same-origin-policy", "title": "Same-Origin Policy", "description": "Browser security model: scripts can only access resources from the same origin (protocol + host + port). Cross-origin: blocked from reading iframe content, making some fetch requests, accessing localStorage. CORS allows controlled cross-origin access.", "briefDescription": "Browser security for cross-origin resources.", "priority": "must" },
            { "id": "postmessage-api", "title": "postMessage API", "description": "targetWindow.postMessage(message, targetOrigin). Receiving: window.addEventListener('message', handler). Check event.origin for security. Enables safe cross-origin communication between windows/iframes. Essential for embedded widgets.", "briefDescription": "Secure cross-origin window communication.", "priority": "imp" },
            { "id": "sandbox-attribute", "title": "sandbox Attribute", "description": "<iframe sandbox=\"allow-scripts allow-forms\">. Restricts iframe capabilities. Empty sandbox blocks everything. Tokens: allow-scripts, allow-forms, allow-same-origin, allow-popups, allow-top-navigation. Defense in depth for untrusted content.", "briefDescription": "Restrict iframe capabilities for security.", "priority": "imp" }
          ]
        }
      ]
    },
    {
      "id": "css-styling",
      "title": "CSS & Styling",
      "description": "CSS controls the visual presentation of web pages. Modern CSS includes powerful layout systems (Flexbox, Grid), responsive design tools, animations, and CSS-in-JS solutions. Interviewers test specificity, layout skills, and understanding of modern CSS techniques.",
      "briefDescription": "Selectors, layout, responsive design, animations, CSS-in-JS.",
      "priority": "must",
      "children": [
        {
          "id": "css-selectors",
          "title": "Selectors",
          "description": "CSS selectors target elements for styling. Understanding selector types, specificity, and combinators is fundamental. Modern pseudo-classes like :has() and :is() enable powerful patterns.",
          "briefDescription": "Target elements with selectors and combinators.",
          "priority": "must",
          "children": [
            { "id": "type-class-id", "title": "Type, Class, ID", "description": "Type: element name (div, p). Class: .className (reusable, multiple per element). ID: #idName (unique per page, higher specificity). Prefer classes for styling. IDs for JavaScript hooks or anchors. Type selectors for resets.", "briefDescription": "Basic selector types.", "priority": "must" },
            { "id": "attribute-selectors", "title": "Attribute Selectors", "description": "[attr] has attribute. [attr=value] exact match. [attr^=value] starts with. [attr$=value] ends with. [attr*=value] contains. [attr~=value] word in list. [attr|=value] value or value-prefix. Useful for styling inputs by type.", "briefDescription": "Select by attribute presence or value.", "priority": "imp" },
            { "id": "pseudo-classes", "title": "Pseudo-classes", "description": ":hover, :focus, :active for interaction. :nth-child(), :nth-of-type() for position. :first-child, :last-child, :only-child for structure. :not() for negation. :is() for grouping. :where() like :is() but zero specificity. :has() parent selector (game-changer!).", "briefDescription": "State and structural pseudo-classes.", "priority": "must" },
            { "id": "pseudo-elements", "title": "Pseudo-elements", "description": "::before, ::after create virtual elements (require content property). ::placeholder for input placeholders. ::selection for highlighted text. ::first-letter, ::first-line for typography. Double colon distinguishes from pseudo-classes.", "briefDescription": "Style generated and partial content.", "priority": "imp" },
            { "id": "combinators", "title": "Combinators", "description": "Descendant (space): div p. Child (>): div > p. Adjacent sibling (+): h1 + p. General sibling (~): h1 ~ p. Understanding these reduces over-specific selectors. Adjacent sibling is great for spacing between elements.", "briefDescription": "Combine selectors with relationship operators.", "priority": "must" }
          ]
        },
        {
          "id": "specificity-cascade",
          "title": "Specificity & Cascade",
          "description": "Understanding how CSS determines which styles apply when rules conflict. Specificity, source order, and importance all play a role. The cascade is what gives CSS its name.",
          "briefDescription": "How CSS resolves conflicting styles.",
          "priority": "must",
          "children": [
            { "id": "specificity-calculation", "title": "Specificity Calculation", "description": "Inline styles: 1000. IDs: 100. Classes/attributes/pseudo-classes: 10. Elements/pseudo-elements: 1. Add up each category separately — no carry-over. 0-1-0-0 beats 0-0-10-0. Same specificity: last rule wins. Know how to calculate quickly.", "briefDescription": "Calculate which selector wins.", "priority": "must" },
            { "id": "important", "title": "!important", "description": "Overrides all other declarations. Creates a separate cascade layer. Use sparingly — makes debugging hard. Legitimate uses: utility classes, overriding third-party styles, accessibility overrides. Multiple !important: specificity still applies among them.", "briefDescription": "Override cascade with caution.", "priority": "imp" },
            { "id": "inheritance", "title": "Inheritance", "description": "Some properties inherit from parent (color, font-family, line-height). Others don't (margin, padding, border). inherit keyword forces inheritance. initial resets to spec default. unset: inherit if inheritable, else initial. revert undoes to user agent default.", "briefDescription": "Properties that cascade through the DOM.", "priority": "imp" },
            { "id": "cascade-layers", "title": "Cascade Layers (@layer)", "description": "@layer utilities, components, base. Later-defined layers win. Unlayered styles beat layered. Organize styles without specificity wars. @layer at document start defines order. Import with @import supports layers.", "briefDescription": "Control cascade with explicit layers.", "priority": "look" }
          ]
        },
        {
          "id": "box-model",
          "title": "Box Model",
          "description": "Every element is a box with content, padding, border, and margin. Understanding box-sizing, margin collapse, and outline vs border is essential for layout.",
          "briefDescription": "Content, padding, border, margin.",
          "priority": "must",
          "children": [
            { "id": "box-model-parts", "title": "Content, Padding, Border, Margin", "description": "Content: actual content area. Padding: space inside border (background shows). Border: line around padding. Margin: space outside border (transparent). Width/height apply to content by default. Backgrounds extend through padding.", "briefDescription": "Four areas of every CSS box.", "priority": "must" },
            { "id": "box-sizing", "title": "box-sizing (content-box vs border-box)", "description": "content-box (default): width/height = content only. border-box: width/height includes content + padding + border. border-box is intuitive — set width: 200px and the element is 200px wide. Use * { box-sizing: border-box } as a reset.", "briefDescription": "Change how width/height are calculated.", "priority": "must" },
            { "id": "margin-collapsing", "title": "Margin Collapsing", "description": "Vertical margins between siblings collapse — larger wins. Parent-child margins collapse if no border/padding between. Empty elements collapse their own margins. Only vertical, only block elements. Doesn't happen with flex/grid children.", "briefDescription": "When vertical margins combine.", "priority": "imp" },
            { "id": "outline-vs-border", "title": "Outline vs Border", "description": "Outline: doesn't take up space, drawn outside border, can be offset, can't have rounded corners (except in Chrome). Border: part of box model, affects layout. Use outline for focus indicators — doesn't shift layout.", "briefDescription": "Non-layout vs layout line styles.", "priority": "imp" }
          ]
        },
        {
          "id": "layout",
          "title": "Layout",
          "description": "CSS layout systems control how elements are sized and positioned. Flexbox for one-dimensional layouts, Grid for two-dimensional. Understanding display modes, positioning, and stacking is fundamental.",
          "briefDescription": "Display, Flexbox, Grid, positioning.",
          "priority": "must",
          "children": [
            { "id": "display-property", "title": "Display (block, inline, inline-block, etc.)", "description": "block: full width, stacks vertically. inline: flows with text, ignores width/height. inline-block: flows inline but respects dimensions. none: removes from layout. flex/grid: enables flex/grid on children. contents: removes box, keeps children.", "briefDescription": "How elements participate in layout.", "priority": "must" },
            {
              "id": "flexbox",
              "title": "Flexbox",
              "description": "One-dimensional layout for rows or columns. The go-to for component layouts, alignment, and spacing. Master both container and item properties.",
              "briefDescription": "One-dimensional flexible layouts.",
              "priority": "must",
              "children": [
                { "id": "flex-container-props", "title": "Container Properties", "description": "flex-direction: row/column (main axis). flex-wrap: wrap/nowrap. justify-content: main axis alignment (flex-start, center, space-between, space-around, space-evenly). align-items: cross axis (stretch, center, flex-start). align-content: multi-line cross axis. gap: spacing between items.", "briefDescription": "Properties on the flex container.", "priority": "must" },
                { "id": "flex-item-props", "title": "Item Properties", "description": "flex-grow: how much extra space to absorb. flex-shrink: how much to shrink. flex-basis: initial size before grow/shrink. Shorthand: flex: 1 = flex: 1 1 0. order: visual order (avoid for a11y). align-self: override container's align-items.", "briefDescription": "Properties on flex items.", "priority": "must" }
              ]
            },
            {
              "id": "css-grid",
              "title": "CSS Grid",
              "description": "Two-dimensional layout for rows AND columns. Best for page layouts, complex grids, and when you need explicit row and column control.",
              "briefDescription": "Two-dimensional grid layouts.",
              "priority": "must",
              "children": [
                { "id": "grid-template", "title": "Grid Template (rows, columns, areas)", "description": "grid-template-columns: 1fr 2fr 1fr. grid-template-rows: auto 100px. fr is fractional unit. repeat(3, 1fr). minmax(100px, 1fr). grid-template-areas for named regions. Powerful for responsive layouts.", "briefDescription": "Define grid tracks and areas.", "priority": "must" },
                { "id": "grid-placement", "title": "Grid Placement (grid-column, grid-row, span)", "description": "grid-column: 1 / 3 or grid-column: span 2. grid-row: 2 / -1 (from line 2 to last). Grid lines are numbered from 1. Negative numbers count from end. Items can overlap. Grid areas defined in template for semantic placement.", "briefDescription": "Place items in specific grid cells.", "priority": "must" },
                { "id": "auto-flow", "title": "Auto-flow & Auto-fill / Auto-fit", "description": "grid-auto-flow: row (default) or column or dense (fill gaps). auto-fill: create as many tracks as fit. auto-fit: same but collapses empty tracks. repeat(auto-fit, minmax(250px, 1fr)) is the responsive grid pattern.", "briefDescription": "Automatic grid sizing and item placement.", "priority": "imp" },
                { "id": "subgrid", "title": "Subgrid", "description": "grid-template-columns: subgrid. Child grid inherits parent's tracks. Enables alignment across nested grids. Greatly simplifies complex layouts. Now supported in modern browsers. Game-changer for card layouts.", "briefDescription": "Nested grids aligned to parent tracks.", "priority": "look" },
                { "id": "named-grid-lines", "title": "Named Grid Lines", "description": "grid-template-columns: [sidebar-start] 200px [sidebar-end content-start] 1fr [content-end]. Reference by name: grid-column: sidebar-start / content-end. Improves readability for complex layouts. Works with repeat().", "briefDescription": "Name grid lines for semantic placement.", "priority": "look" }
              ]
            },
            { "id": "positioning", "title": "Positioning (static, relative, absolute, fixed, sticky)", "description": "static: default, normal flow. relative: offset from normal position, creates stacking context. absolute: removed from flow, positioned relative to nearest positioned ancestor. fixed: relative to viewport, stays on scroll. sticky: relative until scroll threshold, then fixed.", "briefDescription": "Control element positioning mode.", "priority": "must" },
            { "id": "float-clear", "title": "Float & Clear", "description": "Legacy layout technique. float: left/right removes from flow, text wraps around. clear: both prevents wrapping. clearfix hack: ::after { clear: both }. Avoid for layout — use Flexbox/Grid. Still useful for text wrapping around images.", "briefDescription": "Legacy layout (prefer Flexbox/Grid).", "priority": "look" },
            { "id": "z-index-stacking", "title": "Z-index & Stacking Context", "description": "z-index controls stacking order (higher = on top). Only works on positioned elements (not static). Stacking contexts: formed by z-index with position, opacity < 1, transform, etc. z-indexes only compete within same context. Common source of bugs.", "briefDescription": "Layer elements with stacking contexts.", "priority": "must" },
            { "id": "multi-column", "title": "Multi-Column Layout", "description": "column-count: 3 or column-width: 200px. column-gap for spacing. column-rule for dividers. break-inside: avoid prevents breaking elements across columns. Useful for text-heavy content like articles.", "briefDescription": "Newspaper-style column layout.", "priority": "look" }
          ]
        },
        {
          "id": "responsive-design",
          "title": "Responsive Design",
          "description": "Building layouts that work across all screen sizes. Includes media queries, viewport units, container queries, and strategies for designing mobile-first or desktop-first.",
          "briefDescription": "Media queries, viewport units, adaptive layouts.",
          "priority": "must",
          "children": [
            {
              "id": "media-queries",
              "title": "Media Queries",
              "description": "Apply styles conditionally based on device characteristics. The foundation of responsive design.",
              "briefDescription": "Conditional styles based on device/preferences.",
              "priority": "must",
              "children": [
                { "id": "breakpoints", "title": "Breakpoints", "description": "@media (min-width: 768px) { }. Common breakpoints: 480px (mobile), 768px (tablet), 1024px (laptop), 1280px (desktop). Design to content, not devices. Combine with and, not, or comma (or). Modern: use range syntax (40em <= width <= 70em).", "briefDescription": "Screen size thresholds for layout changes.", "priority": "must" },
                { "id": "prefers-color-scheme", "title": "prefers-color-scheme", "description": "@media (prefers-color-scheme: dark) { }. Detects system dark/light mode. Combine with CSS variables for theme switching. Respect user preference, but offer manual toggle. Essential for modern apps.", "briefDescription": "Detect and respect dark/light mode.", "priority": "imp" },
                { "id": "prefers-reduced-motion", "title": "prefers-reduced-motion", "description": "@media (prefers-reduced-motion: reduce) { }. User has requested less animation. Disable or simplify animations for accessibility. Motion can trigger vestibular issues. Essential for inclusive design.", "briefDescription": "Respect user motion preferences.", "priority": "imp" }
              ]
            },
            { "id": "viewport-units", "title": "Viewport Units (vw, vh, vmin, vmax, dvh, svh, lvh)", "description": "vw/vh: 1% of viewport width/height. vmin/vmax: smaller/larger of vw/vh. Mobile issue: vh doesn't account for browser chrome. dvh: dynamic viewport (changes with chrome). svh: smallest. lvh: largest. Use dvh for full-height mobile layouts.", "briefDescription": "Size relative to viewport.", "priority": "must" },
            { "id": "container-queries", "title": "Container Queries", "description": "container-type: inline-size on parent. @container (min-width: 400px) { } on children. Style based on container size, not viewport. Revolutionary for component-based design. Cards can respond to their own width.", "briefDescription": "Style based on container, not viewport.", "priority": "imp" },
            { "id": "fluid-typography", "title": "Fluid Typography (clamp())", "description": "font-size: clamp(1rem, 2vw + 0.5rem, 2rem). Minimum, preferred, maximum. Smoothly scales between breakpoints. No media query jumps. Works for spacing too. calc() for the middle value includes vw for fluidity.", "briefDescription": "Smoothly scaling text without breakpoints.", "priority": "imp" },
            { "id": "mobile-first", "title": "Mobile-First vs Desktop-First", "description": "Mobile-first: base styles for mobile, add with min-width queries. Forces prioritization, smaller base CSS. Desktop-first: base for desktop, override with max-width. Legacy approach. Mobile-first generally preferred for performance and focus.", "briefDescription": "Strategy for writing responsive CSS.", "priority": "imp" }
          ]
        },
        {
          "id": "typography",
          "title": "Typography",
          "description": "CSS typography controls text appearance. Understanding font properties, web fonts, variable fonts, and text handling is essential for readable, beautiful text.",
          "briefDescription": "Fonts, sizing, spacing, text handling.",
          "priority": "imp",
          "children": [
            { "id": "font-properties", "title": "Font Properties (family, size, weight, style, variant)", "description": "font-family: stack with fallbacks. font-size: rem preferred (relative to root). font-weight: 100-900 or keywords. font-style: italic/normal. font-variant: small-caps, numeric features. line-height: unitless multiplier preferred (1.5).", "briefDescription": "Core font styling properties.", "priority": "must" },
            { "id": "font-face", "title": "@font-face", "description": "@font-face { font-family: 'Custom'; src: url('font.woff2') format('woff2'); }. Load custom fonts. woff2 is smallest format. font-display: swap shows fallback quickly. Self-hosting for performance, Google Fonts for convenience.", "briefDescription": "Load custom web fonts.", "priority": "imp" },
            { "id": "variable-fonts", "title": "Variable Fonts", "description": "Single font file with adjustable axes: weight, width, slant, optical size. font-variation-settings or CSS properties. Smaller files than multiple font files. @font-face format: 'woff2-variations'. Modern solution for typography.", "briefDescription": "Adjustable font axes in single file.", "priority": "look" },
            { "id": "line-height-spacing", "title": "Line Height & Letter Spacing", "description": "line-height: 1.5 (unitless, preferred) — relative to font-size. letter-spacing: slight tracking adjustments (em units). word-spacing for word gaps. text-indent for paragraph indentation. Typography details matter for readability.", "briefDescription": "Fine-tune text spacing.", "priority": "imp" },
            { "id": "text-overflow", "title": "Text Overflow & Ellipsis", "description": "text-overflow: ellipsis (with white-space: nowrap and overflow: hidden). For single line. Multi-line: -webkit-line-clamp (with display: -webkit-box). word-break: break-word for long words. overflow-wrap: break-word for continuous strings.", "briefDescription": "Handle text that doesn't fit.", "priority": "imp" },
            { "id": "writing-modes", "title": "Writing Modes", "description": "writing-mode: vertical-rl (vertical right-to-left). horizontal-tb is default. direction: rtl for right-to-left languages. Logical properties (inline-start instead of left) work with any writing mode. Important for internationalization.", "briefDescription": "Vertical and RTL text layout.", "priority": "look" }
          ]
        },
        {
          "id": "colors-backgrounds",
          "title": "Colors & Backgrounds",
          "description": "CSS offers many color formats and powerful background capabilities. Modern color spaces like oklch provide perceptually uniform colors. Gradients and blend modes enable rich visual effects.",
          "briefDescription": "Color formats, gradients, backgrounds.",
          "priority": "imp",
          "children": [
            { "id": "color-formats", "title": "Color Formats (hex, rgb, hsl, oklch, hwb)", "description": "#RRGGBB or #RGB (shorthand). rgb(255, 0, 0) or rgba() with alpha. hsl(0, 100%, 50%) — hue, saturation, lightness. oklch — perceptually uniform (better for color palettes). hwb — hue, whiteness, blackness. Modern syntax: rgb(255 0 0 / 50%).", "briefDescription": "Different ways to specify colors.", "priority": "imp" },
            { "id": "gradients", "title": "Gradients (linear, radial, conic)", "description": "linear-gradient(to right, red, blue). radial-gradient(circle, red, blue). conic-gradient(from 0deg, red, blue). Color stops with percentages. repeating-* for patterns. Multiple backgrounds for layering. Great for decorative effects.", "briefDescription": "Color transitions for backgrounds.", "priority": "imp" },
            { "id": "background-properties", "title": "Background Properties", "description": "background-size: cover (fill) or contain (fit). background-position: center or percentage. background-repeat: no-repeat. background-attachment: fixed (parallax). background-clip: text (text as clipping mask). Multiple backgrounds: layer with commas.", "briefDescription": "Control background image behavior.", "priority": "imp" },
            { "id": "backdrop-filter", "title": "Backdrop Filter", "description": "backdrop-filter: blur(10px) on element blurs what's behind it. Creates frosted glass effect. Requires semi-transparent background. Other filters: brightness, contrast, grayscale. Performance consideration on mobile.", "briefDescription": "Apply filters to content behind element.", "priority": "look" },
            { "id": "mix-blend-mode", "title": "mix-blend-mode", "description": "mix-blend-mode: multiply, screen, overlay, darken, lighten, etc. Blends element with background. isolation: isolate limits blending scope. Creates unique visual effects. Similar to Photoshop blend modes.", "briefDescription": "Blend element with its background.", "priority": "look" }
          ]
        },
        {
          "id": "transitions-animations",
          "title": "Transitions & Animations",
          "description": "CSS can animate property changes smoothly. Transitions for simple state changes, @keyframes for complex multi-step animations. Understanding transform and will-change is essential for performance.",
          "briefDescription": "Transitions, keyframes, transforms, performance.",
          "priority": "must",
          "children": [
            { "id": "transition-properties", "title": "Transition Properties", "description": "transition-property: what to animate. transition-duration: how long. transition-timing-function: easing (ease, linear, ease-in-out, cubic-bezier). transition-delay: when to start. Shorthand: transition: all 0.3s ease. Trigger on state change.", "briefDescription": "Animate property changes.", "priority": "must" },
            { "id": "keyframes", "title": "@keyframes", "description": "@keyframes slide { from { } to { } } or { 0% { } 50% { } 100% { } }. Define animation steps. Apply with animation-name. Unlike transitions, keyframes run without state change triggers.", "briefDescription": "Define multi-step animation sequences.", "priority": "imp" },
            { "id": "animation-properties", "title": "Animation Properties", "description": "animation-duration, animation-timing-function, animation-delay. animation-iteration-count: number or infinite. animation-direction: alternate for back-and-forth. animation-fill-mode: forwards keeps end state. animation-play-state: paused/running.", "briefDescription": "Control keyframe animation behavior.", "priority": "imp" },
            { "id": "transform", "title": "Transform (translate, rotate, scale, skew)", "description": "transform: translateX(10px) rotate(45deg) scale(1.5). Multiple transforms apply in order. Origin: transform-origin. Transforms don't affect layout flow (unlike margin/position). translate, rotate, scale now also individual properties.", "briefDescription": "Move, rotate, scale, skew elements.", "priority": "must" },
            { "id": "will-change", "title": "Will-change", "description": "will-change: transform hints browser to optimize. Creates new layer, uses GPU. Use sparingly — has memory cost. Remove after animation. Alternative: translate3d(0,0,0) forces layer. For animation performance.", "briefDescription": "Optimization hint for animations.", "priority": "imp" },
            { "id": "scroll-animations", "title": "Scroll-driven Animations", "description": "animation-timeline: scroll() or view(). Native scroll-linked animations without JavaScript. animation-range for partial scroll. Very new — limited support. Progressive enhancement approach. Major performance improvement.", "briefDescription": "Native scroll-linked animations.", "priority": "look" }
          ]
        },
        {
          "id": "css-variables",
          "title": "CSS Variables (Custom Properties)",
          "description": "CSS custom properties enable reusable values and dynamic theming. They cascade and can be changed with JavaScript, making them powerful for design systems.",
          "briefDescription": "Reusable, dynamic CSS values.",
          "priority": "must",
          "children": [
            { "id": "css-var-declaration", "title": "Declaration & Usage (--var, var())", "description": ":root { --primary: #007bff; }. Usage: color: var(--primary). Names: --kebab-case. Define at any scope — they cascade. Access in JavaScript: getComputedStyle(element).getPropertyValue('--primary'). Set: element.style.setProperty('--primary', 'blue').", "briefDescription": "Define and use custom properties.", "priority": "must" },
            { "id": "css-var-scope", "title": "Scope & Fallback", "description": "Variables cascade like other properties. Define in :root for global, in selectors for scoped. Fallback: var(--undefined, #000). Nested fallbacks: var(--a, var(--b, #000)). Invalid value: property uses initial value.", "briefDescription": "Variable scoping and fallback values.", "priority": "imp" },
            { "id": "dynamic-theming", "title": "Dynamic Theming", "description": "Define theme colors as variables. Switch theme by changing variable values on :root or body. prefers-color-scheme for auto dark mode. JavaScript toggle for manual switch. One source of truth for colors.", "briefDescription": "Theme switching with CSS variables.", "priority": "imp" }
          ]
        },
        {
          "id": "css-in-js",
          "title": "CSS-in-JS",
          "description": "Various approaches to integrating CSS with JavaScript frameworks. Each has tradeoffs in developer experience, performance, and features. Know the major options.",
          "briefDescription": "Styled Components, CSS Modules, Tailwind.",
          "priority": "must",
          "children": [
            { "id": "styled-components", "title": "Styled Components", "description": "const Button = styled.button`color: red;`. CSS in template literals. Props for dynamic styles: ${props => props.primary && 'blue'}. Automatic scoping, SSR support, theming. Runtime cost. Popular in React ecosystem.", "briefDescription": "Tagged template literal styling.", "priority": "imp" },
            { "id": "emotion", "title": "Emotion", "description": "Similar to styled-components. css prop for inline styles: css={{ color: 'red' }}. styled API also available. Smaller bundle option with @emotion/react. Powers many UI libraries.", "briefDescription": "Flexible CSS-in-JS library.", "priority": "look" },
            { "id": "css-modules", "title": "CSS Modules", "description": "import styles from './Button.module.css'. Class names automatically hashed for scoping. className={styles.button}. No runtime cost. Works with any CSS preprocessor. Built into Next.js, Create React App.", "briefDescription": "Locally scoped CSS via class hashing.", "priority": "imp" },
            {
              "id": "tailwind",
              "title": "Tailwind CSS",
              "description": "Utility-first CSS framework. Write styles as utility classes directly in markup. Highly configurable. Rapidly gained popularity.",
              "briefDescription": "Utility-first CSS framework.",
              "priority": "must",
              "children": [
                { "id": "tailwind-utilities", "title": "Utility Classes", "description": "class=\"text-lg font-bold p-4 bg-blue-500\". Each class does one thing. Combine for complex designs. Consistent spacing/color scales. No naming decisions. Larger HTML, but tree-shaking removes unused CSS.", "briefDescription": "Single-purpose styling classes.", "priority": "must" },
                { "id": "tailwind-config", "title": "Custom Configuration", "description": "tailwind.config.js: extend colors, fonts, spacing, screens. Add custom utilities. Define design system tokens. Plugins for additional utilities. content array specifies files to scan.", "briefDescription": "Customize theme and add features.", "priority": "imp" },
                { "id": "tailwind-apply", "title": "@apply Directive", "description": "@apply bg-blue-500 text-white in CSS files. Extract repeated utility patterns into classes. Use sparingly — defeats utility-first purpose. Better for truly repeated patterns.", "briefDescription": "Use utilities in CSS files.", "priority": "look" },
                { "id": "tailwind-jit", "title": "JIT Mode", "description": "Just-in-Time compilation — now default. Generates CSS on-demand. Enables arbitrary values: w-[123px]. Faster builds. Enables all variants without bloat. No pre-built CSS file needed.", "briefDescription": "On-demand CSS generation.", "priority": "look" },
                { "id": "tailwind-responsive", "title": "Responsive Utilities", "description": "md:flex lg:hidden — prefix with breakpoint name. Mobile-first: unprefixed = small screens. sm, md, lg, xl, 2xl. Combine with other modifiers: hover:md:bg-blue-500. Very efficient for responsive design.", "briefDescription": "Breakpoint-prefixed utility classes.", "priority": "must" },
                { "id": "tailwind-dark", "title": "Dark Mode", "description": "darkMode: 'class' (toggle with .dark class) or 'media' (follows system). dark:bg-gray-900 dark:text-white. Easily implement dark mode throughout the app.", "briefDescription": "Built-in dark mode support.", "priority": "imp" }
              ]
            },
            {
              "id": "sass-scss",
              "title": "Sass/SCSS",
              "description": "CSS preprocessor adding variables (before CSS had them), nesting, mixins, and more. SCSS syntax is superset of CSS. Still relevant but declining with CSS improvements.",
              "briefDescription": "CSS preprocessor with enhanced features.",
              "priority": "imp",
              "children": [
                { "id": "sass-basics", "title": "Variables, Nesting, Mixins", "description": "$variable: value. Nesting: parent { child { } } (use sparingly). @mixin name($param) { } with @include. DRY CSS patterns. Nesting can create overly specific selectors — limit depth.", "briefDescription": "Core Sass features.", "priority": "imp" },
                { "id": "sass-extends", "title": "Extends & Placeholders", "description": "@extend .class shares styles. %placeholder { } defines non-outputted extendable styles. Reduces duplication in output. Use carefully — can create unexpected selectors.", "briefDescription": "Share styles between selectors.", "priority": "look" },
                { "id": "sass-functions", "title": "Functions & Loops", "description": "@function name($arg) { @return value }. @for, @each, @while for loops. Built-in functions: darken(), lighten(), color.scale(). Generate utility classes programmatically.", "briefDescription": "Programmatic CSS generation.", "priority": "look" },
                { "id": "sass-partials", "title": "Partials & Import", "description": "_partial.scss files not compiled directly. @use 'partial' (modern) or @import 'partial' (deprecated). Organize into components. @use has namespacing for conflicts.", "briefDescription": "Modular Sass organization.", "priority": "imp" }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "react-js",
      "title": "React.js",
      "description": "React is the most popular JavaScript library for building user interfaces. Developed by Facebook, React uses a component-based architecture with unidirectional data flow. Understanding React deeply — from JSX and hooks to performance optimization and server components — is essential for any MERN developer. This topic covers everything from basics to advanced patterns.",
      "briefDescription": "Complete React.js mastery from fundamentals to advanced patterns.",
      "priority": "must",
      "children": [
        {
          "id": "react-jsx",
          "title": "JSX",
          "description": "JSX is a syntax extension that allows writing HTML-like code in JavaScript. It's not HTML — it compiles to React.createElement() calls. Understanding JSX syntax rules, expression embedding, and how React handles rendering is foundational to writing React applications.",
          "briefDescription": "JavaScript XML syntax for describing UI structure.",
          "priority": "must",
          "children": [
            { "id": "jsx-syntax", "title": "JSX Syntax Rules", "description": "JSX must return a single parent element. Use className instead of class, htmlFor instead of for. Self-close empty tags: <img />. camelCase for attributes: onClick, tabIndex. Comments: {/* comment */}. Must close all tags. Can't use reserved words as attributes.", "briefDescription": "Core syntax rules that differ from HTML.", "priority": "must" },
            { "id": "jsx-expressions", "title": "Expressions in JSX", "description": "Embed JavaScript expressions using curly braces: {variable}, {2 + 2}, {fn()}. Can't use statements (if/for) directly — only expressions. Can embed arrays which render each element. Objects can't be rendered directly (except for style attribute).", "briefDescription": "Embedding dynamic values and expressions.", "priority": "must" },
            {
              "id": "jsx-conditionals",
              "title": "Conditional Rendering",
              "description": "React doesn't have template directives like Vue. Use JavaScript patterns for conditionals: ternary operators, logical && for short-circuit rendering, or extract logic to variables with if/else before the return statement.",
              "briefDescription": "Patterns for rendering content conditionally.",
              "priority": "must",
              "children": [
                { "id": "jsx-ternary", "title": "Ternary Operator", "description": "{condition ? <ComponentA /> : <ComponentB />}. Most common pattern for either/or rendering. Can nest but becomes unreadable — extract to variables instead. Returns one of two expressions.", "briefDescription": "Inline if-else using ? : syntax.", "priority": "must" },
                { "id": "jsx-logical-and", "title": "Logical && Operator", "description": "{condition && <Component />}. Renders component only if condition is truthy. GOTCHA: 0 && <Component /> renders '0' (not null). Use Boolean(condition) or condition > 0 with numbers.", "briefDescription": "Short-circuit rendering for single branch.", "priority": "must" },
                { "id": "jsx-if-else", "title": "if/else with Variables", "description": "let content; if (condition) { content = <A />; } else { content = <B />; } return <div>{content}</div>. More readable for complex logic. Can also use early returns in component body.", "briefDescription": "Extract conditional logic before return.", "priority": "imp" }
              ]
            },
            {
              "id": "jsx-lists-keys",
              "title": "Lists & Keys",
              "description": "Rendering lists uses array.map() to transform data into JSX elements. Each element needs a unique 'key' prop for React's reconciliation algorithm to efficiently update the DOM when the list changes.",
              "briefDescription": "Rendering arrays of elements with proper keys.",
              "priority": "must",
              "children": [
                { "id": "key-importance", "title": "Key Prop Importance", "description": "Keys help React identify which items changed, added, or removed. Must be unique among siblings (not globally). Stable keys prevent unnecessary re-renders and preserve component state. React uses keys for efficient list diffing.", "briefDescription": "Why keys are crucial for list rendering.", "priority": "must" },
                { "id": "index-as-key", "title": "Index as Key Anti-pattern", "description": "Using array index as key (key={index}) causes bugs when list order changes or items are added/removed. State gets associated with wrong items. Only safe for static lists that never reorder. Use unique IDs from data instead.", "briefDescription": "When using index breaks and why.", "priority": "must" }
              ]
            },
            { "id": "jsx-fragment", "title": "Fragment (<> </>)", "description": "Fragments let you group elements without adding extra DOM nodes. <React.Fragment> or shorthand <> </>. Fragment with key: <Fragment key={id}>. Avoids wrapper div bloat. Necessary when returning multiple elements.", "briefDescription": "Group elements without extra DOM nodes.", "priority": "must" },
            { "id": "jsx-dangerously", "title": "dangerouslySetInnerHTML", "description": "Renders raw HTML strings: <div dangerouslySetInnerHTML={{__html: htmlString}} />. Named 'dangerously' as a reminder of XSS risks. Always sanitize with DOMPurify or similar before using. Needed for CMS content, markdown rendering, etc.", "briefDescription": "Render raw HTML (with caution).", "priority": "imp" }
          ]
        },
        {
          "id": "react-components",
          "title": "Components",
          "description": "Components are the building blocks of React applications. They encapsulate UI, logic, and state. Understanding component types, composition patterns, props, and lifecycle is essential for building maintainable React applications.",
          "briefDescription": "Building blocks of React UI.",
          "priority": "must",
          "children": [
            { "id": "functional-components", "title": "Functional Components", "description": "Functions that accept props and return JSX. The modern standard since hooks (React 16.8). Simpler syntax, easier to test, compose, and reason about. Can use all React features via hooks. Default export or named export patterns.", "briefDescription": "Function-based component definition.", "priority": "must" },
            { "id": "class-components", "title": "Class Components (Legacy)", "description": "ES6 classes extending React.Component. Have this.props, this.state, lifecycle methods. Still in many codebases but being phased out. Need to bind methods or use arrow functions. Verbose but sometimes easier for lifecycle visualization.", "briefDescription": "Class-based components (legacy pattern).", "priority": "look" },
            { "id": "component-composition", "title": "Component Composition", "description": "Build complex UIs by combining smaller components. Prefer composition over inheritance. Use children prop for flexible content insertion. Specialization: wrap generic components with specific props. Containment: pass components as props.", "briefDescription": "Building complex UIs from simple parts.", "priority": "must" },
            {
              "id": "react-props",
              "title": "Props",
              "description": "Props (properties) are the mechanism for passing data from parent to child components. They are read-only and flow one direction (parent to child). Understanding props patterns is fundamental to React's data flow model.",
              "briefDescription": "Passing data between components.",
              "priority": "must",
              "children": [
                { "id": "passing-props", "title": "Passing Props", "description": "<Component name='John' age={30} isActive />. Strings use quotes, other values use curly braces. Boolean true can be shorthand. Spread props: <Component {...obj} />. Props are immutable within the component.", "briefDescription": "Syntax for providing props to components.", "priority": "must" },
                { "id": "default-props", "title": "Default Props", "description": "function Component({ name = 'Guest' }) { }. ES6 default parameters in destructuring. Legacy: Component.defaultProps = { name: 'Guest' }. TypeScript: can define defaults with Partial<Props>.", "briefDescription": "Providing fallback values for props.", "priority": "imp" },
                { "id": "children-prop", "title": "Children Prop", "description": "Special prop for content between opening and closing tags: <Wrapper>{content}</Wrapper>. Access via props.children. Can be any value: string, element, array, function. React.Children utilities for manipulation.", "briefDescription": "Content passed between component tags.", "priority": "must" },
                { "id": "render-props", "title": "Render Props Pattern", "description": "Pass a function as a prop that returns JSX: <Mouse render={mouse => <Cat position={mouse} />} />. Share behavior between components. Predates hooks. Still useful but often replaced by custom hooks.", "briefDescription": "Function props for sharing component logic.", "priority": "imp" },
                { "id": "prop-drilling", "title": "Prop Drilling Problem", "description": "Passing props through many levels of components that don't use them. Makes code verbose and maintenance harder. Solutions: Context API, state management libraries, component composition, custom hooks.", "briefDescription": "Pain of passing props through many layers.", "priority": "must" }
              ]
            },
            { "id": "pure-components", "title": "Pure Components", "description": "Components that render the same output for the same props/state. Class: extends PureComponent (shallow comparison on props/state). Functional: wrap with React.memo(). Avoid re-renders when inputs unchanged. Be careful with object/array props.", "briefDescription": "Components with predictable output.", "priority": "imp" },
            { "id": "hoc-pattern", "title": "Higher-Order Components (HOC)", "description": "Functions that take a component and return a new enhanced component: const Enhanced = withFeature(BaseComponent). Share logic across components. Common in older codebases. Being replaced by hooks. Examples: withRouter, connect(), withStyles.", "briefDescription": "Functions that enhance components.", "priority": "imp" },
            {
              "id": "class-lifecycle",
              "title": "Component Lifecycle (Class)",
              "description": "Class components have lifecycle methods that run at specific phases: mounting (insertion into DOM), updating (re-renders), and unmounting (removal). Understanding these helps when maintaining legacy code and understanding what hooks replace.",
              "briefDescription": "Lifecycle methods in class components.",
              "priority": "look",
              "children": [
                { "id": "lifecycle-mounting", "title": "Mounting", "description": "constructor(): Initialize state, bind methods. static getDerivedStateFromProps(): Rarely needed, sync state to props. render(): Return JSX. componentDidMount(): After first render — fetch data, subscriptions, DOM manipulation.", "briefDescription": "Component creation and insertion.", "priority": "look" },
                { "id": "lifecycle-updating", "title": "Updating", "description": "static getDerivedStateFromProps(). shouldComponentUpdate(nextProps, nextState): Return false to prevent re-render. render(). getSnapshotBeforeUpdate(): Capture DOM info before update. componentDidUpdate(): After re-render — compare prev/current props.", "briefDescription": "Component re-rendering phase.", "priority": "look" },
                { "id": "lifecycle-unmounting", "title": "Unmounting", "description": "componentWillUnmount(): Cleanup before removal — cancel timers, subscriptions, abort requests. Equivalent to useEffect cleanup function. Memory leak prevention is critical here.", "briefDescription": "Component removal cleanup.", "priority": "look" },
                { "id": "error-boundary-lifecycle", "title": "Error Boundaries", "description": "static getDerivedStateFromError(error): Update state to show fallback UI. componentDidCatch(error, errorInfo): Log error to service. Only class components can be error boundaries (no hook equivalent yet). Catch errors in child tree.", "briefDescription": "Catching and handling render errors.", "priority": "imp" }
              ]
            }
          ]
        },
        {
          "id": "react-hooks",
          "title": "Hooks",
          "description": "Hooks let you use state and other React features in functional components. Introduced in React 16.8, they've become the standard for writing React. Master the built-in hooks, understand their rules, and learn to create custom hooks to share logic.",
          "briefDescription": "Functions for state and effects in components.",
          "priority": "must",
          "children": [
            {
              "id": "usestate-hook",
              "title": "useState",
              "description": "The most fundamental hook. Returns a stateful value and a setter function. When state updates, the component re-renders. Understanding initialization, updates, and batching is essential for every React developer.",
              "briefDescription": "Add state to functional components.",
              "priority": "must",
              "children": [
                { "id": "usestate-lazy-init", "title": "Lazy Initialization", "description": "useState(expensiveFn) calls fn on every render but only uses result initially. useState(() => expensiveFn()) only runs once. Use for expensive computations like reading localStorage or parsing.", "briefDescription": "Defer expensive initial state computation.", "priority": "imp" },
                { "id": "usestate-functional", "title": "Functional Updates", "description": "setCount(prev => prev + 1) instead of setCount(count + 1). Ensures correct value when multiple updates happen before re-render. Essential inside closures, intervals, event handlers that may have stale state.", "briefDescription": "Update based on previous state value.", "priority": "must" },
                { "id": "usestate-batching", "title": "State Batching", "description": "React 18: All state updates are batched automatically. Multiple setState calls in same event handler = single re-render. Pre-18: Only batched in React event handlers. flushSync() to opt-out of batching when needed.", "briefDescription": "Multiple updates combined into one render.", "priority": "imp" }
              ]
            },
            {
              "id": "useeffect-hook",
              "title": "useEffect",
              "description": "Side effect hook for data fetching, subscriptions, DOM manipulation, and anything that interacts with the outside world. Runs after render. Understanding dependencies and cleanup prevents bugs and memory leaks.",
              "briefDescription": "Handle side effects in components.",
              "priority": "must",
              "children": [
                { "id": "useeffect-deps", "title": "Dependencies Array", "description": "Empty []: Run once on mount. [a, b]: Run when a or b change. Omitted: Run after every render (usually wrong). Linter helps find missing deps. Object deps need memoization or they'll trigger on every render.", "briefDescription": "Control when effect runs.", "priority": "must" },
                { "id": "useeffect-cleanup", "title": "Cleanup Function", "description": "Return a function from useEffect to cleanup: return () => { subscription.unsubscribe(); }. Runs before effect re-runs and on unmount. Essential for preventing memory leaks, dangling subscriptions, race conditions.", "briefDescription": "Clean up when effect re-runs or unmounts.", "priority": "must" },
                { "id": "useeffect-stale-closures", "title": "Stale Closures", "description": "Effect callback closes over state/props. If deps are wrong, callback uses old values. Common in setInterval: use functional setState. Or use useRef for mutable 'current' value that doesn't trigger re-render.", "briefDescription": "When closures capture old values.", "priority": "must" },
                { "id": "useeffect-infinite-loop", "title": "Infinite Loop Pitfalls", "description": "setState in effect without deps = infinite loop. Object/array in deps without memo = infinite loop (referential inequality). Fix: add deps, memoize values, or restructure effect logic.", "briefDescription": "Common causes and prevention.", "priority": "must" },
                { "id": "useeffect-data-fetching", "title": "Data Fetching Pattern", "description": "useEffect with async IIFE: useEffect(() => { (async () => { const data = await fetch(); setData(data); })(); }, []). Handle loading/error states. Abort controller for cleanup. Consider React Query/SWR instead.", "briefDescription": "Fetching data with useEffect.", "priority": "must" }
              ]
            },
            {
              "id": "usecontext-hook",
              "title": "useContext",
              "description": "Access context values without wrapper components. Combined with createContext for the Provider pattern. Solves prop drilling but has performance implications — every context consumer re-renders when context changes.",
              "briefDescription": "Consume context in functional components.",
              "priority": "must",
              "children": [
                { "id": "context-creating", "title": "Creating Context", "description": "const ThemeContext = createContext(defaultValue). Default only used when no Provider above. Export context for consumers. Can create multiple contexts for different concerns.", "briefDescription": "Initialize context with createContext.", "priority": "must" },
                { "id": "context-provider", "title": "Provider Pattern", "description": "<ThemeContext.Provider value={theme}>. Wrap component tree. value can be any type. Common pattern: value={{ state, dispatch }} or value={{ user, login, logout }}. Update value causes all consumers to re-render.", "briefDescription": "Provide context value to descendants.", "priority": "must" },
                { "id": "context-consuming", "title": "Consuming Context", "description": "const theme = useContext(ThemeContext). Simple syntax vs Consumer wrapper. Returns current context value from nearest Provider. Throws if no Provider and no default.", "briefDescription": "Access context value with hook.", "priority": "must" },
                { "id": "context-performance", "title": "Performance Issues", "description": "All consumers re-render when Provider value changes. Split contexts for different update frequencies. Memoize value object. Consider state management for frequently updated global state. Context is not optimized for high-frequency updates.", "briefDescription": "Understanding and mitigating re-renders.", "priority": "imp" }
              ]
            },
            {
              "id": "usereducer-hook",
              "title": "useReducer",
              "description": "Alternative to useState for complex state logic. Takes a reducer function and initial state, returns state and dispatch. Inspired by Redux pattern. Better for state with multiple sub-values or complex update logic.",
              "briefDescription": "Manage complex state with reducer pattern.",
              "priority": "must",
              "children": [
                { "id": "reducer-pattern", "title": "Reducer Pattern", "description": "function reducer(state, action) { switch(action.type) { case 'INCREMENT': return { count: state.count + 1 }; default: return state; } }. Pure function. Returns new state. Never mutate state directly.", "briefDescription": "Pure function that computes new state.", "priority": "must" },
                { "id": "reducer-dispatch", "title": "Action Dispatching", "description": "dispatch({ type: 'INCREMENT', payload: 5 }). Actions are objects describing what happened. type is conventional but not required. payload carries data. dispatch is stable (same reference across renders).", "briefDescription": "Send actions to update state.", "priority": "must" },
                { "id": "reducer-complex-state", "title": "Complex State Logic", "description": "When state transitions depend on previous state. When next state depends on multiple state values. Form state with validation. Shopping cart with multiple operations. Undo/redo functionality.", "briefDescription": "When to choose useReducer.", "priority": "imp" },
                { "id": "reducer-vs-state", "title": "useReducer vs useState", "description": "useState: simple, independent values. useReducer: related values, complex transitions. Dispatch is stable (good for context), setState is not. useReducer centralizes update logic for easier testing.", "briefDescription": "Choosing between the two hooks.", "priority": "imp" }
              ]
            },
            {
              "id": "usecallback-hook",
              "title": "useCallback",
              "description": "Memoize callback functions to prevent unnecessary re-renders of child components that depend on referential equality. Returns the same function reference if dependencies haven't changed.",
              "briefDescription": "Memoize functions between renders.",
              "priority": "must",
              "children": [
                { "id": "callback-memoizing", "title": "Memoizing Callbacks", "description": "const handleClick = useCallback(() => { doSomething(a, b); }, [a, b]). Returns same fn ref if deps unchanged. Prevents child re-renders when passing as prop to memoized child. Also useful for useEffect deps.", "briefDescription": "Return stable function reference.", "priority": "must" },
                { "id": "callback-when-to-use", "title": "When to Use", "description": "Passing callbacks to optimized child components (React.memo). Callbacks in useEffect dependencies. NOT needed if child isn't memoized. Overuse adds complexity without benefit. Profile before optimizing.", "briefDescription": "Understand appropriate use cases.", "priority": "must" },
                { "id": "callback-deps", "title": "Dependency Array", "description": "Like useEffect deps. Include all values from scope used in callback. Linter enforces this. If deps change, you get a new function. Empty deps [] only if callback uses nothing from scope.", "briefDescription": "Declare dependencies correctly.", "priority": "imp" }
              ]
            },
            {
              "id": "usememo-hook",
              "title": "useMemo",
              "description": "Memoize computed values to avoid expensive recalculations on every render. Returns a memoized value that only recomputes when dependencies change. Similar to useCallback but for values instead of functions.",
              "briefDescription": "Cache expensive computations.",
              "priority": "must",
              "children": [
                { "id": "memo-expensive", "title": "Memoizing Expensive Computations", "description": "const sortedList = useMemo(() => items.sort((a, b) => a - b), [items]). Only re-sorts when items changes. Avoids O(n log n) sort on every render. Measure first — profile to confirm computation is actually expensive.", "briefDescription": "Cache costly calculations.", "priority": "must" },
                { "id": "memo-when-to-use", "title": "When to Use vs Avoid", "description": "Use: expensive calculations, referential equality for deps, avoiding child re-renders with object props. Avoid: simple calculations (memoization has overhead), premature optimization. Not a guarantee — React can forget values.", "briefDescription": "Guidelines for appropriate use.", "priority": "imp" },
                { "id": "memo-referential", "title": "Referential Equality", "description": "const config = useMemo(() => ({ theme, size }), [theme, size]). Without memo, new object on every render. Causes useEffect to re-run, memoized children to re-render. useMemo maintains reference.", "briefDescription": "Maintain stable object references.", "priority": "must" }
              ]
            },
            {
              "id": "useref-hook",
              "title": "useRef",
              "description": "Create a mutable ref object that persists across renders without causing re-renders when mutated. Used for DOM access, storing mutable values, and maintaining values across renders.",
              "briefDescription": "Mutable refs that don't trigger renders.",
              "priority": "must",
              "children": [
                { "id": "ref-dom", "title": "DOM References", "description": "const inputRef = useRef(null); <input ref={inputRef} />. Access DOM node: inputRef.current.focus(). Common uses: focus management, measurements, third-party library integration, scroll position.", "briefDescription": "Access DOM elements directly.", "priority": "must" },
                { "id": "ref-mutable", "title": "Mutable Values", "description": "const prevValue = useRef(value). Store value without re-render: prevValue.current = newValue. Interval IDs, previous prop values, any value that needs to persist but shouldn't trigger render.", "briefDescription": "Store values across renders.", "priority": "must" },
                { "id": "ref-previous", "title": "Previous Value Pattern", "description": "useEffect(() => { prevRef.current = value; }). After render, save current value. Next render, prevRef.current has previous value. Useful for comparing prev/current props or animation logic.", "briefDescription": "Track previous render values.", "priority": "imp" },
                { "id": "ref-forwarding", "title": "Forwarding Refs (forwardRef)", "description": "forwardRef((props, ref) => <input ref={ref} {...props} />). Allows passing ref through component to child DOM element. Required for component libraries. Works with useImperativeHandle to customize exposed ref.", "briefDescription": "Pass refs through components.", "priority": "imp" }
              ]
            },
            { "id": "uselayouteffect-hook", "title": "useLayoutEffect", "description": "Identical to useEffect but fires synchronously after DOM mutations, before browser paints. Use for DOM measurements or mutations that should be synchronous. Blocks visual updates. Prefer useEffect unless you see flicker.", "briefDescription": "Synchronous effect before paint.", "priority": "imp" },
            { "id": "useid-hook", "title": "useId", "description": "Generate unique IDs stable across server/client. const id = useId(); <label htmlFor={id}>. Solves hydration mismatch issues. Don't use for keys in lists. Returns string like ':r1:', ':r2:'. React 18+.", "briefDescription": "Generate hydration-safe unique IDs.", "priority": "imp" },
            {
              "id": "usetransition-hook",
              "title": "useTransition",
              "description": "Mark state updates as non-urgent transitions. React can interrupt them to keep UI responsive. Part of React 18 concurrent features. Useful for expensive updates that shouldn't block user input.",
              "briefDescription": "Mark updates as interruptible transitions.",
              "priority": "imp",
              "children": [
                { "id": "transition-concurrent", "title": "Concurrent Features", "description": "React 18 enables concurrent rendering. UI can remain responsive during heavy updates. Low-priority updates can be interrupted by high-priority ones (user input). Opt-in via useTransition, useDeferredValue.", "briefDescription": "React 18's concurrent rendering.", "priority": "imp" },
                { "id": "transition-start", "title": "startTransition", "description": "const [isPending, startTransition] = useTransition(); startTransition(() => { setSearchResults(expensiveFilter()); }). Updates inside startTransition are interruptible. User input stays responsive.", "briefDescription": "Wrap updates in transitions.", "priority": "imp" },
                { "id": "transition-pending", "title": "isPending", "description": "Boolean indicating transition is pending. Show loading indicator: {isPending && <Spinner />}. Don't block input while isPending. Debounce not needed — React handles interruptibility.", "briefDescription": "Track transition in-progress state.", "priority": "imp" }
              ]
            },
            { "id": "usedeferredvalue-hook", "title": "useDeferredValue", "description": "const deferredQuery = useDeferredValue(query). Returns a deferred version of value. Old value shown during urgent updates, new value when ready. Simpler than useTransition when you don't control the state update.", "briefDescription": "Defer non-urgent value updates.", "priority": "look" },
            { "id": "usesyncexternalstore-hook", "title": "useSyncExternalStore", "description": "Safe way to subscribe to external stores (non-React state). Required for concurrent-safe third-party state. useSyncExternalStore(subscribe, getSnapshot). Libraries like Redux, Zustand use this internally.", "briefDescription": "Subscribe to external state sources.", "priority": "look" },
            { "id": "useimperativehandle-hook", "title": "useImperativeHandle", "description": "useImperativeHandle(ref, () => ({ focus: () => inputRef.current.focus() })). Customize the ref value exposed to parent. Use with forwardRef. Expose only what's needed, not entire DOM node.", "briefDescription": "Customize exposed ref methods.", "priority": "look" },
            {
              "id": "custom-hooks",
              "title": "Custom Hooks",
              "description": "Create your own hooks to extract and reuse stateful logic. Custom hooks are functions that use other hooks. They follow the 'use' prefix convention and share state logic without sharing state itself.",
              "briefDescription": "Build reusable stateful logic.",
              "priority": "must",
              "children": [
                { "id": "custom-hook-creation", "title": "Creating Custom Hooks", "description": "function useFetch(url) { const [data, setData] = useState(null); useEffect(() => { fetch(url).then(r => r.json()).then(setData); }, [url]); return data; }. Always start with 'use'. Can use any hooks inside. Each call gets its own state.", "briefDescription": "Encapsulate logic in functions.", "priority": "must" },
                { "id": "rules-of-hooks", "title": "Rules of Hooks", "description": "Only call at top level — no conditionals, loops, or nested functions. Only call from React functions (components or custom hooks). Linter (eslint-plugin-react-hooks) enforces these. Rules ensure consistent hook call order.", "briefDescription": "Mandatory rules for hook usage.", "priority": "must" },
                { "id": "common-custom-hooks", "title": "Common Custom Hooks", "description": "useDebounce(value, delay), useLocalStorage(key, initial), useFetch(url), useOnClickOutside(ref, handler), useMediaQuery(query), useIntersectionObserver(ref, options). Build or use community hooks. usehooks.com, ahooks.", "briefDescription": "Popular reusable hook patterns.", "priority": "imp" }
              ]
            }
          ]
        },
        {
          "id": "react-state-patterns",
          "title": "State Management Patterns",
          "description": "React offers flexibility in how you manage state. Understanding when to lift state, when to colocate it, and when to reach for context or external libraries is crucial for maintainable applications.",
          "briefDescription": "Patterns for organizing component state.",
          "priority": "must",
          "children": [
            { "id": "lifting-state", "title": "Lifting State Up", "description": "Move state to the nearest common ancestor when siblings need to share it. Parent holds state, passes down as props, receives updates via callbacks. Single source of truth. Main React pattern for shared state.", "briefDescription": "Share state via common ancestor.", "priority": "must" },
            { "id": "colocating-state", "title": "Co-locating State", "description": "Keep state as close to where it's used as possible. If only one component needs state, keep it there. Avoid premature lifting. Makes components more modular and reusable. Move state up only when needed.", "briefDescription": "Keep state close to usage.", "priority": "must" },
            { "id": "context-reducer", "title": "Context + useReducer", "description": "Combine Context for distribution and useReducer for complex updates. const [state, dispatch] = useReducer(reducer, init); <Context.Provider value={{state, dispatch}}>. Poor man's Redux. Good for medium complexity.", "briefDescription": "Combine patterns for global state.", "priority": "imp" },
            { "id": "state-machines", "title": "State Machines (XState)", "description": "Model state as finite state machine with explicit transitions. Prevents impossible states. XState library for React integration. Visual editor available. Excellent for complex UI state (forms, wizards, async flows).", "briefDescription": "Formal state modeling with libraries.", "priority": "look" }
          ]
        },
        {
          "id": "react-rendering",
          "title": "Rendering",
          "description": "Understanding React's rendering model — virtual DOM, reconciliation, and fiber architecture — helps write performant applications. Learn what triggers renders, how to prevent unnecessary ones, and leverage concurrent features.",
          "briefDescription": "How React updates the DOM.",
          "priority": "must",
          "children": [
            {
              "id": "virtual-dom",
              "title": "Virtual DOM",
              "description": "React maintains a lightweight JavaScript representation of the actual DOM. When state changes, React creates a new virtual DOM, compares it with the previous one (diffing), and efficiently updates only the changed parts of the real DOM.",
              "briefDescription": "In-memory DOM representation.",
              "priority": "must",
              "children": [
                { "id": "diffing-algo", "title": "Diffing Algorithm", "description": "Compares two trees. Same type elements: update attributes, recurse on children. Different types: tear down old, build new. Lists use keys for efficient reordering. O(n) complexity via heuristics.", "briefDescription": "How React compares virtual DOMs.", "priority": "must" },
                { "id": "reconciliation", "title": "Reconciliation", "description": "Process of syncing virtual DOM with actual DOM. After diffing identifies changes, reconciler determines minimal operations. Batches DOM updates for efficiency. Fiber architecture made this interruptible.", "briefDescription": "Syncing virtual and real DOM.", "priority": "imp" },
                { "id": "fiber-architecture", "title": "Fiber Architecture", "description": "React 16+ internal rewrite. Each component is a 'fiber' (unit of work). Work can be paused, aborted, restarted. Enables concurrent features, time slicing, prioritization. Not an API — internal implementation.", "briefDescription": "React's internal work scheduler.", "priority": "look" }
              ]
            },
            { "id": "react-memo", "title": "React.memo", "description": "Higher-order component for memoizing functional components. React.memo(Component) or React.memo(Component, areEqual). Skips re-render if props unchanged (shallow comparison). Custom comparison function for deep/specific checks.", "briefDescription": "Memoize components to prevent re-renders.", "priority": "must" },
            { "id": "rerender-triggers", "title": "Re-render Triggers", "description": "Component re-renders when: 1) Its state changes 2) Its parent re-renders 3) Context value changes 4) forceUpdate called (class). Props changing doesn't trigger — parent re-rendering does. Use React DevTools Profiler to identify.", "briefDescription": "What causes components to re-render.", "priority": "must" },
            { "id": "batched-updates", "title": "Batched Updates", "description": "Multiple state updates in same event = single re-render. React 18: automatic batching everywhere (timeouts, promises, native events). Pre-18: only in React events. ReactDOM.flushSync() for immediate render.", "briefDescription": "Combining state updates into one render.", "priority": "imp" },
            {
              "id": "concurrent-rendering",
              "title": "Concurrent Rendering",
              "description": "React 18's concurrent mode allows React to interrupt rendering to handle more urgent updates. Improves perceived performance for heavy applications. Opt-in via concurrent features.",
              "briefDescription": "Interruptible rendering for responsiveness.",
              "priority": "imp",
              "children": [
                { "id": "time-slicing", "title": "Time Slicing", "description": "Break rendering work into small chunks. Yield to browser between chunks for user input, animations. Prevents jank from long render times. Automatic with concurrent features. Heavy work no longer blocks UI.", "briefDescription": "Split rendering into yielding chunks.", "priority": "imp" },
                { "id": "suspense", "title": "Suspense", "description": "<Suspense fallback={<Loading />}><Component /></Suspense>. Shows fallback while children are loading. Works with React.lazy() for code splitting. In React 18: also for data fetching with compatible libraries.", "briefDescription": "Declarative loading states.", "priority": "must" },
                { "id": "streaming-ssr", "title": "Streaming SSR", "description": "React 18 server rendering streams HTML progressively. User sees content before entire page renders. Combined with Suspense boundaries for progressive hydration. renderToPipeableStream, renderToReadableStream APIs.", "briefDescription": "Progressive server-side rendering.", "priority": "imp" }
              ]
            },
            {
              "id": "react-server-components",
              "title": "React Server Components (RSC)",
              "description": "New paradigm where components run on the server and send rendered output to client. Reduces JavaScript bundle size. Can access databases, file system directly. Foundation for Next.js App Router.",
              "briefDescription": "Server-rendered components without client JS.",
              "priority": "must",
              "children": [
                { "id": "server-vs-client", "title": "Server vs Client Components", "description": "Server components: no useState, no useEffect, no browser APIs. Run once on server. Client components: interactive, have state, run in browser. Can import server into client, not vice versa (special patterns).", "briefDescription": "Understanding component types.", "priority": "must" },
                { "id": "use-directives", "title": "'use client' / 'use server' Directives", "description": "'use client' at file top marks client boundary. 'use server' marks server actions (functions callable from client). Default is server in RSC frameworks. Directive creates serialization boundary.", "briefDescription": "Mark component/function boundaries.", "priority": "must" },
                { "id": "rsc-data-fetching", "title": "Data Fetching in RSC", "description": "Server components can be async: async function Component() { const data = await db.query(); return <div>{data}</div>; }. No useEffect needed. No loading states — Suspense handles it. Colocate data with component.", "briefDescription": "Fetch data directly in server components.", "priority": "must" }
              ]
            }
          ]
        },
        {
          "id": "react-routing",
          "title": "Routing",
          "description": "Single-page applications need client-side routing. React Router is the standard. Learn navigation, route parameters, nested routes, and data loading patterns.",
          "briefDescription": "Client-side navigation in React apps.",
          "priority": "must",
          "children": [
            {
              "id": "react-router-v6",
              "title": "React Router v6",
              "description": "The standard library for React routing. v6 introduced simplified APIs, relative routes, and built-in data loading. Learn the core components and hooks for building navigable applications.",
              "briefDescription": "Standard React routing library.",
              "priority": "must",
              "children": [
                { "id": "browser-router", "title": "BrowserRouter", "description": "<BrowserRouter><App /></BrowserRouter>. Uses HTML5 history API. Wrap entire app. Also: HashRouter (#/path URLs), MemoryRouter (testing). Provides routing context to all descendants.", "briefDescription": "Top-level router component.", "priority": "must" },
                { "id": "routes-route", "title": "Routes & Route", "description": "<Routes><Route path='/' element={<Home />} /><Route path='/about' element={<About />} /></Routes>. Routes is container, Route defines path-to-element mapping. First match wins. No exact prop needed in v6.", "briefDescription": "Define route mappings.", "priority": "must" },
                { "id": "link-navlink", "title": "Link & NavLink", "description": "<Link to='/about'>About</Link>. Client-side navigation without page reload. NavLink adds active class/style: <NavLink className={({isActive}) => isActive ? 'active' : ''}>. Never use <a> for internal links.", "briefDescription": "Navigation components.", "priority": "must" },
                { "id": "usenavigate", "title": "useNavigate", "description": "const navigate = useNavigate(); navigate('/path'); navigate(-1); navigate('/path', { replace: true, state: { from: location } }). Programmatic navigation. Replace for redirects. State for passing data.", "briefDescription": "Programmatic navigation hook.", "priority": "must" },
                { "id": "useparams", "title": "useParams", "description": "Route: path='/users/:id'. const { id } = useParams(); Returns object of dynamic segments. Type is always string — parse numbers. Multiple params: /posts/:postId/comments/:commentId.", "briefDescription": "Access URL parameters.", "priority": "must" },
                { "id": "usesearchparams", "title": "useSearchParams", "description": "const [searchParams, setSearchParams] = useSearchParams(); searchParams.get('query'). Manage URL query string. setSearchParams({ query: 'react' }) updates URL. Similar to useState for query params.", "briefDescription": "Read and write query strings.", "priority": "imp" },
                { "id": "uselocation", "title": "useLocation", "description": "const location = useLocation(); location.pathname, location.search, location.state. Access current location object. State for data passed via navigate. React to URL changes.", "briefDescription": "Access current location info.", "priority": "imp" },
                { "id": "nested-routes", "title": "Nested Routes", "description": "<Route path='dashboard' element={<Dashboard />}><Route path='settings' element={<Settings />} /></Route>. Parent layout wraps child. Use <Outlet /> in parent to render child. Relative paths from parent.", "briefDescription": "Routes within routes.", "priority": "must" },
                { "id": "outlet", "title": "Outlet", "description": "Placeholder in parent route for child routes: <div><Nav /><Outlet /></div>. Renders matched child route. Context: <Outlet context={{ value }} />, child: useOutletContext().", "briefDescription": "Render child route components.", "priority": "must" },
                { "id": "dynamic-routes", "title": "Dynamic Routes", "description": "path='/users/:id'. :id is dynamic segment. Access via useParams. Can have multiple: /categories/:catId/products/:prodId. Optional params: :id? (v6.1+). Catch-all: path='*' for 404.", "briefDescription": "URL parameters in route paths.", "priority": "must" },
                { "id": "protected-routes", "title": "Protected Routes", "description": "Wrap routes requiring auth: <Route element={<RequireAuth />}><Route path='dashboard' /></Route>. RequireAuth checks auth, renders <Outlet /> or <Navigate to='/login' />. Role-based: check user.role.", "briefDescription": "Restrict access to authenticated users.", "priority": "must" },
                { "id": "lazy-loading-routes", "title": "Lazy Loading Routes", "description": "const Dashboard = lazy(() => import('./Dashboard')). <Suspense fallback={<Loading />}><Routes><Route path='/dashboard' element={<Dashboard />} /></Routes></Suspense>. Code-split by route. Reduces initial bundle.", "briefDescription": "Load route components on demand.", "priority": "must" },
                { "id": "loaders-actions", "title": "Loaders & Actions (Data APIs)", "description": "createBrowserRouter with loader: async ({ params }) => fetch('/api/user/' + params.id). Data loads before render. action for mutations. useLoaderData(), useActionData() in components. Parallel loading.", "briefDescription": "Route-level data loading and mutations.", "priority": "imp" }
              ]
            }
          ]
        },
        {
          "id": "react-forms",
          "title": "Forms in React",
          "description": "Form handling in React requires understanding controlled vs uncontrolled components. For complex forms, libraries like React Hook Form simplify validation, performance, and developer experience.",
          "briefDescription": "Handle user input and form submission.",
          "priority": "must",
          "children": [
            { "id": "controlled-components", "title": "Controlled Components", "description": "Input value controlled by React state: value={state} onChange={e => setState(e.target.value)}. React is single source of truth. Can validate on every change. Required for conditional disabling, formatting, etc.", "briefDescription": "React state controls input value.", "priority": "must" },
            { "id": "uncontrolled-components", "title": "Uncontrolled Components", "description": "Input manages own state: <input ref={inputRef} defaultValue='initial' />. Access value with inputRef.current.value. Less code for simple forms. Can't validate on change. Better performance for large forms.", "briefDescription": "DOM manages input state.", "priority": "imp" },
            {
              "id": "react-hook-form",
              "title": "React Hook Form",
              "description": "The most popular React form library. Uses uncontrolled components under the hood for performance. Minimal re-renders. Easy validation with schema libraries. Excellent TypeScript support.",
              "briefDescription": "Performant form library for React.",
              "priority": "must",
              "children": [
                { "id": "rhf-useform", "title": "useForm", "description": "const { register, handleSubmit, formState } = useForm({ defaultValues }). Central hook. Options: mode ('onBlur', 'onChange', 'onSubmit'), resolver for schema validation. Returns form methods.", "briefDescription": "Main hook for form handling.", "priority": "must" },
                { "id": "rhf-register", "title": "register", "description": "<input {...register('email', { required: 'Email required', pattern: /.../ })} />. Registers input to form. Validation rules as second argument. Returns name, ref, onChange, onBlur.", "briefDescription": "Register inputs with validation.", "priority": "must" },
                { "id": "rhf-handlesubmit", "title": "handleSubmit", "description": "<form onSubmit={handleSubmit(onValid, onInvalid)}>. Validates before calling onValid. Prevents default. Type-safe data in callback. onInvalid called if validation fails.", "briefDescription": "Handle form submission.", "priority": "must" },
                { "id": "rhf-validation", "title": "Validation (Yup, Zod)", "description": "resolver: yupResolver(schema) or zodResolver(schema). Define schema separately. Type inference with zod. errors: formState.errors.fieldName?.message. Mode controls when validation runs.", "briefDescription": "Schema-based validation integration.", "priority": "must" },
                { "id": "rhf-field-arrays", "title": "Field Arrays", "description": "const { fields, append, remove } = useFieldArray({ control, name: 'items' }). Dynamic add/remove fields. fields.map((field, index) => <input {...register(`items.${index}.name`)} key={field.id} />).", "briefDescription": "Handle dynamic form fields.", "priority": "imp" },
                { "id": "rhf-watch-setvalue", "title": "Watch & setValue", "description": "watch('fieldName') subscribes to field changes. watch() for all fields. setValue('field', value) programmatically sets values. trigger('field') manually triggers validation.", "briefDescription": "Observe and update form values.", "priority": "imp" }
              ]
            },
            { "id": "formik", "title": "Formik (comparison)", "description": "Alternative form library. <Formik> wrapper with render props or <Form>, <Field> components. More declarative. Heavier than RHF. Lower performance (controlled). Still widely used. Yup integration built-in. RHF is now more popular.", "briefDescription": "Alternative form library to RHF.", "priority": "look" }
          ]
        },
        {
          "id": "react-styling",
          "title": "Styling in React",
          "description": "React is unopinionated about styling. Choose from inline styles, CSS modules, CSS-in-JS, or utility frameworks like Tailwind. Each has tradeoffs in developer experience, performance, and maintainability.",
          "briefDescription": "Approaches to styling React components.",
          "priority": "imp",
          "children": [
            { "id": "react-inline-styles", "title": "Inline Styles", "description": "style={{ color: 'red', fontSize: '16px' }}. camelCase properties. No pseudo-selectors, media queries. Good for dynamic styles. Performance OK. Limited but sometimes useful. Avoids CSS conflicts.", "briefDescription": "JavaScript object styles.", "priority": "imp" },
            { "id": "react-css-modules", "title": "CSS Modules", "description": "import styles from './Button.module.css'. className={styles.button}. Locally scoped class names. No conflicts. Works with existing CSS knowledge. Generated unique class names. Great middle ground.", "briefDescription": "Scoped CSS files per component.", "priority": "must" },
            { "id": "react-styled-components", "title": "Styled Components", "description": "const Button = styled.button`color: red; &:hover { color: blue; }`. CSS-in-JS. Dynamic styles via props. Full CSS support. Theming built-in. Creates actual components. Some runtime cost.", "briefDescription": "CSS-in-JS library with template literals.", "priority": "imp" },
            { "id": "react-tailwind", "title": "Tailwind CSS with React", "description": "className='bg-blue-500 text-white p-4'. Utility classes. Works great with React. Some use @apply for component styles. clsx/classnames for conditional classes. Very popular in React ecosystem.", "briefDescription": "Utility-first CSS framework.", "priority": "must" },
            { "id": "classname-vs-style", "title": "className vs style prop", "description": "className for static and precompiled CSS. style for truly dynamic values (calculated at runtime). className has browser caching. style inline has specificity implications. Mix approaches as needed.", "briefDescription": "When to use each approach.", "priority": "imp" }
          ]
        },
        {
          "id": "react-data-fetching",
          "title": "Data Fetching",
          "description": "Fetching data in React has evolved from useEffect patterns to specialized libraries. Understanding the options — React Query, SWR, and upcoming Suspense patterns — is essential for modern React development.",
          "briefDescription": "Strategies for fetching and caching data.",
          "priority": "must",
          "children": [
            { "id": "useeffect-fetch", "title": "useEffect + fetch", "description": "Basic pattern: useEffect(() => { fetch(url).then(r => r.json()).then(setData); }, []). Must handle loading, error states manually. Race conditions, cleanup needed. OK for simple cases. Libraries are better.", "briefDescription": "Native browser fetch in effects.", "priority": "must" },
            { "id": "axios-react", "title": "Axios", "description": "Promise-based HTTP client. axios.get(url).then(). Auto JSON parsing. Request/response interceptors. Instance configuration. Cancel tokens. Better error handling than fetch. Still need state management.", "briefDescription": "Popular HTTP client library.", "priority": "imp" },
            {
              "id": "react-query",
              "title": "React Query / TanStack Query",
              "description": "The most popular data-fetching library for React. Handles caching, refetching, retry, pagination, and mutations with minimal code. Dramatically simplifies data fetching logic.",
              "briefDescription": "Powerful async state management.",
              "priority": "must",
              "children": [
                { "id": "rq-usequery", "title": "useQuery", "description": "const { data, isLoading, error } = useQuery({ queryKey: ['todos'], queryFn: fetchTodos }). queryKey for cache identification. Automatic caching, deduplication, background refetching. Options: staleTime, gcTime, enabled.", "briefDescription": "Fetch and cache data.", "priority": "must" },
                { "id": "rq-usemutation", "title": "useMutation", "description": "const { mutate, isLoading } = useMutation({ mutationFn: createTodo, onSuccess: () => queryClient.invalidateQueries(['todos']) }). For POST/PUT/DELETE. Callbacks: onSuccess, onError, onSettled. mutate(data).", "briefDescription": "Handle data mutations.", "priority": "must" },
                { "id": "rq-invalidation", "title": "Query Invalidation", "description": "queryClient.invalidateQueries({ queryKey: ['todos'] }). Marks query as stale, triggers refetch. After mutation to sync UI. Can invalidate by prefix: ['todos'] invalidates ['todos', id] too.", "briefDescription": "Trigger refetch after mutations.", "priority": "must" },
                { "id": "rq-caching", "title": "Caching Strategies", "description": "staleTime: how long data is fresh (no refetch). gcTime: how long unused data stays in cache. refetchOnWindowFocus: refetch when tab focused. refetchInterval: polling. staleness vs garbage collection.", "briefDescription": "Configure cache behavior.", "priority": "imp" },
                { "id": "rq-optimistic", "title": "Optimistic Updates", "description": "onMutate: async (newTodo) => { queryClient.cancelQueries(['todos']); const previous = queryClient.getQueryData(['todos']); queryClient.setQueryData(['todos'], old => [...old, newTodo]); return { previous }; }. Rollback onError.", "briefDescription": "Update UI before server confirms.", "priority": "imp" },
                { "id": "rq-infinite", "title": "Infinite Queries", "description": "useInfiniteQuery({ queryKey: ['projects'], queryFn: fetchPage, getNextPageParam: (lastPage, pages) => lastPage.nextCursor }). fetchNextPage(). data.pages is array. Good for infinite scroll.", "briefDescription": "Paginated data loading.", "priority": "imp" },
                { "id": "rq-prefetching", "title": "Prefetching", "description": "queryClient.prefetchQuery({ queryKey: ['todos', id], queryFn: () => fetchTodo(id) }). Prefetch on hover for instant navigation. Data in cache when component mounts. useQuery uses cached data.", "briefDescription": "Load data before it's needed.", "priority": "imp" }
              ]
            },
            { "id": "swr-react", "title": "SWR", "description": "Vercel's data fetching library. stale-while-revalidate pattern. const { data, error } = useSWR('/api/user', fetcher). Simpler than React Query. Built-in cache, deduplication, revalidation. Good Next.js integration.", "briefDescription": "Lightweight data fetching library.", "priority": "imp" },
            { "id": "suspense-data", "title": "Suspense for Data Fetching", "description": "Experimental/evolving. Libraries like React Query, Relay can integrate with Suspense. Component suspends while loading, Suspense shows fallback. Cleaner loading states. use() hook in React 19+.", "briefDescription": "Declarative loading with Suspense.", "priority": "look" }
          ]
        },
        {
          "id": "react-error-handling",
          "title": "Error Handling",
          "description": "Gracefully handling errors improves user experience and helps debugging. Learn error boundaries for render errors and proper patterns for async error handling.",
          "briefDescription": "Handle errors gracefully in React apps.",
          "priority": "imp",
          "children": [
            { "id": "error-boundaries", "title": "Error Boundaries", "description": "Class components with componentDidCatch and getDerivedStateFromError. Catch render errors in child tree. Show fallback UI: if (this.state.hasError) return <ErrorFallback />. Don't catch event handler errors.", "briefDescription": "Catch and display render errors.", "priority": "must" },
            { "id": "fallback-ui", "title": "Fallback UI", "description": "Show user-friendly error message instead of white screen. Include retry button. Log to error service (Sentry, LogRocket). Different fallbacks for different sections. Keep app partially functional.", "briefDescription": "User-friendly error displays.", "priority": "imp" },
            { "id": "try-catch-events", "title": "try/catch in Event Handlers", "description": "Error boundaries don't catch event handler errors. Use try/catch: onClick = async () => { try { await api() } catch (e) { setError(e) } }. Show inline errors or notifications.", "briefDescription": "Handle async errors in handlers.", "priority": "imp" },
            { "id": "rq-error-handling", "title": "React Query Error Handling", "description": "const { error, isError } = useQuery(...). {isError && <Error message={error.message} />}. onError callback. Global default: QueryClient({ queryCache: new QueryCache({ onError }) }). retry option for transient failures.", "briefDescription": "Handle errors with React Query.", "priority": "imp" }
          ]
        },
        {
          "id": "react-portals",
          "title": "Portals",
          "description": "Render children into a DOM node outside the parent component's hierarchy. Essential for modals, tooltips, and overlays that need to break out of parent CSS constraints.",
          "briefDescription": "Render outside parent DOM hierarchy.",
          "priority": "imp",
          "children": [
            { "id": "create-portal", "title": "createPortal", "description": "import { createPortal } from 'react-dom'; return createPortal(<Modal />, document.getElementById('modal-root')). Renders Modal into #modal-root, not parent. Events still bubble through React tree (not DOM tree).", "briefDescription": "API for portal rendering.", "priority": "imp" },
            { "id": "portal-modal", "title": "Modal Implementation", "description": "Create #modal-root in index.html. Modal component uses createPortal. Trap focus inside modal. Handle Escape keypress. Prevent body scroll. aria-modal, role='dialog'. Consider Radix or Headless UI.", "briefDescription": "Building accessible modals.", "priority": "imp" },
            { "id": "portal-tooltip", "title": "Tooltip Implementation", "description": "Calculate position relative to trigger element. Portal to document.body for z-index freedom. Use Floating UI / Popper for positioning. Handle viewport edges. Accessibility: aria-describedby.", "briefDescription": "Properly positioned tooltips.", "priority": "look" }
          ]
        },
        {
          "id": "react-performance",
          "title": "Performance",
          "description": "React apps can become slow without performance optimization. Learn code splitting, memoization, virtualization, and profiling to build fast applications.",
          "briefDescription": "Optimizing React application performance.",
          "priority": "must",
          "children": [
            { "id": "code-splitting", "title": "Code Splitting", "description": "const Component = lazy(() => import('./Component')). Split by route, by feature, by below-the-fold. Reduces initial bundle. Webpack/Vite handle splitting. Suspense for loading states. Preload on hover.", "briefDescription": "Load code on demand.", "priority": "must" },
            { "id": "react-memoization", "title": "Memoization", "description": "React.memo for components, useMemo for values, useCallback for functions. Prevent unnecessary re-renders and recalculations. Profile before optimizing — memoization has overhead. Use wisely.", "briefDescription": "Cache components and values.", "priority": "must" },
            { "id": "virtualization", "title": "Virtualization", "description": "Only render visible items in long lists. react-window, react-virtuoso, TanStack Virtual. Measure item heights. VariableSizeList for different heights. Essential for 1000+ items. Improves memory too.", "briefDescription": "Efficient long list rendering.", "priority": "imp" },
            { "id": "profiler-api", "title": "Profiler API", "description": "<Profiler id='nav' onRender={(id, phase, duration) => log(id, duration)}>. Programmatic performance measurement. phase: 'mount' | 'update'. actualDuration vs baseDuration. Use in development.", "briefDescription": "Measure component render times.", "priority": "look" },
            { "id": "devtools-performance", "title": "DevTools Performance Tab", "description": "React DevTools Profiler: visualize renders, identify slow components. Browser Performance tab: flame charts, long tasks. Lighthouse for overall performance. Record, analyze, optimize.", "briefDescription": "Profile with browser and React tools.", "priority": "imp" },
            { "id": "avoiding-rerenders", "title": "Avoiding Unnecessary Re-renders", "description": "Memoize expensive children. Stable references (useMemo, useCallback). Move state down (co-locating). Lift expensive computation above frequently changing components. Split contexts. Profile first.", "briefDescription": "Strategies to reduce re-renders.", "priority": "must" },
            { "id": "image-optimization", "title": "Image Optimization", "description": "next/image in Next.js for automatic optimization. Lazy loading: loading='lazy'. Modern formats: WebP, AVIF. Responsive srcset. Proper sizing - don't scale down large images. Image CDN.", "briefDescription": "Optimize images for web.", "priority": "imp" },
            { "id": "bundle-analysis", "title": "Bundle Size Analysis", "description": "webpack-bundle-analyzer, source-map-explorer. Identify large dependencies. Tree-shaking: import { fn } from 'lib', not import lib. Replace heavy libraries. Lazy load non-critical code.", "briefDescription": "Analyze and reduce bundle size.", "priority": "imp" }
          ]
        },
        {
          "id": "react-patterns",
          "title": "Patterns & Architecture",
          "description": "React patterns help organize code for maintainability and reusability. Learn established patterns used in professional React codebases.",
          "briefDescription": "Architectural patterns for React apps.",
          "priority": "imp",
          "children": [
            { "id": "container-presentational", "title": "Container/Presentational Pattern", "description": "Separate smart (stateful, logic) and dumb (UI only) components. Container handles data/state, passes to presentational via props. Presentational is reusable, testable. Pattern less needed with hooks.", "briefDescription": "Separate logic from presentation.", "priority": "imp" },
            { "id": "compound-components", "title": "Compound Components", "description": "<Select><Select.Trigger /><Select.Content>{items}</Select.Content></Select>. Components that work together with implicit state sharing. Context for internal state. Flexible, intuitive API. Radix, Headless UI use this.", "briefDescription": "Related components sharing implicit state.", "priority": "imp" },
            { "id": "provider-pattern", "title": "Provider Pattern", "description": "Wrap app/section with providers supplying context: <ThemeProvider><AuthProvider><App /></AuthProvider></ThemeProvider>. Common for themes, auth, routing. Provider manages state, consumers access.", "briefDescription": "Context providers for shared state.", "priority": "must" },
            { "id": "controlled-uncontrolled", "title": "Controlled vs Uncontrolled", "description": "Controlled: parent manages state via value/onChange. Uncontrolled: component manages own state, exposes via ref/callback. Support both for flexibility: value prop presence determines mode.", "briefDescription": "Component control patterns.", "priority": "must" },
            { "id": "headless-components", "title": "Headless Components", "description": "Provide behavior/state without UI. useSelect(), useDialog() return props to spread. Consumer provides markup. Maximum flexibility. Headless UI, Radix, Downshift, React Aria. Separate logic from styling.", "briefDescription": "Logic without opinionated UI.", "priority": "imp" },
            { "id": "atomic-design", "title": "Atomic Design", "description": "Atoms (button, input), Molecules (search form), Organisms (header), Templates (page layouts), Pages. Hierarchical component organization. Design system methodology. Not React-specific but commonly applied.", "briefDescription": "Component hierarchy methodology.", "priority": "look" }
          ]
        },
        {
          "id": "react-testing",
          "title": "Testing React",
          "description": "Testing ensures React components work correctly and prevents regressions. Learn React Testing Library for user-centric testing, along with mocking and async patterns.",
          "briefDescription": "Testing strategies for React applications.",
          "priority": "must",
          "children": [
            { "id": "jest-react", "title": "Jest", "description": "Default JavaScript testing framework. describe, test, expect. Mocking with jest.mock(), jest.fn(). Coverage reports. Snapshots (use sparingly). Setup in setupTests.ts. Fast, parallel execution.", "briefDescription": "JavaScript testing framework.", "priority": "must" },
            {
              "id": "react-testing-library",
              "title": "React Testing Library",
              "description": "Testing library focused on testing components how users use them. Queries by text, role, label — not implementation. 'The more your tests resemble the way your software is used, the more confidence they give you.'",
              "briefDescription": "User-centric component testing.",
              "priority": "must",
              "children": [
                { "id": "rtl-render", "title": "render, screen, fireEvent, waitFor", "description": "render(<Component />). screen.getByText('Hello'). fireEvent.click(button). await waitFor(() => expect(...)).  screen is preferred over destructuring. waitFor for async updates.", "briefDescription": "Core testing utilities.", "priority": "must" },
                { "id": "rtl-userevent", "title": "userEvent", "description": "userEvent.click(), userEvent.type(). More realistic than fireEvent — simulates full user interaction (focus, keydown, keyup, etc.). Async in v14: await userEvent.click(). Preferred over fireEvent.", "briefDescription": "Realistic user interaction simulation.", "priority": "must" },
                { "id": "rtl-custom-render", "title": "Custom Render with Providers", "description": "Wrap render with providers: const customRender = (ui) => render(<Providers>{ui}</Providers>). Export from test-utils.ts. Import customRender instead of render. Same API, includes context.", "briefDescription": "Pre-wrap components with context.", "priority": "imp" }
              ]
            },
            { "id": "snapshot-testing", "title": "Snapshot Testing", "description": "expect(tree).toMatchSnapshot(). Saves rendered output. Detects unexpected changes. Easy to update. CONS: Brittle, large diffs, developers blindly update. Use sparingly for stable UI. Prefer explicit assertions.", "briefDescription": "Record and compare rendered output.", "priority": "look" },
            { "id": "mocking-modules", "title": "Mocking Modules", "description": "jest.mock('./api', () => ({ fetchData: jest.fn() })). Mock before importing. jest.spyOn for partial mocks. Mock resolved values: mockFn.mockResolvedValue(data). Reset between tests: jest.clearAllMocks().", "briefDescription": "Replace modules with test doubles.", "priority": "must" },
            { "id": "testing-hooks", "title": "Testing Hooks", "description": "@testing-library/react-hooks (or RTL renderHook). const { result } = renderHook(() => useCounter()). act(() => result.current.increment()). Test custom hooks in isolation. Or test through component.", "briefDescription": "Test custom hooks directly.", "priority": "imp" },
            { "id": "testing-async", "title": "Testing Async Code", "description": "await waitFor(() => expect(screen.getByText('Loaded'))).toBeInTheDocument(). findBy* queries wait automatically. waitFor for assertions. Mock timers: jest.useFakeTimers(). Avoid testing implementation details.", "briefDescription": "Handle async operations in tests.", "priority": "must" },
            { "id": "msw-testing", "title": "MSW (Mock Service Worker)", "description": "Mock HTTP at network level. Works with any fetch implementation. rest.get('/api/user', (req, res, ctx) => res(ctx.json({ name: 'John' }))). Same mocks for tests and development. Realistic API simulation.", "briefDescription": "Mock network requests in tests.", "priority": "imp" }
          ]
        }
      ]
    },
    {
      "id": "redux-state-management",
      "title": "Redux & State Management",
      "description": "Redux is a predictable state container for JavaScript applications. While React has built-in state management, Redux provides a structured approach for complex applications with shared state. This section covers Redux fundamentals, Redux Toolkit (the modern approach), RTK Query for data fetching, and alternative state management libraries.",
      "briefDescription": "Global state management with Redux and alternatives.",
      "priority": "must",
      "children": [
        {
          "id": "redux-core",
          "title": "Core Concepts",
          "description": "Redux follows a strict unidirectional data flow: actions describe what happened, reducers specify how state changes, and the store holds the single source of truth. Understanding these concepts is essential before using Redux Toolkit.",
          "briefDescription": "Fundamental Redux architecture and patterns.",
          "priority": "must",
          "children": [
            { "id": "redux-store", "title": "Store", "description": "Single source of truth for application state. Created with createStore (legacy) or configureStore (RTK). Holds entire state tree. Access state via store.getState(). Only way to change: dispatch actions. Subscribe to changes: store.subscribe(listener).", "briefDescription": "The single state container.", "priority": "must" },
            { "id": "redux-actions", "title": "Actions", "description": "Plain JavaScript objects describing what happened: { type: 'ADD_TODO', payload: { text: 'Learn Redux' } }. type is required (string, usually SCREAMING_CASE). payload carries data. Actions are the only way to trigger state changes.", "briefDescription": "Objects describing state changes.", "priority": "must" },
            { "id": "redux-action-creators", "title": "Action Creators", "description": "Functions that create actions: const addTodo = (text) => ({ type: 'ADD_TODO', payload: { text } }). Encapsulate action creation. Can be async (with middleware). dispatch(addTodo('Learn Redux')). RTK createSlice generates these automatically.", "briefDescription": "Functions that return action objects.", "priority": "must" },
            {
              "id": "redux-reducers",
              "title": "Reducers",
              "description": "Pure functions that take current state and action, return new state: (state, action) => newState. Never mutate state directly. Handle different action types with switch or if statements. Return previous state for unknown actions.",
              "briefDescription": "Pure functions that compute new state.",
              "priority": "must",
              "children": [
                { "id": "reducer-pure-fns", "title": "Pure Functions", "description": "No side effects, no API calls, no mutations. Same input = same output. Don't modify arguments. Return new objects: { ...state, count: state.count + 1 }. Predictable, testable, enables time-travel debugging.", "briefDescription": "Rules for reducer functions.", "priority": "must" },
                { "id": "combine-reducers", "title": "Combining Reducers", "description": "combineReducers({ users: usersReducer, posts: postsReducer }). Split logic by domain. Each reducer manages its slice. Combined into root reducer. State shape mirrors reducer keys. RTK configureStore does this automatically.", "briefDescription": "Compose multiple reducers.", "priority": "imp" },
                { "id": "root-reducer", "title": "Root Reducer", "description": "Top-level reducer passed to createStore. Usually result of combineReducers. Can wrap with higher-order reducer for cross-cutting concerns (reset state, dev tools). Single entry point for all actions.", "briefDescription": "Top-level combined reducer.", "priority": "imp" }
              ]
            },
            { "id": "redux-dispatch", "title": "Dispatch", "description": "store.dispatch(action) sends action to reducers. Only way to trigger state update. Returns the action (useful for chaining). With React-Redux: const dispatch = useDispatch(); dispatch(increment()). Synchronous by default.", "briefDescription": "Method to send actions to store.", "priority": "must" },
            { "id": "redux-selectors", "title": "Selectors", "description": "Functions that extract data from state: const selectTodos = state => state.todos. Encapsulate state shape. Can compute derived data. Memoize with createSelector (Reselect) for performance. useSelector(selectTodos) in components.", "briefDescription": "Functions to read state slices.", "priority": "must" },
            { "id": "redux-unidirectional", "title": "Unidirectional Data Flow", "description": "UI dispatches action → action goes to reducer → reducer computes new state → store notifies subscribers → UI reads new state and re-renders. One-way, predictable, traceable. Makes debugging easier.", "briefDescription": "One-way data flow pattern.", "priority": "must" }
          ]
        },
        {
          "id": "redux-toolkit",
          "title": "Redux Toolkit (RTK)",
          "description": "The official, recommended way to write Redux. Simplifies store setup, reduces boilerplate, includes useful utilities, and has good defaults. If you're using Redux, you should be using Redux Toolkit.",
          "briefDescription": "Modern Redux with less boilerplate.",
          "priority": "must",
          "children": [
            { "id": "rtk-configure-store", "title": "configureStore", "description": "const store = configureStore({ reducer: { todos: todosReducer } }). Replaces createStore. Auto-combines reducers. Includes redux-thunk, devtools by default. Optionally add middleware, enhancers, preloadedState.", "briefDescription": "Simplified store creation.", "priority": "must" },
            {
              "id": "rtk-create-slice",
              "title": "createSlice",
              "description": "The core of RTK. Generates action creators and action types automatically. Write 'mutating' logic that becomes immutable (via Immer). Dramatically reduces Redux boilerplate.",
              "briefDescription": "Define reducers and actions together.",
              "priority": "must",
              "children": [
                { "id": "slice-reducers", "title": "Reducers", "description": "createSlice({ name: 'todos', initialState: [], reducers: { addTodo: (state, action) => { state.push(action.payload) } } }). Write mutating code — Immer handles immutability. Automatically generates action creators and types.", "briefDescription": "Define state updates in slice.", "priority": "must" },
                { "id": "slice-extra-reducers", "title": "Extra Reducers", "description": "extraReducers: (builder) => { builder.addCase(fetchTodos.fulfilled, (state, action) => { state.items = action.payload }) }. Handle actions from other slices or async thunks. builder.addCase, addMatcher, addDefaultCase.", "briefDescription": "Handle external actions.", "priority": "must" },
                { "id": "slice-prepare", "title": "Prepare Callbacks", "description": "reducers: { addTodo: { reducer: (state, action) => {}, prepare: (text) => ({ payload: { id: nanoid(), text } }) } }. Transform payload before reducer. Add generated IDs, timestamps. Keeps reducer pure.", "briefDescription": "Transform payload before reduction.", "priority": "imp" }
              ]
            },
            {
              "id": "rtk-async-thunk",
              "title": "createAsyncThunk",
              "description": "Standard approach for async logic in Redux Toolkit. Generates pending/fulfilled/rejected actions automatically. Handles loading and error states consistently.",
              "briefDescription": "Handle async operations in Redux.",
              "priority": "must",
              "children": [
                { "id": "thunk-states", "title": "Pending, Fulfilled, Rejected", "description": "createAsyncThunk('todos/fetch', async () => await api.getTodos()). Dispatches todos/fetch/pending, then fulfilled or rejected. Handle in extraReducers: builder.addCase(fetchTodos.pending, ...).addCase(fetchTodos.fulfilled, ...)", "briefDescription": "Automatic lifecycle actions.", "priority": "must" },
                { "id": "thunk-api", "title": "Thunk API", "description": "async (arg, thunkAPI) => { const state = thunkAPI.getState(); thunkAPI.dispatch(otherAction()); return thunkAPI.rejectWithValue({ message: 'Error' }); }. Access store, dispatch, and control rejection payload.", "briefDescription": "Thunk function utilities.", "priority": "imp" }
              ]
            },
            { "id": "rtk-entity-adapter", "title": "createEntityAdapter", "description": "const adapter = createEntityAdapter({ selectId: (item) => item.id, sortComparer: (a, b) => a.name.localeCompare(b.name) }). Normalized state shape. CRUD methods: addOne, updateOne, removeOne. getSelectors() for reading.", "briefDescription": "Manage normalized entity collections.", "priority": "imp" },
            {
              "id": "rtk-create-selector",
              "title": "createSelector (Reselect)",
              "description": "Create memoized selectors for derived data. Only recomputes when inputs change. Essential for performance with large state trees or expensive computations.",
              "briefDescription": "Memoized selectors for derived state.",
              "priority": "must",
              "children": [
                { "id": "memoized-selectors", "title": "Memoized Selectors", "description": "const selectCompletedTodos = createSelector([selectTodos], (todos) => todos.filter(t => t.completed)). Only recomputes if selectTodos result changes. Prevents unnecessary re-renders.", "briefDescription": "Cache computed values.", "priority": "must" },
                { "id": "input-selectors", "title": "Input Selectors", "description": "First arguments to createSelector. Each returns a value. Output selector receives all input results. (selectTodos, selectFilter) => (todos, filter) => todos.filter(...). Chain selectors for composition.", "briefDescription": "Selectors that provide inputs.", "priority": "imp" },
                { "id": "derived-data", "title": "Derived Data", "description": "Don't store computed data in state — compute with selectors. Total price from cart items, filtered/sorted lists, aggregations. Keeps state minimal. Single source of truth.", "briefDescription": "Compute rather than store.", "priority": "must" }
              ]
            }
          ]
        },
        {
          "id": "rtk-query",
          "title": "RTK Query",
          "description": "Data fetching and caching solution built into Redux Toolkit. Eliminates need to write thunks, loading state, normalization. Similar to React Query but integrated with Redux. The recommended approach for data fetching in Redux apps.",
          "briefDescription": "Data fetching and caching for Redux.",
          "priority": "must",
          "children": [
            { "id": "rtkq-create-api", "title": "createApi", "description": "const api = createApi({ reducerPath: 'api', baseQuery: fetchBaseQuery({ baseUrl: '/api' }), endpoints: (builder) => ({ getTodos: builder.query({ query: () => 'todos' }) }) }). Central API definition. Auto-generates hooks.", "briefDescription": "Define API endpoints.", "priority": "must" },
            { "id": "rtkq-fetch-base-query", "title": "fetchBaseQuery", "description": "Wrapper around fetch with defaults. Handles JSON, headers, base URL. Add prepareHeaders for auth tokens. Can create custom baseQuery for axios, graphql, etc.", "briefDescription": "Configure base request behavior.", "priority": "imp" },
            { "id": "rtkq-endpoints", "title": "Endpoints (query, mutation)", "description": "builder.query for GET: { query: (id) => `todos/${id}` }. builder.mutation for POST/PUT/DELETE: { query: (data) => ({ url: 'todos', method: 'POST', body: data }) }. Generates useGetTodosQuery, useAddTodoMutation hooks.", "briefDescription": "Define read and write operations.", "priority": "must" },
            { "id": "rtkq-cache-tags", "title": "Cache Tags", "description": "providesTags: ['Todos'] on queries. invalidatesTags: ['Todos'] on mutations. After mutation, queries with matching tags refetch. Fine-grained: providesTags: (result) => result.map(t => ({ type: 'Todo', id: t.id })).", "briefDescription": "Automatic cache invalidation.", "priority": "must" },
            { "id": "rtkq-refetching", "title": "Automatic Re-fetching", "description": "Refetches when: tags invalidated, component remounts (configurable), window regains focus (refetchOnFocus), network reconnects (refetchOnReconnect). Configure globally or per-endpoint.", "briefDescription": "Data stays fresh automatically.", "priority": "imp" },
            { "id": "rtkq-polling", "title": "Polling", "description": "useGetTodosQuery(undefined, { pollingInterval: 5000 }). Fetches every N milliseconds. Stops when component unmounts or skip: true. Good for real-time data without WebSockets.", "briefDescription": "Periodic data refreshing.", "priority": "look" },
            { "id": "rtkq-optimistic", "title": "Optimistic Updates", "description": "onQueryStarted: async (arg, { dispatch, queryFulfilled }) => { const patch = dispatch(api.util.updateQueryData('getTodos', undefined, draft => { draft.push(arg) })); try { await queryFulfilled } catch { patch.undo() } }", "briefDescription": "Update UI before server confirms.", "priority": "imp" },
            { "id": "rtkq-codegen", "title": "Code Generation (OpenAPI)", "description": "@rtk-query/codegen-openapi generates endpoints from OpenAPI/Swagger spec. Type-safe API automatically. npx @rtk-query/codegen-openapi configFile.ts. Reduces manual endpoint definition.", "briefDescription": "Generate API from OpenAPI spec.", "priority": "look" },
            { "id": "rtkq-vs-react-query", "title": "Comparison with React Query", "description": "RTK Query: integrated with Redux, action-based, devtools in Redux. React Query: standalone, more mature, more features (infinite queries easier). Both excellent. RTK Query if already using Redux.", "briefDescription": "Choose based on existing stack.", "priority": "imp" }
          ]
        },
        {
          "id": "redux-middleware",
          "title": "Middleware",
          "description": "Middleware extends dispatch, allowing async operations, logging, crash reporting, and more. Redux Toolkit includes thunk by default. Learn how middleware works and alternatives like Saga.",
          "briefDescription": "Extend Redux with side effects.",
          "priority": "imp",
          "children": [
            { "id": "custom-middleware", "title": "Custom Middleware", "description": "const logger = store => next => action => { console.log(action); return next(action); }. Curried function. Access store.getState(), store.dispatch(). Call next(action) to continue chain. Return value used by dispatch.", "briefDescription": "Write your own middleware.", "priority": "imp" },
            { "id": "redux-thunk", "title": "Redux Thunk", "description": "Dispatch functions instead of objects: dispatch((dispatch, getState) => { /* async logic */ dispatch(action) }). Included in RTK by default. Simple async handling. createAsyncThunk abstracts common patterns.", "briefDescription": "Async logic via function dispatch.", "priority": "must" },
            {
              "id": "redux-saga",
              "title": "Redux Saga",
              "description": "Middleware using generator functions for complex async flows. More powerful than thunks for complex scenarios: cancellation, debouncing, racing. Steeper learning curve but very capable.",
              "briefDescription": "Generator-based side effect management.",
              "priority": "look",
              "children": [
                { "id": "saga-generators", "title": "Generators", "description": "function* mySaga() { yield ... }. Pausable functions. yield expression suspends execution. Generator iterator controls flow. Makes async look synchronous. ES6 feature underlying Saga.", "briefDescription": "ES6 generator functions.", "priority": "look" },
                { "id": "saga-effects", "title": "Effects", "description": "take(action) waits for action. put(action) dispatches. call(fn, args) calls function. fork(saga) runs in parallel. select(selector) reads state. yield effect() declarative, testable descriptions.", "briefDescription": "Saga effect creators.", "priority": "look" },
                { "id": "saga-watchers", "title": "Watchers", "description": "function* watchFetch() { yield takeEvery('FETCH_REQUESTED', fetchSaga) }. Listen for actions, spawn workers. takeEvery, takeLatest, takeLeading. takeLatest cancels previous.", "briefDescription": "Listen and respond to actions.", "priority": "look" },
                { "id": "saga-workers", "title": "Workers", "description": "function* fetchSaga(action) { try { const data = yield call(api.fetch, action.payload); yield put({ type: 'SUCCESS', data }); } catch (e) { yield put({ type: 'FAILURE', error: e }); } }", "briefDescription": "Perform the actual side effects.", "priority": "look" }
              ]
            },
            { "id": "redux-observable", "title": "Redux Observable (RxJS)", "description": "Middleware using RxJS observables. Actions in, actions out. const epic = action$ => action$.pipe(ofType('PING'), mapTo({ type: 'PONG' })). Powerful for complex async. Requires RxJS knowledge.", "briefDescription": "Reactive extensions for Redux.", "priority": "skip" }
          ]
        },
        {
          "id": "react-redux",
          "title": "React-Redux",
          "description": "The official bindings for using Redux with React. Provides the Provider component and hooks for accessing store in components. Modern React-Redux uses hooks exclusively.",
          "briefDescription": "Connect Redux to React components.",
          "priority": "must",
          "children": [
            { "id": "rr-provider", "title": "Provider", "description": "<Provider store={store}><App /></Provider>. Wraps app at top level. Makes store available to all descendants. Use React context internally. Required for useSelector/useDispatch.", "briefDescription": "Make store available to app.", "priority": "must" },
            { "id": "rr-use-selector", "title": "useSelector", "description": "const todos = useSelector(state => state.todos). Subscribe to specific state. Component re-renders when selected value changes. Use memoized selectors for objects/arrays. Equality: shallowEqual as second arg.", "briefDescription": "Read state in components.", "priority": "must" },
            { "id": "rr-use-dispatch", "title": "useDispatch", "description": "const dispatch = useDispatch(); dispatch(addTodo('text')). Get dispatch function. Stable reference. Combine with action creators: dispatch(increment()). Used for all state changes.", "briefDescription": "Dispatch actions from components.", "priority": "must" },
            { "id": "rr-connect", "title": "connect() (Legacy)", "description": "connect(mapStateToProps, mapDispatchToProps)(Component). HOC pattern from before hooks. Still works, but hooks preferred. mapStateToProps: state => ({ todos: state.todos }). mapDispatchToProps: dispatch or object shorthand.", "briefDescription": "Legacy HOC for Redux connection.", "priority": "look" }
          ]
        },
        {
          "id": "state-normalization",
          "title": "State Normalization",
          "description": "Flatten nested data into a normalized shape with entities and IDs. Prevents data duplication, simplifies updates, improves performance. Essential pattern for complex relational data.",
          "briefDescription": "Flatten and organize state data.",
          "priority": "imp",
          "children": [
            { "id": "normalized-shape", "title": "Normalized Shape", "description": "Instead of nested arrays: { users: { byId: { 1: {...}, 2: {...} }, allIds: [1, 2] } }. Each entity type has lookup table. Relationships via IDs. createEntityAdapter helps.", "briefDescription": "ID-indexed entity storage.", "priority": "imp" },
            { "id": "entities-ids", "title": "Entities & IDs", "description": "entities: lookup object keyed by ID. ids: array of all IDs (for ordering). entity = entities[id]. list = ids.map(id => entities[id]). Can denormalize selectively in selectors.", "briefDescription": "Separate entity data from ordering.", "priority": "imp" },
            { "id": "denormalization", "title": "Denormalization", "description": "Reconstruct nested data in selectors when needed for components. Keep state normalized, views denormalized. createSelector memoizes denormalization. Don't store denormalized data.", "briefDescription": "Reconstruct nested data for views.", "priority": "imp" }
          ]
        },
        {
          "id": "redux-devtools",
          "title": "DevTools",
          "description": "Redux DevTools browser extension provides powerful debugging capabilities. See every action, inspect state, time-travel debug. Essential for Redux development.",
          "briefDescription": "Debug Redux applications.",
          "priority": "must",
          "children": [
            { "id": "devtools-extension", "title": "Redux DevTools Extension", "description": "Browser extension for Chrome, Firefox, Edge. RTK configureStore enables automatically. See action log, state tree, diff between states. Filter actions. Export/import state.", "briefDescription": "Browser extension for debugging.", "priority": "must" },
            { "id": "devtools-time-travel", "title": "Time Travel Debugging", "description": "Jump to any past state by clicking action. See how state evolved. Replay actions. Skip actions to see alternate histories. Powerful for debugging complex flows.", "briefDescription": "Navigate state history.", "priority": "must" },
            { "id": "devtools-replay", "title": "Action Replay", "description": "Re-dispatch any action. Combine with hot reloading — fix reducer, replay actions. Replay sequence of actions. Test edge cases by replaying.", "briefDescription": "Re-run actions for debugging.", "priority": "imp" }
          ]
        },
        {
          "id": "alt-state-managers",
          "title": "Alternative State Managers",
          "description": "Redux isn't the only option. Modern alternatives are simpler, have less boilerplate, and may be better fits for different project sizes and requirements.",
          "briefDescription": "Lighter Redux alternatives.",
          "priority": "imp",
          "children": [
            { "id": "zustand", "title": "Zustand", "description": "const useStore = create(set => ({ count: 0, inc: () => set(s => ({ count: s.count + 1 })) })). Minimal API. No providers, no boilerplate. Works outside React. Immer optional. Growing fast in popularity.", "briefDescription": "Simple, minimal state management.", "priority": "imp" },
            { "id": "jotai", "title": "Jotai", "description": "Atomic state: const countAtom = atom(0). const [count, setCount] = useAtom(countAtom). Bottom-up. No store configuration. Compose atoms. Primitives for async. Inspired by Recoil but simpler.", "briefDescription": "Primitive atomic state.", "priority": "look" },
            { "id": "recoil", "title": "Recoil", "description": "Facebook's atomic state library. atoms for state, selectors for derived. RecoilRoot provider. Similar to Jotai but more features. Larger bundle. Official but slower adoption.", "briefDescription": "Facebook's atomic state solution.", "priority": "look" },
            { "id": "mobx", "title": "MobX", "description": "Observable state with automatic tracking. class Store { @observable count = 0; @action inc() { this.count++ } }. makeAutoObservable(this). observer(Component) for reactivity. Different mental model from Redux.", "briefDescription": "Observable-based state management.", "priority": "look" },
            { "id": "valtio", "title": "Valtio", "description": "Proxy-based reactivity: const state = proxy({ count: 0 }). Mutate directly: state.count++. useSnapshot(state) in components. Simple, intuitive. Works with class instances. Made by Zustand team.", "briefDescription": "Proxy-based mutable state.", "priority": "look" }
          ]
        }
      ]
    },
    {
      "id": "nextjs",
      "title": "Next.js",
      "description": "Next.js is the most popular React framework for production. It provides server-side rendering, static site generation, API routes, and the new App Router with React Server Components. Understanding Next.js deeply is essential for building production-ready MERN applications with optimal performance and SEO.",
      "briefDescription": "React framework for production with SSR/SSG.",
      "priority": "must",
      "children": [
        {
          "id": "nextjs-project-structure",
          "title": "Project Structure",
          "description": "Next.js uses file-system based routing. The App Router (app/) is the modern approach with React Server Components, while Pages Router (pages/) is the legacy pattern. Understanding the conventions enables you to leverage the framework's power.",
          "briefDescription": "File-based project organization.",
          "priority": "must",
          "children": [
            { "id": "next-app-router", "title": "App Router (app/)", "description": "Modern routing system using app/ directory. Every folder is a route segment. page.tsx for UI, layout.tsx for shared layouts, loading.tsx, error.tsx, not-found.tsx for states. Server Components by default. Introduced in Next.js 13.", "briefDescription": "Modern Server Component-based routing.", "priority": "must" },
            { "id": "next-pages-router", "title": "Pages Router (pages/) [Legacy]", "description": "Original routing in pages/ directory. Each file is a route: pages/about.tsx = /about. getStaticProps, getServerSideProps for data. Still supported but App Router is preferred for new projects.", "briefDescription": "Legacy file-to-route mapping.", "priority": "look" },
            { "id": "next-file-routing", "title": "File-based Routing", "description": "Folders define routes: app/dashboard/settings/page.tsx = /dashboard/settings. No router configuration needed. Co-locate components, tests, styles with routes. Convention over configuration philosophy.", "briefDescription": "Folders and files become routes.", "priority": "must" },
            { "id": "next-route-groups", "title": "Route Groups", "description": "(folder) syntax creates groups without affecting URL: app/(marketing)/about/ renders at /about. Organize by feature/team. Share layouts within groups. Multiple root layouts possible for different sections.", "briefDescription": "Organize routes without URL effect.", "priority": "imp" },
            { "id": "next-parallel-routes", "title": "Parallel Routes", "description": "@folder convention for simultaneous routes: @modal, @sidebar can render alongside @main. Each can have own loading/error states. Useful for dashboards, modals, split views. Advanced pattern.", "briefDescription": "Render multiple pages simultaneously.", "priority": "look" },
            { "id": "next-intercepting-routes", "title": "Intercepting Routes", "description": "(.) (..) (...) (...)(...) conventions intercept navigation. /photo in modal when navigated from gallery, full page when accessed directly. Instagram-like photo modals. Complex but powerful pattern.", "briefDescription": "Intercept routes for modals.", "priority": "look" }
          ]
        },
        {
          "id": "nextjs-routing",
          "title": "Routing",
          "description": "Next.js routing goes beyond static paths with dynamic segments, catch-all routes, middleware, and special files for loading states and error handling. Master these for building complex navigation flows.",
          "briefDescription": "Advanced routing patterns and handlers.",
          "priority": "must",
          "children": [
            { "id": "next-dynamic-routes", "title": "Dynamic Routes ([slug])", "description": "Folder [slug]/ creates dynamic segment: app/posts/[id]/page.tsx matches /posts/1, /posts/2. Access params: ({ params }) => params.id. Multiple: /[category]/[product]. Static paths with generateStaticParams.", "briefDescription": "URL parameters in routes.", "priority": "must" },
            { "id": "next-catch-all", "title": "Catch-All Routes ([...slug])", "description": "[...slug]/ matches any depth: /docs/a/b/c. params.slug is array: ['a', 'b', 'c']. Good for documentation, breadcrumbs. Matches one or more segments.", "briefDescription": "Match multiple path segments.", "priority": "imp" },
            { "id": "next-optional-catch-all", "title": "Optional Catch-All ([[...slug]])", "description": "[[...slug]]/ matches zero or more: /docs and /docs/a/b. Optional params. slug is undefined for root. More flexible than catch-all.", "briefDescription": "Optional multi-segment matching.", "priority": "imp" },
            { "id": "next-route-handlers", "title": "Route Handlers (route.ts)", "description": "app/api/users/route.ts defines API endpoint. Export GET, POST, PUT, DELETE, etc. functions. export async function GET(request: Request) { return Response.json({ users }) }. Replaces pages/api.", "briefDescription": "API endpoints in App Router.", "priority": "must" },
            {
              "id": "next-middleware",
              "title": "Middleware",
              "description": "middleware.ts at project root runs before every request. Intercept, redirect, rewrite, add headers. Great for auth, localization, A/B testing. Runs on Edge Runtime.",
              "briefDescription": "Request interception before routing.",
              "priority": "must",
              "children": [
                { "id": "middleware-matcher", "title": "matcher Config", "description": "export const config = { matcher: ['/dashboard/:path*', '/api/:path*'] }. Limit middleware to specific paths. Regex-like patterns. Exclude static files. Performance optimization.", "briefDescription": "Specify which routes trigger middleware.", "priority": "imp" },
                { "id": "middleware-manipulation", "title": "Request/Response Manipulation", "description": "NextRequest has cookies(), headers(), nextUrl. NextResponse for redirect, rewrite, json. NextResponse.next() to continue. Set cookies: response.cookies.set().", "briefDescription": "Modify requests and responses.", "priority": "imp" },
                { "id": "middleware-redirects", "title": "Redirects & Rewrites", "description": "NextResponse.redirect(new URL('/login', request.url)). NextResponse.rewrite() changes destination but keeps URL. Conditional redirects based on auth, locale, feature flags.", "briefDescription": "Redirect or rewrite requests.", "priority": "must" }
              ]
            },
            { "id": "next-loading-ui", "title": "Loading UI (loading.tsx)", "description": "loading.tsx in route folder shows during page load. Wraps page in <Suspense>. Instant loading states. Skeleton UIs. Nested loading for incremental display. No loading prop gymnastics.", "briefDescription": "Automatic loading states.", "priority": "must" },
            { "id": "next-error-handling", "title": "Error Handling (error.tsx)", "description": "error.tsx catches errors in route segment. 'use client' required. Receives error and reset function. Nested error boundaries. Isolate failures. Global error.tsx at root catches all.", "briefDescription": "Automatic error boundaries.", "priority": "must" },
            { "id": "next-not-found", "title": "Not Found (not-found.tsx)", "description": "not-found.tsx for 404 pages. Trigger with notFound() function. Can be nested. app/not-found.tsx is global fallback. Customize per section with nested not-found files.", "briefDescription": "Custom 404 handling.", "priority": "imp" },
            {
              "id": "next-layout",
              "title": "Layout (layout.tsx)",
              "description": "Shared UI that persists across route changes. Wraps child pages. Root layout is required. State preserved on navigation — perfect for navbars, sidebars, authentication context.",
              "briefDescription": "Persistent shared UI components.",
              "priority": "must",
              "children": [
                { "id": "next-root-layout", "title": "Root Layout", "description": "app/layout.tsx wraps entire app. Must include <html> and <body>. Place providers, global styles, metadata here. One per app. Sets up application shell.", "briefDescription": "App-wide wrapper required.", "priority": "must" },
                { "id": "next-nested-layouts", "title": "Nested Layouts", "description": "app/dashboard/layout.tsx wraps all dashboard pages. Compose layouts. Dashboard sidebar persists across /dashboard/* pages. Each segment can have own layout.", "briefDescription": "Per-section persistent layouts.", "priority": "must" },
                { "id": "next-template-layout", "title": "Template vs Layout", "description": "template.tsx recreates instance on navigation (no state preservation). Use for enter/exit animations, per-page effects. Layout preserves state, template resets.", "briefDescription": "Layouts persist, templates reset.", "priority": "imp" }
              ]
            }
          ]
        },
        {
          "id": "nextjs-rendering",
          "title": "Rendering Strategies",
          "description": "Next.js supports multiple rendering strategies: SSR, SSG, ISR, CSR, and streaming. Understanding when to use each is crucial for performance and user experience. The App Router makes choosing and mixing approaches easier.",
          "briefDescription": "SSR, SSG, ISR, CSR, and streaming.",
          "priority": "must",
          "children": [
            {
              "id": "next-ssr",
              "title": "Server-Side Rendering (SSR)",
              "description": "Render HTML on every request. Fresh data guaranteed. Essential for personalized or frequently changing content. Slower than static but always current.",
              "briefDescription": "Render on each request.",
              "priority": "must",
              "children": [
                { "id": "next-getserversideprops", "title": "getServerSideProps (Pages Router)", "description": "export async function getServerSideProps(context) { return { props: { data } } }. Runs on every request. context has req, res, params, query. Return props to component. Pages Router pattern.", "briefDescription": "Legacy per-request data fetching.", "priority": "look" },
                { "id": "next-dynamic-rendering", "title": "Dynamic Rendering (App Router)", "description": "fetch with cache: 'no-store' or use cookies()/headers(). Opts route into dynamic rendering. const data = await fetch(url, { cache: 'no-store' }). Or export const dynamic = 'force-dynamic'.", "briefDescription": "Modern per-request rendering.", "priority": "must" }
              ]
            },
            {
              "id": "next-ssg",
              "title": "Static Site Generation (SSG)",
              "description": "Pre-render at build time. Fastest possible response. Perfect for content that doesn't change often. CDN-cacheable. The default in Next.js when possible.",
              "briefDescription": "Pre-render at build time.",
              "priority": "must",
              "children": [
                { "id": "next-getstaticprops", "title": "getStaticProps (Pages Router)", "description": "export async function getStaticProps() { return { props: { data } } }. Runs at build time. Data embedded in HTML. Combine with getStaticPaths for dynamic routes.", "briefDescription": "Legacy static data fetching.", "priority": "look" },
                { "id": "next-getstaticpaths", "title": "getStaticPaths (Pages Router)", "description": "export async function getStaticPaths() { return { paths: [{ params: { id: '1' } }], fallback: true/false/'blocking' } }. Define which dynamic paths to pre-render.", "briefDescription": "Legacy static path generation.", "priority": "look" },
                { "id": "next-generatestaticparams", "title": "generateStaticParams (App Router)", "description": "export async function generateStaticParams() { return [{ id: '1' }, { id: '2' }] }. In page.tsx alongside dynamic route. Define paths at build time. Replaces getStaticPaths.", "briefDescription": "Modern static path generation.", "priority": "must" }
              ]
            },
            {
              "id": "next-isr",
              "title": "Incremental Static Regeneration (ISR)",
              "description": "Best of static and dynamic. Serve static, regenerate in background. Fresh-ish data with static performance. Groundbreaking Next.js feature.",
              "briefDescription": "Static with background updates.",
              "priority": "must",
              "children": [
                { "id": "next-revalidate", "title": "revalidate", "description": "fetch(url, { next: { revalidate: 60 } }) or export const revalidate = 60 in page. Page revalidates after 60 seconds. Stale-while-revalidate pattern. Time-based freshness.", "briefDescription": "Time-based revalidation.", "priority": "must" },
                { "id": "next-on-demand", "title": "On-Demand Revalidation", "description": "revalidatePath('/posts') or revalidateTag('posts') in server action or route handler. Invalidate immediately when data changes. Webhook from CMS triggers revalidation.", "briefDescription": "Trigger revalidation programmatically.", "priority": "must" }
              ]
            },
            { "id": "next-csr", "title": "Client-Side Rendering (CSR)", "description": "'use client' components fetch data client-side. Use SWR or React Query. Good for dashboards, personalized data, real-time updates. Combine with server components for hybrid approach.", "briefDescription": "Fetch data in browser.", "priority": "imp" },
            {
              "id": "next-streaming",
              "title": "Streaming",
              "description": "Progressive HTML delivery. Users see content as it renders. Improved perceived performance. Built on React 18 Suspense and streaming SSR.",
              "briefDescription": "Progressive content delivery.",
              "priority": "imp",
              "children": [
                { "id": "next-suspense", "title": "React Suspense", "description": "<Suspense fallback={<Loading />}><AsyncComponent /></Suspense>. Show fallback while async component loads. Multiple Suspense boundaries for incremental UI. loading.tsx creates automatic Suspense.", "briefDescription": "Declarative loading boundaries.", "priority": "must" },
                { "id": "next-streaming-ssr", "title": "Streaming SSR", "description": "HTML streams to browser progressively. Static shell first, dynamic parts as ready. No waiting for slowest query. Feels faster even if total time same. React 18 renderToPipeableStream.", "briefDescription": "Progressive HTML rendering.", "priority": "imp" }
              ]
            },
            { "id": "next-ppr", "title": "Partial Pre-rendering (PPR)", "description": "Experimental. Static shell with dynamic holes. Pre-render as much as possible, stream dynamic parts. Best of static and dynamic. export const experimental_ppr = true. Coming in Next.js 15+.", "briefDescription": "Mix static and dynamic seamlessly.", "priority": "look" }
          ]
        },
        {
          "id": "nextjs-server-components",
          "title": "Server Components",
          "description": "React Server Components run on the server, send rendered HTML to client, and never ship JavaScript. This is the foundation of the App Router. Understanding the server/client boundary is essential.",
          "briefDescription": "Components that run only on server.",
          "priority": "must",
          "children": [
            { "id": "next-server-vs-client", "title": "Server vs Client Components", "description": "Server (default): No useState, useEffect. Access databases, await in component. Zero client JS. Client ('use client'): Interactive, browser APIs, React hooks. Serialize data across boundary. Think carefully about boundary placement.", "briefDescription": "When and why to use each.", "priority": "must" },
            { "id": "next-use-client", "title": "'use client' Directive", "description": "'use client' at top of file marks client boundary. All imports become client components. Place as deep as possible. Only client components can use hooks, event handlers, browser APIs.", "briefDescription": "Mark file as client component.", "priority": "must" },
            { "id": "next-use-server", "title": "'use server' Directive", "description": "'use server' marks server actions — functions callable from client. Form actions, button handlers. Secure server code. Serializable arguments only. Creates RPC-like experience.", "briefDescription": "Mark functions as server actions.", "priority": "must" },
            {
              "id": "next-server-actions",
              "title": "Server Actions",
              "description": "Functions that run on the server, callable from client components. Replace API routes for mutations. Progressive enhancement with forms. The future of React data mutations.",
              "briefDescription": "Server functions for mutations.",
              "priority": "must",
              "children": [
                { "id": "server-action-forms", "title": "Form Actions", "description": "<form action={submitForm}>. No handleSubmit needed. Works without JavaScript (progressive enhancement). Form data passed as FormData. Native browser form submission enhanced.", "briefDescription": "Forms that call server directly.", "priority": "must" },
                { "id": "server-action-mutations", "title": "Mutations", "description": "async function createTodo(formData: FormData) { 'use server'; await db.insert(formData.get('title')); }. Direct database access. No separate API route. Secure by default.", "briefDescription": "Database writes from actions.", "priority": "must" },
                { "id": "server-action-revalidation", "title": "Revalidation", "description": "After mutation: revalidatePath('/todos') or revalidateTag('todos'). UI updates automatically. Combine with redirect() for navigation.", "briefDescription": "Update cache after mutations.", "priority": "must" },
                { "id": "server-action-redirects", "title": "Redirects", "description": "redirect('/success') in server action. Throws redirect error caught by Next.js. Use after successful mutations. Works with try/finally for cleanup.", "briefDescription": "Navigate after action completion.", "priority": "imp" }
              ]
            },
            {
              "id": "next-rsc-data-fetching",
              "title": "Data Fetching in Server Components",
              "description": "Server Components can be async and fetch data directly. No useEffect, no loading states in component. This is the recommended pattern in App Router.",
              "briefDescription": "Async data fetching in components.",
              "priority": "must",
              "children": [
                { "id": "rsc-fetch-cache", "title": "fetch with cache options", "description": "cache: 'force-cache' (default, static), 'no-store' (dynamic), next: { revalidate: 60 } (ISR). Control caching per-fetch. Fine-grained control.", "briefDescription": "Cache configuration per request.", "priority": "must" },
                { "id": "rsc-revalidation", "title": "Revalidation Strategies", "description": "Time-based: { next: { revalidate: 3600 } }. Tag-based: { next: { tags: ['posts'] } } then revalidateTag('posts'). Path-based: revalidatePath('/posts'). Choose based on invalidation needs.", "briefDescription": "Control data freshness.", "priority": "must" },
                { "id": "rsc-parallel-fetch", "title": "Parallel Data Fetching", "description": "const [users, posts] = await Promise.all([fetchUsers(), fetchPosts()]). Don't await sequentially. parallel = faster. Independent data should load in parallel.", "briefDescription": "Load independent data together.", "priority": "must" },
                { "id": "rsc-sequential-fetch", "title": "Sequential Data Fetching", "description": "When data depends on previous: const user = await getUser(); const posts = await getUserPosts(user.id). Use when necessary. Parallel when possible.", "briefDescription": "Load dependent data in order.", "priority": "imp" }
              ]
            },
            {
              "id": "rsc-composition",
              "title": "Composition Patterns",
              "description": "Server and client components compose together with specific patterns. Pass server data as props, not the other way around. Understanding these patterns prevents common mistakes.",
              "briefDescription": "Combining server and client components.",
              "priority": "must",
              "children": [
                { "id": "rsc-server-client-children", "title": "Server Component with Client Children", "description": "Server component can render client children: <ServerWrapper><ClientInteractive /></ServerWrapper>. Pass client component as prop/children. Client island in server sea. Keep interactivity minimal.", "briefDescription": "Server parents, client children.", "priority": "must" },
                { "id": "rsc-passing-data", "title": "Passing Server Data to Client", "description": "Fetch in server component, pass as props: <ClientComponent data={serverData} />. Data serialized across boundary. Only serializable data. No functions unless 'use server'.", "briefDescription": "Props cross the boundary.", "priority": "must" }
              ]
            }
          ]
        },
        {
          "id": "nextjs-api-routes",
          "title": "API Routes",
          "description": "Build backend API endpoints within your Next.js application. Route handlers in App Router or pages/api in Pages Router. Good for BFF pattern, webhooks, and simple APIs.",
          "briefDescription": "Backend endpoints in Next.js.",
          "priority": "imp",
          "children": [
            { "id": "next-pages-api", "title": "Pages Router: pages/api/", "description": "pages/api/users.ts exports default handler: (req, res) => res.json({ users }). Express-like req/res. Dynamic: [id].ts. Catch-all: [...slug].ts. Legacy pattern.", "briefDescription": "Legacy API route pattern.", "priority": "look" },
            { "id": "next-app-route", "title": "App Router: route.ts", "description": "app/api/users/route.ts exports HTTP method handlers. export async function GET(request: Request) { return Response.json(data) }. Web standard Request/Response. Modern pattern.", "briefDescription": "Modern Web API routes.", "priority": "must" },
            { "id": "next-req-res-helpers", "title": "Request & Response Helpers", "description": "NextRequest extends Request: cookies(), nextUrl for searchParams. NextResponse.json(), redirect(), rewrite(). Set headers, cookies in response.", "briefDescription": "Enhanced Request/Response APIs.", "priority": "imp" },
            { "id": "next-dynamic-api", "title": "Dynamic API Routes", "description": "app/api/users/[id]/route.ts. Access params: export async function GET(request, { params }) { const { id } = params; }. Same dynamic segment syntax as pages.", "briefDescription": "API routes with parameters.", "priority": "imp" },
            { "id": "next-api-middleware", "title": "API Middleware", "description": "Use middleware.ts for API routes too. Auth checks, rate limiting, CORS. Or create wrapper functions for shared logic across handlers.", "briefDescription": "Shared logic for API routes.", "priority": "imp" }
          ]
        },
        {
          "id": "nextjs-data-fetching",
          "title": "Data Fetching",
          "description": "Next.js extends fetch with caching and revalidation options. Combined with Server Actions for mutations, this provides a complete data layer without additional libraries.",
          "briefDescription": "Extended fetch and mutations.",
          "priority": "must",
          "children": [
            {
              "id": "next-fetch-extended",
              "title": "fetch API (Extended)",
              "description": "Next.js extends native fetch with caching controls. Same API you know, with powerful options. Automatic request deduplication during render.",
              "briefDescription": "Enhanced fetch with caching.",
              "priority": "must",
              "children": [
                { "id": "fetch-cache", "title": "cache: 'force-cache' | 'no-store'", "description": "force-cache: (default) cache indefinitely, static. no-store: never cache, always fresh, dynamic rendering. Simple toggle between static and dynamic.", "briefDescription": "Basic cache control.", "priority": "must" },
                { "id": "fetch-revalidate", "title": "next: { revalidate }", "description": "fetch(url, { next: { revalidate: 60 } }). Revalidate after N seconds. ISR per-fetch. 0 = no cache. Omit or false = cache forever.", "briefDescription": "Time-based revalidation.", "priority": "must" },
                { "id": "fetch-tags", "title": "next: { tags }", "description": "fetch(url, { next: { tags: ['posts'] } }). Label fetches. revalidateTag('posts') invalidates all tagged fetches. Fine-grained invalidation.", "briefDescription": "Tagged cache invalidation.", "priority": "must" }
              ]
            },
            { "id": "next-server-actions-mutation", "title": "Server Actions for Mutations", "description": "Prefer Server Actions over API routes for mutations. 'use server' functions in forms or called from client. Simpler, type-safe, progressive enhancement.", "briefDescription": "Mutations without API routes.", "priority": "must" },
            { "id": "next-revalidate-funcs", "title": "revalidatePath / revalidateTag", "description": "import { revalidatePath, revalidateTag } from 'next/cache'. Call in Server Actions or Route Handlers. revalidatePath('/posts') for specific route. revalidateTag('posts') for tagged data.", "briefDescription": "Programmatic cache invalidation.", "priority": "must" },
            { "id": "next-cookies-headers", "title": "Cookies & Headers Access", "description": "import { cookies, headers } from 'next/headers'. cookies().get('session'), headers().get('authorization'). Server-only. Reading them opts into dynamic rendering.", "briefDescription": "Access request cookies and headers.", "priority": "imp" },
            { "id": "next-fetch-patterns", "title": "Parallel & Sequential Fetching", "description": "Parallel: Promise.all([fetch1(), fetch2()]). Sequential: const a = await f1(); const b = await f2(a). Use Suspense boundaries for progressive loading. Don't waterfall unnecessarily.", "briefDescription": "Optimize fetch order.", "priority": "imp" }
          ]
        },
        {
          "id": "nextjs-caching",
          "title": "Caching",
          "description": "Next.js has multiple caching layers: request memoization, data cache, full route cache, and router cache. Understanding these layers helps optimize performance and troubleshoot issues.",
          "briefDescription": "Multi-layer caching system.",
          "priority": "imp",
          "children": [
            { "id": "next-request-memo", "title": "Request Memoization", "description": "Same fetch called multiple times in render tree? Deduplicated automatically. Only one network request. Result shared. React feature during single render. Short-lived.", "briefDescription": "Deduplicate fetches in single render.", "priority": "imp" },
            { "id": "next-data-cache", "title": "Data Cache", "description": "Persists fetch results across requests and deployments. Controlled by cache and revalidate options. Stored on server. Survives redeploys unless invalidated.", "briefDescription": "Persistent server-side fetch cache.", "priority": "must" },
            { "id": "next-route-cache", "title": "Full Route Cache", "description": "Statically rendered routes cached at build time. HTML and RSC payload stored. Served without rendering. Invalidated by revalidation. Production only.", "briefDescription": "Pre-rendered route caching.", "priority": "imp" },
            { "id": "next-router-cache", "title": "Router Cache", "description": "Client-side cache of visited routes. Back button instant. Prefetched routes cached. 30s for dynamic, 5min for static (defaults). Invalidated by router.refresh().", "briefDescription": "Client-side navigation cache.", "priority": "imp" },
            { "id": "next-cache-invalidation", "title": "Cache Invalidation", "description": "revalidatePath, revalidateTag for data cache. router.refresh() for router cache. Time-based with revalidate. On-demand most flexible.", "briefDescription": "Clear stale cached data.", "priority": "must" },
            { "id": "next-unstable-cache", "title": "unstable_cache", "description": "import { unstable_cache } from 'next/cache'. Wrap non-fetch async functions: unstable_cache(async () => db.query(), ['key'], { revalidate: 60 }). Cache anything, not just fetch.", "briefDescription": "Cache arbitrary async functions.", "priority": "look" }
          ]
        },
        {
          "id": "nextjs-optimization",
          "title": "Optimization",
          "description": "Next.js provides built-in optimizations for images, fonts, scripts, and metadata. These components and APIs dramatically improve Core Web Vitals with minimal effort.",
          "briefDescription": "Built-in performance optimizations.",
          "priority": "must",
          "children": [
            {
              "id": "next-image",
              "title": "Image Optimization (next/image)",
              "description": "Automatic image optimization, resizing, and serving modern formats. Lazy loading by default. Prevents Cumulative Layout Shift. Dramatic performance improvement.",
              "briefDescription": "Optimized image component.",
              "priority": "must",
              "children": [
                { "id": "next-image-sizing", "title": "Sizing & Layout", "description": "width/height required for remote images (prevents CLS). fill for responsive containers. sizes prop for responsive images: sizes='(max-width: 768px) 100vw, 50vw'. style={{ objectFit: 'cover' }}.", "briefDescription": "Control image dimensions.", "priority": "must" },
                { "id": "next-image-formats", "title": "Formats (WebP, AVIF)", "description": "Automatically serves WebP or AVIF based on browser support. Smaller files, same quality. No manual conversion needed. Configured in next.config.js formats array.", "briefDescription": "Modern image formats automatically.", "priority": "imp" },
                { "id": "next-image-priority", "title": "Priority Loading", "description": "priority prop for LCP images. Preloads image. Disables lazy loading. Use for above-fold hero images. Only one or two per page.", "briefDescription": "Preload critical images.", "priority": "must" },
                { "id": "next-image-placeholder", "title": "Placeholder (blur)", "description": "placeholder='blur' shows blurred preview. Static imports get blurDataURL automatically. Remote images need blurDataURL prop. Improves perceived performance.", "briefDescription": "Blur placeholder while loading.", "priority": "imp" }
              ]
            },
            {
              "id": "next-font",
              "title": "Font Optimization (next/font)",
              "description": "Zero layout shift fonts. Automatic self-hosting. Preload critical fonts. Built-in for Google Fonts and local fonts.",
              "briefDescription": "Optimized font loading.",
              "priority": "must",
              "children": [
                { "id": "next-font-google", "title": "Google Fonts", "description": "import { Inter } from 'next/font/google'. const inter = Inter({ subsets: ['latin'] }). className={inter.className}. Self-hosted, no external requests. Preloaded.", "briefDescription": "Self-hosted Google Fonts.", "priority": "must" },
                { "id": "next-font-local", "title": "Local Fonts", "description": "import localFont from 'next/font/local'. const myFont = localFont({ src: './fonts/MyFont.woff2' }). Same optimizations for custom fonts.", "briefDescription": "Optimize custom font files.", "priority": "imp" },
                { "id": "next-font-variable", "title": "Variable Fonts", "description": "Single file with multiple weights/widths. const inter = Inter({ variable: '--font-inter' }). CSS: font-family: var(--font-inter). Smaller total size.", "briefDescription": "Efficient variable font usage.", "priority": "look" }
              ]
            },
            {
              "id": "next-script",
              "title": "Script Optimization (next/script)",
              "description": "Control when and how third-party scripts load. Prevent render blocking. Improve Core Web Vitals affected by analytics, ads, chat widgets.",
              "briefDescription": "Strategic script loading.",
              "priority": "imp",
              "children": [
                { "id": "next-script-strategies", "title": "Loading Strategies", "description": "beforeInteractive: before hydration (rare). afterInteractive: after hydration (default, analytics). lazyOnload: after everything (low priority). worker: in web worker (experimental).", "briefDescription": "Control script loading timing.", "priority": "imp" }
              ]
            },
            {
              "id": "next-metadata",
              "title": "Metadata API",
              "description": "Manage document head declaratively. SEO, Open Graph, Twitter cards. Static or dynamic metadata per route. Type-safe configuration.",
              "briefDescription": "SEO and social metadata.",
              "priority": "must",
              "children": [
                { "id": "next-static-metadata", "title": "Static Metadata", "description": "export const metadata: Metadata = { title: 'My App', description: 'Welcome' }. In layout.tsx or page.tsx. Type-safe. Merged with parent metadata.", "briefDescription": "Hardcoded page metadata.", "priority": "must" },
                { "id": "next-dynamic-metadata", "title": "Dynamic Metadata (generateMetadata)", "description": "export async function generateMetadata({ params }) { const post = await getPost(params.id); return { title: post.title } }. Fetch-based metadata. Access params, searchParams.", "briefDescription": "Metadata based on data.", "priority": "must" },
                { "id": "next-opengraph", "title": "Open Graph", "description": "openGraph: { title, description, images: [{ url }] }. Social sharing previews. opengraph-image.tsx generates images dynamically. og images in same folder.", "briefDescription": "Social media previews.", "priority": "imp" },
                { "id": "next-jsonld", "title": "JSON-LD", "description": "Structured data for SEO. <script type='application/ld+json'>{JSON.stringify(schema)}</script> in page. Article, Product, FAQ schemas. Rich search results.", "briefDescription": "Structured data for search engines.", "priority": "look" }
              ]
            },
            { "id": "next-link-prefetch", "title": "Link Prefetching (next/link)", "description": "<Link href='/about'>. Prefetches by default when link enters viewport. prefetch={false} to disable. Instant navigation for prefetched routes. Works with router cache.", "briefDescription": "Preload linked pages.", "priority": "must" },
            { "id": "next-bundle-analysis", "title": "Bundle Analysis", "description": "@next/bundle-analyzer. ANALYZE=true npm run build. Visualize bundle contents. Find large dependencies. Optimize code splitting. Identify import issues.", "briefDescription": "Visualize JavaScript bundles.", "priority": "imp" }
          ]
        },
        {
          "id": "nextjs-auth",
          "title": "Authentication in Next.js",
          "description": "Authentication in Next.js can use dedicated libraries like NextAuth.js (Auth.js), third-party services like Clerk, or custom implementations. Each approach has tradeoffs in complexity and control.",
          "briefDescription": "Auth strategies for Next.js apps.",
          "priority": "must",
          "children": [
            {
              "id": "next-auth",
              "title": "NextAuth.js / Auth.js",
              "description": "The most popular auth library for Next.js. Supports many providers, handles session management, works with App Router. Now called Auth.js for framework-agnostic use.",
              "briefDescription": "Popular Next.js auth library.",
              "priority": "must",
              "children": [
                { "id": "nextauth-providers", "title": "Providers (Google, GitHub, Credentials)", "description": "OAuth providers: Google, GitHub, Discord, etc. Credentials provider for email/password. Configure in auth.ts. Each provider has specific setup requirements.", "briefDescription": "Authentication provider options.", "priority": "must" },
                { "id": "nextauth-session", "title": "Session Management", "description": "useSession() hook for client. getServerSession() for server. SessionProvider wraps app. session has user object. status: 'loading' | 'authenticated' | 'unauthenticated'.", "briefDescription": "Access session in components.", "priority": "must" },
                { "id": "nextauth-jwt-db", "title": "JWT vs Database Sessions", "description": "JWT: stateless, no DB needed, stored in cookie. Database: sessions in DB, more control, can revoke. Choose based on needs. Database needed for credentials provider.", "briefDescription": "Session storage strategies.", "priority": "imp" },
                { "id": "nextauth-middleware", "title": "Middleware Protection", "description": "export { auth as middleware } from './auth'. config.matcher protects routes. Or check session in middleware and redirect. Protect API routes and pages.", "briefDescription": "Protect routes with middleware.", "priority": "must" }
              ]
            },
            { "id": "next-clerk", "title": "Clerk", "description": "Full-featured auth service. Drop-in components: <SignIn />, <UserButton />. User management dashboard. MFA, organizations, invitations. Paid service. Very low friction setup.", "briefDescription": "Managed auth service.", "priority": "imp" },
            { "id": "next-custom-auth", "title": "Custom Auth", "description": "Build your own with jose for JWT, bcrypt for passwords. cookies() for sessions. Full control but more work. Consider for specific requirements not met by libraries.", "briefDescription": "Build auth from scratch.", "priority": "look" }
          ]
        },
        {
          "id": "nextjs-i18n",
          "title": "Internationalization (i18n)",
          "description": "Support multiple languages and regions in your Next.js app. Route-based or domain-based localization. Content translation and locale detection.",
          "briefDescription": "Multi-language support.",
          "priority": "look",
          "children": [
            { "id": "next-app-i18n", "title": "App Router i18n", "description": "app/[lang]/page.tsx pattern. generateStaticParams for locales. Use next-intl or react-i18next for translations. Middleware for locale detection and redirect.", "briefDescription": "i18n in App Router.", "priority": "look" },
            { "id": "next-locale-detection", "title": "Locale Detection", "description": "Read Accept-Language header in middleware. Negotiate best locale match. Redirect to localized route. Store preference in cookie.", "briefDescription": "Detect user's preferred language.", "priority": "look" },
            { "id": "next-route-localization", "title": "Route Localization", "description": "/en/about, /es/about pattern. Or subdomains: en.site.com. Dictionary files per locale. next-intl provides <TranslationProvider> and t() function.", "briefDescription": "Localized URL routing.", "priority": "look" }
          ]
        },
        {
          "id": "nextjs-deployment",
          "title": "Deployment",
          "description": "Deploy Next.js to Vercel for zero-config, or self-host with Node.js, Docker, or edge platforms. Each option has different capabilities and tradeoffs.",
          "briefDescription": "Hosting and deployment options.",
          "priority": "must",
          "children": [
            { "id": "next-vercel", "title": "Vercel", "description": "Made by Next.js team. Zero config. Automatic previews, analytics, edge functions. Free tier generous. Production ISR, image optimization, edge middleware all work. Recommended for most projects.", "briefDescription": "Official hosting platform.", "priority": "must" },
            { "id": "next-self-hosted", "title": "Self-hosted (Node.js server)", "description": "npm run build && npm run start. Runs Node.js server. Need to handle: process management, load balancing, CDN for static assets. Full control but more ops work.", "briefDescription": "Run on your own servers.", "priority": "imp" },
            { "id": "next-docker", "title": "Docker", "description": "Multi-stage Dockerfile: build stage creates .next, production stage runs next start. Standalone output mode (output: 'standalone' in config) for smaller image. Deploy anywhere containers run.", "briefDescription": "Containerized deployment.", "priority": "imp" },
            { "id": "next-runtime", "title": "Edge Runtime vs Node.js Runtime", "description": "Edge: fast cold starts, limited APIs, close to users. Node.js: full Node APIs, more memory, traditional hosting. export const runtime = 'edge' | 'nodejs'. Per-route opt-in.", "briefDescription": "Choose execution environment.", "priority": "imp" },
            { "id": "next-env-vars", "title": "Environment Variables", "description": "NEXT_PUBLIC_* exposed to client. Others server-only. .env.local for local dev. Set in Vercel dashboard or deployment platform. next.config.js: env: {} for build-time.", "briefDescription": "Configure environment variables.", "priority": "must" }
          ]
        }
      ]
    },
    {
      "id": "nodejs",
      "title": "Node.js",
      "description": "Node.js is a JavaScript runtime built on Chrome's V8 engine. It enables JavaScript on the server side with non-blocking I/O and an event-driven architecture. Understanding Node.js internals, core modules, and best practices is essential for the backend of MERN applications.",
      "briefDescription": "Server-side JavaScript runtime environment.",
      "priority": "must",
      "children": [
        {
          "id": "node-architecture",
          "title": "Node.js Architecture",
          "description": "Node.js combines the V8 JavaScript engine with libuv for async I/O. Understanding the event loop, single-threaded model, and non-blocking nature helps write efficient Node.js applications.",
          "briefDescription": "How Node.js works internally.",
          "priority": "must",
          "children": [
            { "id": "node-v8", "title": "V8 Engine", "description": "Google's JavaScript engine written in C++. Compiles JS to machine code (JIT compilation). Handles memory management, garbage collection. Same engine as Chrome. Constantly optimized for performance.", "briefDescription": "JavaScript execution engine.", "priority": "imp" },
            { "id": "node-libuv", "title": "libuv", "description": "C library providing event loop, async I/O, thread pool. Abstracts OS differences. Handles file system, network, child processes. The secret behind Node's async capabilities. Cross-platform.", "briefDescription": "Async I/O and event loop library.", "priority": "imp" },
            { "id": "node-event-driven", "title": "Event-Driven Architecture", "description": "Node.js uses events for async operations. EventEmitter pattern throughout. Callbacks, Promises, async/await built on this foundation. Non-blocking by design.", "briefDescription": "Event-based programming model.", "priority": "must" },
            { "id": "node-nonblocking", "title": "Non-blocking I/O", "description": "I/O operations don't block the main thread. fs.readFile returns immediately, callback runs when done. Enables handling thousands of concurrent connections. Key advantage over traditional servers.", "briefDescription": "Async operations don't wait.", "priority": "must" },
            {
              "id": "node-event-loop",
              "title": "Single-Threaded Event Loop",
              "description": "Node.js runs JavaScript on a single thread with an event loop for concurrency. Understanding the phases, tick timing, and queue priorities is crucial for performance.",
              "briefDescription": "How the event loop processes work.",
              "priority": "must",
              "children": [
                { "id": "event-loop-phases", "title": "Phases", "description": "Timers (setTimeout, setInterval) → Pending callbacks (I/O) → Idle/Prepare (internal) → Poll (new I/O events) → Check (setImmediate) → Close (socket.on('close')). Each phase has a queue.", "briefDescription": "Event loop execution phases.", "priority": "must" },
                { "id": "nexttick-immediate", "title": "process.nextTick vs setImmediate", "description": "nextTick runs before next event loop phase — highest priority, can starve loop. setImmediate runs in Check phase, after I/O. nextTick for current operation cleanup, setImmediate for next iteration.", "briefDescription": "Different async scheduling.", "priority": "must" },
                { "id": "micro-macro-tasks", "title": "Microtasks vs Macrotasks", "description": "Microtasks (Promise.then, queueMicrotask) run between phases. Macrotasks (setTimeout, setImmediate, I/O) run in their phase. Microtasks always drain before next macrotask.", "briefDescription": "Task queue priorities.", "priority": "must" }
              ]
            }
          ]
        },
        {
          "id": "node-core-modules",
          "title": "Core Modules",
          "description": "Node.js includes powerful built-in modules for file system, networking, cryptography, and more. No npm install needed. Understanding these modules is fundamental to Node.js development.",
          "briefDescription": "Built-in Node.js functionality.",
          "priority": "must",
          "children": [
            {
              "id": "node-fs",
              "title": "fs (File System)",
              "description": "Read, write, manipulate files and directories. Sync and async versions of all methods. Modern fs.promises API for cleaner async code.",
              "briefDescription": "File and directory operations.",
              "priority": "must",
              "children": [
                { "id": "fs-sync-async", "title": "Sync vs Async Methods", "description": "fs.readFileSync blocks. fs.readFile uses callback. Sync OK for startup scripts, never in request handlers. Async keeps event loop free. Always prefer async in servers.", "briefDescription": "Blocking vs non-blocking APIs.", "priority": "must" },
                { "id": "fs-streams", "title": "Streams-based File I/O", "description": "fs.createReadStream, fs.createWriteStream. Process large files without loading into memory. Pipe: readStream.pipe(writeStream). Essential for large files, transformations.", "briefDescription": "Memory-efficient file handling.", "priority": "must" },
                { "id": "fs-promises", "title": "fs.promises API", "description": "import { readFile } from 'fs/promises'. Async/await friendly. const data = await readFile('file.txt', 'utf8'). Modern, clean API. Use this over callbacks.", "briefDescription": "Promise-based file operations.", "priority": "must" },
                { "id": "fs-watch", "title": "Watching Files", "description": "fs.watch(filename, (event, filename) => {}). Detect file changes. Use for hot reloading, build tools. chokidar library for robust watching. Native watch has platform quirks.", "briefDescription": "Monitor file/directory changes.", "priority": "imp" }
              ]
            },
            {
              "id": "node-path",
              "title": "path",
              "description": "Utilities for working with file and directory paths. Platform-independent path handling. Essential for cross-platform code.",
              "briefDescription": "Path manipulation utilities.",
              "priority": "must",
              "children": [
                { "id": "path-methods", "title": "join, resolve, basename, dirname, extname", "description": "path.join('a', 'b') = 'a/b'. path.resolve gives absolute path. basename: filename. dirname: directory. extname: extension. Use instead of string concatenation.", "briefDescription": "Common path operations.", "priority": "must" },
                { "id": "path-cross-platform", "title": "path.sep & Cross-platform", "description": "path.sep is '/' on POSIX, '\\' on Windows. path.join handles this automatically. Always use path module, never hardcode separators. path.posix and path.win32 for specific.", "briefDescription": "Platform-safe path handling.", "priority": "imp" }
              ]
            },
            { "id": "node-os", "title": "os", "description": "Operating system info: os.platform(), os.cpus(), os.totalmem(), os.freemem(), os.homedir(), os.tmpdir(). Useful for system monitoring, temp file locations, platform-specific logic.", "briefDescription": "System information access.", "priority": "imp" },
            {
              "id": "node-http",
              "title": "http / https",
              "description": "Create HTTP servers and make HTTP requests. Foundation for Express and other frameworks. Understanding raw http module helps debug and customize.",
              "briefDescription": "HTTP server and client.",
              "priority": "must",
              "children": [
                { "id": "http-server", "title": "Creating Server", "description": "http.createServer((req, res) => { res.end('Hello'); }).listen(3000). IncomingMessage (req) and ServerResponse (res) objects. Foundation for Express.", "briefDescription": "Basic HTTP server.", "priority": "must" },
                { "id": "http-req-res", "title": "Request & Response Objects", "description": "req.method, req.url, req.headers. res.statusCode, res.setHeader(), res.write(), res.end(). Streams underneath. Must call res.end() or connection hangs.", "briefDescription": "HTTP message interfaces.", "priority": "must" },
                { "id": "http-post-data", "title": "Handling POST Data", "description": "let body = ''; req.on('data', chunk => body += chunk); req.on('end', () => { const data = JSON.parse(body); }). Stream chunks. Express body-parser simplifies this.", "briefDescription": "Read request body chunks.", "priority": "imp" }
              ]
            },
            {
              "id": "node-url",
              "title": "url",
              "description": "Parse and construct URLs. Modern WHATWG URL class or legacy url.parse().",
              "briefDescription": "URL parsing and formatting.",
              "priority": "imp",
              "children": [
                { "id": "url-class", "title": "URL Class", "description": "const u = new URL('https://example.com/path?q=1'). u.hostname, u.pathname, u.searchParams.get('q'). WHATWG standard. Modern approach.", "briefDescription": "Modern URL API.", "priority": "must" },
                { "id": "url-querystring", "title": "Query String Parsing", "description": "url.searchParams is URLSearchParams instance. .get(), .set(), .append(), .delete(), .toString(). Or querystring module for legacy. Parse and build query strings.", "briefDescription": "Work with URL parameters.", "priority": "imp" }
              ]
            },
            {
              "id": "node-crypto",
              "title": "crypto",
              "description": "Cryptographic functionality: hashing, encryption, secure random. Essential for authentication, password storage, security features.",
              "briefDescription": "Cryptographic operations.",
              "priority": "must",
              "children": [
                { "id": "crypto-hashing", "title": "Hashing (SHA, MD5)", "description": "crypto.createHash('sha256').update(data).digest('hex'). One-way transformation. SHA-256 for security, MD5 only for checksums (broken for security). Use for file integrity, signatures.", "briefDescription": "One-way hash functions.", "priority": "must" },
                { "id": "crypto-hmac", "title": "HMAC", "description": "crypto.createHmac('sha256', secret).update(message).digest('hex'). Hash with secret key. Verify message authenticity. Used in JWT, webhooks, API signing.", "briefDescription": "Keyed hash for authentication.", "priority": "imp" },
                { "id": "crypto-encryption", "title": "Encryption/Decryption (AES)", "description": "crypto.createCipheriv('aes-256-gcm', key, iv). Encrypt sensitive data. Use IV, never ECB mode. GCM mode provides authentication. Decrypt with createDecipheriv.", "briefDescription": "Symmetric encryption.", "priority": "imp" },
                { "id": "crypto-random", "title": "Random Bytes", "description": "crypto.randomBytes(32) for secure random data. crypto.randomUUID() for UUIDs. Use for tokens, keys, salts. Never use Math.random() for security.", "briefDescription": "Cryptographically secure random.", "priority": "must" },
                { "id": "bcrypt-vs-crypto", "title": "bcrypt vs crypto", "description": "bcrypt specifically for passwords: automatic salt, configurable work factor, slow by design. crypto.scrypt() is built-in alternative. Never store passwords with simple hashing.", "briefDescription": "Password hashing choice.", "priority": "must" }
              ]
            },
            {
              "id": "node-events",
              "title": "events",
              "description": "EventEmitter class for event-driven programming. Pattern used throughout Node.js core. Crucial for building event-based architectures.",
              "briefDescription": "Event emission and handling.",
              "priority": "must",
              "children": [
                { "id": "event-emitter", "title": "EventEmitter", "description": "const emitter = new EventEmitter(). Many core modules extend EventEmitter: streams, http.Server. Base class for event-driven components.", "briefDescription": "Core event class.", "priority": "must" },
                { "id": "event-methods", "title": "on, emit, once, removeListener", "description": "emitter.on('event', callback) subscribes. emitter.emit('event', data) triggers. once() for single use. removeListener() or off() to unsubscribe. Avoid memory leaks.", "briefDescription": "EventEmitter API.", "priority": "must" },
                { "id": "custom-events", "title": "Custom Events", "description": "class MyClass extends EventEmitter { action() { this.emit('done', result); } }. myInstance.on('done', handler). Decouple components. Publish-subscribe pattern.", "briefDescription": "Create your own event emitters.", "priority": "imp" },
                { "id": "error-event", "title": "Error Event", "description": "Special 'error' event. If no listener, crashes process. Always handle: emitter.on('error', handler). Streams, servers emit errors this way.", "briefDescription": "Handle emitter errors.", "priority": "must" }
              ]
            },
            {
              "id": "node-child-process",
              "title": "child_process",
              "description": "Spawn child processes to run shell commands, other programs. Essential for CPU-intensive tasks, running external tools.",
              "briefDescription": "Run external processes.",
              "priority": "imp",
              "children": [
                { "id": "child-methods", "title": "exec, execFile, spawn, fork", "description": "exec: shell command, buffered output. execFile: direct executable, no shell. spawn: streams, for long-running. fork: Node.js child with IPC. Choose based on needs.", "briefDescription": "Different process spawning methods.", "priority": "imp" },
                { "id": "child-ipc", "title": "IPC Communication", "description": "fork() creates channel between parent and child. child.send(message), process.on('message', handler). Structured data passing. Good for worker processes.", "briefDescription": "Inter-process communication.", "priority": "imp" }
              ]
            },
            {
              "id": "node-cluster",
              "title": "cluster",
              "description": "Run multiple Node.js processes sharing the same port. Utilize multi-core CPUs. Master-worker architecture for scaling.",
              "briefDescription": "Multi-process scaling.",
              "priority": "imp",
              "children": [
                { "id": "cluster-pattern", "title": "Master-Worker Pattern", "description": "if (cluster.isPrimary) { fork workers } else { run server }. Master manages workers. Workers handle requests. One worker per CPU core typically.", "briefDescription": "Primary process manages workers.", "priority": "imp" },
                { "id": "cluster-load-balance", "title": "Load Balancing", "description": "OS distributes connections across workers (round-robin on most systems). Workers share port 3000. Automatic failover if worker dies. Master can restart workers.", "briefDescription": "Distribute load across workers.", "priority": "imp" },
                { "id": "pm2-clustering", "title": "PM2 Clustering", "description": "pm2 start app.js -i max. Handles clustering automatically. Monitoring, logs, restart on crash. Production-ready process management. Easier than manual clustering.", "briefDescription": "Clustering with PM2.", "priority": "must" }
              ]
            },
            {
              "id": "node-workers",
              "title": "worker_threads",
              "description": "True multi-threading in Node.js. Run JavaScript in parallel threads. Share memory with SharedArrayBuffer. Good for CPU-intensive work.",
              "briefDescription": "Multi-threaded JavaScript.",
              "priority": "imp",
              "children": [
                { "id": "worker-shared-buffer", "title": "SharedArrayBuffer", "description": "Share memory between threads. const sab = new SharedArrayBuffer(1024). Use Atomics for safe operations. Avoids data copying overhead. Complex but powerful.", "briefDescription": "Shared memory between threads.", "priority": "look" },
                { "id": "worker-messagechannel", "title": "MessageChannel", "description": "Send messages between workers. parentPort.postMessage(data). parentPort.on('message', handler). Structured clone for complex objects.", "briefDescription": "Worker message passing.", "priority": "imp" },
                { "id": "worker-pools", "title": "Worker Pools", "description": "Create pool of workers, distribute tasks. Libraries: piscina, workerpool. Reuse workers, queue tasks. Efficient for repeated CPU work.", "briefDescription": "Manage worker lifecycle.", "priority": "imp" }
              ]
            },
            {
              "id": "node-stream",
              "title": "stream",
              "description": "Process data piece by piece without loading into memory. Four types: Readable, Writable, Transform, Duplex. Fundamental for efficient I/O.",
              "briefDescription": "Memory-efficient data processing.",
              "priority": "must",
              "children": [
                { "id": "stream-readable", "title": "Readable Streams", "description": "fs.createReadStream, http.IncomingMessage. on('data'), on('end'), on('error'). read() for pulling. Flowing vs paused modes. Source of data.", "briefDescription": "Data sources (files, requests).", "priority": "must" },
                { "id": "stream-writable", "title": "Writable Streams", "description": "fs.createWriteStream, http.ServerResponse. write(chunk), end(). on('finish') when done. Drain event for backpressure. Destination for data.", "briefDescription": "Data destinations (files, responses).", "priority": "must" },
                { "id": "stream-transform", "title": "Transform Streams", "description": "Modify data in transit. zlib.createGzip(), crypto.createCipher(). Both readable and writable. transform(chunk, encoding, callback). Data goes in, modified data comes out.", "briefDescription": "Modify data as it flows.", "priority": "imp" },
                { "id": "stream-duplex", "title": "Duplex Streams", "description": "Both readable and writable, independent. net.Socket is duplex. Read and write simultaneously. Separate read and write sides.", "briefDescription": "Bidirectional data streams.", "priority": "look" },
                { "id": "stream-piping", "title": "Piping", "description": "readable.pipe(writable). Chain: file.pipe(gzip).pipe(response). Automatic backpressure handling. pipeline() for error handling: pipeline(src, transform, dest, callback).", "briefDescription": "Connect streams together.", "priority": "must" },
                { "id": "stream-backpressure", "title": "Backpressure", "description": "When writable slower than readable. write() returns false when buffer full. Wait for 'drain' event. pipe() handles automatically. Must handle manually otherwise.", "briefDescription": "Handle slow consumers.", "priority": "imp" }
              ]
            },
            {
              "id": "node-buffer",
              "title": "buffer",
              "description": "Handle binary data directly. Fixed-size chunk of memory. Essential for files, network protocols, cryptography.",
              "briefDescription": "Binary data handling.",
              "priority": "imp",
              "children": [
                { "id": "buffer-create", "title": "Buffer.from, Buffer.alloc", "description": "Buffer.from('hello') from string. Buffer.from([1, 2, 3]) from array. Buffer.alloc(10) zeroed. Never use new Buffer() (deprecated, security issues).", "briefDescription": "Create buffer instances.", "priority": "must" },
                { "id": "buffer-encoding", "title": "Encoding/Decoding", "description": "buf.toString('utf8'), buf.toString('base64'), buf.toString('hex'). Buffer.from(str, 'base64'). Convert between representations. Default is utf8.", "briefDescription": "Convert buffer to/from strings.", "priority": "must" },
                { "id": "buffer-binary", "title": "Binary Data Handling", "description": "buf[0] access bytes. buf.readUInt32BE(), buf.writeInt16LE() for multi-byte values. Endianness matters. Protocol parsing, file formats.", "briefDescription": "Low-level binary operations.", "priority": "look" }
              ]
            },
            { "id": "node-net", "title": "net", "description": "Low-level TCP networking. net.createServer() for TCP server. net.connect() for client. Socket is duplex stream. Foundation for http module. Use for custom protocols.", "briefDescription": "TCP networking.", "priority": "look" },
            {
              "id": "node-util",
              "title": "util",
              "description": "Utility functions for common patterns. promisify and inspect are most used.",
              "briefDescription": "Helpful utility functions.",
              "priority": "imp",
              "children": [
                { "id": "util-promisify", "title": "promisify", "description": "util.promisify(fs.readFile). Convert callback-based functions to promises. Only works with error-first callbacks. Essential for modernizing legacy APIs.", "briefDescription": "Convert callbacks to promises.", "priority": "must" },
                { "id": "util-inspect", "title": "inspect", "description": "util.inspect(obj, { depth: null, colors: true }). Pretty-print objects. Custom inspect: [Symbol.for('nodejs.util.inspect.custom')](). Better than JSON.stringify for debugging.", "briefDescription": "Object inspection and formatting.", "priority": "imp" },
                { "id": "util-types", "title": "types", "description": "util.types.isPromise(), isAsyncFunction(), isDate(), etc. Type checking utilities. More reliable than typeof for some cases.", "briefDescription": "Type checking helpers.", "priority": "look" }
              ]
            }
          ]
        },
        {
          "id": "node-npm",
          "title": "NPM & Package Management",
          "description": "npm is the default package manager for Node.js. Understanding package.json, versioning, and package management is essential for any Node.js developer.",
          "briefDescription": "Package management and dependencies.",
          "priority": "must",
          "children": [
            {
              "id": "npm-package-json",
              "title": "package.json",
              "description": "The manifest file for Node.js projects. Defines dependencies, scripts, metadata, and more.",
              "briefDescription": "Project configuration file.",
              "priority": "must",
              "children": [
                { "id": "npm-deps", "title": "dependencies vs devDependencies", "description": "dependencies: needed in production. devDependencies: only for development (testing, building). npm install --save-dev for dev deps. Production installs skip devDeps.", "briefDescription": "Runtime vs development dependencies.", "priority": "must" },
                { "id": "npm-peer-deps", "title": "peerDependencies", "description": "Specify compatible versions of host package. Common in plugins. npm 7+ auto-installs, earlier warns. Avoid version conflicts in shared dependencies.", "briefDescription": "Host package compatibility.", "priority": "imp" },
                { "id": "npm-scripts", "title": "scripts", "description": "\"scripts\": { \"start\": \"node server.js\", \"test\": \"jest\" }. npm run start, npm test. Pre/post hooks: pretest, postbuild. Lifecycle scripts. Task automation.", "briefDescription": "Command shortcuts and automation.", "priority": "must" },
                { "id": "npm-engines", "title": "engines", "description": "\"engines\": { \"node\": \">=18\" }. Specify required Node.js version. npm warns if mismatch. Use with .nvmrc for version switching.", "briefDescription": "Node.js version requirements.", "priority": "imp" },
                { "id": "npm-exports", "title": "main, module, exports", "description": "main: CommonJS entry. module: ES module entry. exports: modern, precise exports map. { \"exports\": { \".\": \"./dist/index.js\" } }. Controls what consumers can import.", "briefDescription": "Package entry points.", "priority": "imp" }
              ]
            },
            { "id": "npm-lockfile", "title": "package-lock.json", "description": "Locks exact versions of all dependencies. Ensures reproducible installs. Commit to version control. npm ci uses lockfile strictly. Resolves version ranges to specific versions.", "briefDescription": "Lock exact dependency versions.", "priority": "must" },
            { "id": "npm-semver", "title": "Semantic Versioning", "description": "MAJOR.MINOR.PATCH: 2.1.3. Major: breaking changes. Minor: new features, backward compatible. Patch: bug fixes. ^2.1.0 allows minor updates. ~2.1.0 allows patch updates.", "briefDescription": "Version numbering convention.", "priority": "must" },
            { "id": "npm-npx", "title": "npx", "description": "Run packages without installing: npx create-react-app myapp. Runs from node_modules/.bin first. Downloads temporarily if not installed. Great for CLI tools.", "briefDescription": "Run packages without global install.", "priority": "must" },
            { "id": "npm-publishing", "title": "Publishing Packages", "description": "npm publish. Need npm account. Versioning important. Private: @scope/package. .npmignore or files field. prepublishOnly script for builds.", "briefDescription": "Share packages on npm registry.", "priority": "look" },
            { "id": "npm-monorepos", "title": "Monorepos", "description": "npm workspaces: \"workspaces\": [\"packages/*\"]. Share dependencies. npm install from root. Turborepo for build orchestration. Lerna for advanced management.", "briefDescription": "Multi-package repositories.", "priority": "imp" }
          ]
        },
        {
          "id": "node-environment",
          "title": "Environment & Configuration",
          "description": "Managing configuration across environments is crucial for security and deployment. Learn environment variables, configuration patterns, and NODE_ENV.",
          "briefDescription": "Configuration management.",
          "priority": "must",
          "children": [
            { "id": "node-process-env", "title": "process.env", "description": "Access environment variables: process.env.DATABASE_URL. Set in shell: DATABASE_URL=xxx node app.js. All values are strings. process.env.PORT || 3000 pattern.", "briefDescription": "Read environment variables.", "priority": "must" },
            { "id": "node-dotenv", "title": "dotenv", "description": "require('dotenv').config(). Loads .env file into process.env. Don't commit .env (add to .gitignore). .env.example as template. Import early in app.", "briefDescription": "Load .env files.", "priority": "must" },
            { "id": "node-config", "title": "config Management", "description": "Libraries: config, convict, env-schema. Validate required vars. Type conversion. Default values. Centralize configuration. Fail fast on missing config.", "briefDescription": "Structured configuration handling.", "priority": "imp" },
            { "id": "node-env", "title": "NODE_ENV", "description": "Convention for environment: 'development', 'production', 'test'. Affects library behavior (Express, React). production enables optimizations. Check: process.env.NODE_ENV === 'production'.", "briefDescription": "Environment mode indicator.", "priority": "must" },
            { "id": "node-argv", "title": "Command Line Arguments", "description": "process.argv: ['/path/node', '/path/script.js', 'arg1', 'arg2']. Parse manually or use minimist, yargs, commander. Build CLI tools. process.argv.slice(2) for user args.", "briefDescription": "Read command line arguments.", "priority": "imp" }
          ]
        },
        {
          "id": "node-error-handling",
          "title": "Error Handling in Node.js",
          "description": "Proper error handling prevents crashes, enables recovery, and provides useful debugging information. Node.js has specific patterns for sync, async, and promise-based errors.",
          "briefDescription": "Handle errors gracefully.",
          "priority": "must",
          "children": [
            { "id": "node-uncaught", "title": "Uncaught Exceptions", "description": "process.on('uncaughtException', (err) => { log(err); process.exit(1); }). Last resort catch. Don't try to recover — state may be corrupted. Log and exit. Let PM2 restart.", "briefDescription": "Handle crash-level errors.", "priority": "must" },
            { "id": "node-unhandled-rejection", "title": "Unhandled Rejections", "description": "process.on('unhandledRejection', (reason, promise) => { log(reason); }). Unhandled promise rejections. Node 15+ throws by default. Always await or .catch() promises.", "briefDescription": "Handle promise rejections.", "priority": "must" },
            { "id": "node-error-types", "title": "Operational vs Programmer Errors", "description": "Operational: expected failures (network down, invalid input). Handle gracefully. Programmer: bugs (null reference). Crash and fix code. Different handling strategies.", "briefDescription": "Categorize error types.", "priority": "imp" },
            { "id": "node-error-first", "title": "Error-first Callbacks", "description": "callback(error, result). If error, first param is truthy. fs.readFile(path, (err, data) => { if (err) return handleError(err); }). Node.js callback convention.", "briefDescription": "Callback error convention.", "priority": "must" },
            { "id": "node-graceful-shutdown", "title": "Graceful Shutdown", "description": "process.on('SIGTERM', async () => { await closeConnections(); process.exit(0); }). Handle SIGTERM, SIGINT. Finish current requests. Close database connections. Prevent data loss.", "briefDescription": "Clean process termination.", "priority": "must" }
          ]
        },
        {
          "id": "node-debugging",
          "title": "Debugging",
          "description": "Node.js has built-in debugging support and integrates with Chrome DevTools and VS Code. Learn to effectively debug Node.js applications.",
          "briefDescription": "Debug Node.js applications.",
          "priority": "imp",
          "children": [
            { "id": "node-inspector", "title": "Node Inspector", "description": "Built-in debugger. node --inspect app.js (break when debugger statement). node --inspect-brk app.js (break at start). Opens WebSocket for debugger connection.", "briefDescription": "Built-in debug server.", "priority": "imp" },
            { "id": "node-inspect-flag", "title": "--inspect Flag", "description": "node --inspect=0.0.0.0:9229 app.js. Default localhost:9229. Open chrome://inspect. Connect to Node process. Set breakpoints, watch expressions.", "briefDescription": "Enable remote debugging.", "priority": "imp" },
            { "id": "node-chrome-devtools", "title": "Chrome DevTools", "description": "Open chrome://inspect. Click 'Open dedicated DevTools for Node'. Full debugging: breakpoints, call stack, scope, heap snapshots. Same tools as browser debugging.", "briefDescription": "Debug with Chrome tools.", "priority": "imp" },
            { "id": "node-vscode-debug", "title": "VS Code Debugger", "description": "launch.json configuration. F5 to start debugging. Breakpoints in editor. Variable inspection. Integrated terminal. Best developer experience for debugging.", "briefDescription": "Debug with VS Code.", "priority": "must" },
            { "id": "node-console-trace", "title": "console.trace", "description": "console.trace('message'). Prints stack trace. See how code reached this point. Quick debugging without breakpoints. Remove in production.", "briefDescription": "Print stack trace.", "priority": "imp" },
            { "id": "node-debug-module", "title": "Debug Module", "description": "const debug = require('debug')('app:server'). debug('listening on port %d', port). Enable: DEBUG=app:* node app.js. Namespaced logging. Disable in production.", "briefDescription": "Conditional debug logging.", "priority": "imp" }
          ]
        },
        {
          "id": "node-process-management",
          "title": "Process Management",
          "description": "Keep Node.js applications running reliably in production. Process managers handle restarts, clustering, logging, and monitoring.",
          "briefDescription": "Production process handling.",
          "priority": "must",
          "children": [
            {
              "id": "node-pm2",
              "title": "PM2",
              "description": "The most popular Node.js process manager. Handles clustering, restarts, logs, monitoring. Essential for production deployments.",
              "briefDescription": "Advanced process manager.",
              "priority": "must",
              "children": [
                { "id": "pm2-cluster", "title": "Cluster Mode", "description": "pm2 start app.js -i max. -i 0 or -i max uses all CPUs. Automatic load balancing. Zero-downtime reloads: pm2 reload app.", "briefDescription": "Multi-process scaling.", "priority": "must" },
                { "id": "pm2-monitoring", "title": "Process Monitoring", "description": "pm2 monit for dashboard. pm2 list shows processes. CPU, memory usage. pm2 plus for cloud monitoring. Alerts on errors, restarts.", "briefDescription": "Monitor process health.", "priority": "imp" },
                { "id": "pm2-logs", "title": "Log Management", "description": "pm2 logs. Aggregated logs from all instances. pm2 flush clears logs. Log rotation with pm2-logrotate module. Timestamps, no manual log setup.", "briefDescription": "Centralized log access.", "priority": "imp" },
                { "id": "pm2-ecosystem", "title": "Ecosystem File", "description": "ecosystem.config.js. Define apps, env vars, cluster settings. pm2 start ecosystem.config.js. Version controlled configuration. Different configs for dev/prod.", "briefDescription": "Configuration file for PM2.", "priority": "must" }
              ]
            },
            { "id": "node-forever", "title": "Forever", "description": "Simple process monitor. forever start app.js. Restarts on crash. Less features than PM2. OK for simple deployments. npm install -g forever.", "briefDescription": "Simple process runner.", "priority": "look" },
            { "id": "node-nodemon", "title": "Nodemon (Development)", "description": "nodemon app.js. Auto-restarts on file changes. Development only. Configure with nodemon.json. Watch specific directories. Ignore node_modules automatically.", "briefDescription": "Auto-restart for development.", "priority": "must" }
          ]
        },
        {
          "id": "node-security",
          "title": "Security",
          "description": "Security is crucial for Node.js applications. Understand common vulnerabilities and how to prevent them. Defense in depth approach.",
          "briefDescription": "Secure Node.js applications.",
          "priority": "must",
          "children": [
            { "id": "node-input-validation", "title": "Input Validation", "description": "Never trust user input. Validate type, length, format. Use express-validator, Joi, Zod. Reject early. Sanitize for specific context (SQL, HTML).", "briefDescription": "Validate all user input.", "priority": "must" },
            { "id": "node-rate-limiting", "title": "Rate Limiting", "description": "express-rate-limit. Prevent brute force, DoS. windowMs: 15 * 60 * 1000, max: 100. Per-IP or per-user. Stricter for auth endpoints. 429 Too Many Requests.", "briefDescription": "Prevent abuse and DoS.", "priority": "must" },
            { "id": "node-helmet", "title": "Helmet.js", "description": "app.use(helmet()). Sets security headers: X-XSS-Protection, X-Content-Type-Options, X-Frame-Options, CSP. Sensible defaults. Configure as needed.", "briefDescription": "Security headers middleware.", "priority": "must" },
            { "id": "node-cors", "title": "CORS", "description": "app.use(cors({ origin: 'https://mysite.com' })). Control cross-origin access. Don't use origin: '*' with credentials. Whitelist specific origins.", "briefDescription": "Configure cross-origin access.", "priority": "must" },
            { "id": "node-injection", "title": "SQL/NoSQL Injection Prevention", "description": "Use parameterized queries. db.query('SELECT * FROM users WHERE id = $1', [id]). Mongoose escapes by default. Never concatenate user input into queries.", "briefDescription": "Prevent query injection.", "priority": "must" },
            { "id": "node-xss", "title": "XSS Prevention", "description": "Escape output in templates. Use Content-Security-Policy header. DOMPurify or sanitize-html for user HTML. httpOnly cookies. React escapes by default.", "briefDescription": "Prevent cross-site scripting.", "priority": "must" },
            { "id": "node-csrf", "title": "CSRF Protection", "description": "csurf middleware (deprecated but pattern valid). Token in forms, verified on submit. SameSite=Strict cookies. Double-submit cookie pattern. Less relevant for API-only backends.", "briefDescription": "Prevent cross-site request forgery.", "priority": "imp" },
            { "id": "node-audit", "title": "Dependency Auditing", "description": "npm audit. Scans for known vulnerabilities. npm audit fix for automatic updates. Snyk for continuous monitoring. Update dependencies regularly.", "briefDescription": "Check for vulnerable packages.", "priority": "must" }
          ]
        },
        {
          "id": "node-performance",
          "title": "Performance",
          "description": "Optimize Node.js applications for speed and efficiency. Profiling, monitoring, and caching strategies for production performance.",
          "briefDescription": "Optimize for speed and efficiency.",
          "priority": "imp",
          "children": [
            { "id": "node-profiling", "title": "Profiling (clinic.js)", "description": "clinic doctor -- node app.js. Identifies performance issues. clinic flame for flame graphs. clinic bubbleprof for async. Visualize bottlenecks.", "briefDescription": "Performance analysis tools.", "priority": "imp" },
            { "id": "node-memory-leaks", "title": "Memory Leak Detection", "description": "heapdump for heap snapshots. node --inspect and Chrome DevTools Memory tab. Compare snapshots over time. Look for growing object counts. Common causes: closures, event listeners.", "briefDescription": "Find memory leaks.", "priority": "imp" },
            { "id": "node-cpu-profiling", "title": "CPU Profiling", "description": "node --prof app.js creates V8 log. node --prof-process isolate-*.log. Or Chrome DevTools CPU profiler. Identify slow functions. Optimize hot paths.", "briefDescription": "Find CPU bottlenecks.", "priority": "imp" },
            { "id": "node-event-loop-monitoring", "title": "Event Loop Monitoring", "description": "Monitor event loop lag. Libraries: blocked, event-loop-lag. High lag = blocking operations. Move CPU work to worker threads. Keep event loop free.", "briefDescription": "Detect blocking operations.", "priority": "imp" },
            { "id": "node-caching", "title": "Caching Strategies", "description": "In-memory: node-cache, lru-cache. External: Redis. Cache database queries, API responses, computations. Invalidation strategy crucial. TTL for expiration.", "briefDescription": "Cache for performance.", "priority": "must" },
            { "id": "node-connection-pooling", "title": "Connection Pooling", "description": "Reuse database connections. pg pool, mongoose connection pooling. Configure pool size. Avoid connection per request. Essential for production traffic.", "briefDescription": "Efficient database connections.", "priority": "must" }
          ]
        },
        {
          "id": "node-realtime",
          "title": "Real-time Communication",
          "description": "Build real-time features with WebSockets, Socket.io, or Server-Sent Events. Chat, notifications, live updates.",
          "briefDescription": "Real-time data transmission.",
          "priority": "imp",
          "children": [
            { "id": "node-websockets", "title": "WebSockets", "description": "Full-duplex communication. Lower latency than HTTP polling. ws library: wss.on('connection', ws => ws.on('message', msg => {})). Native browser WebSocket API.", "briefDescription": "Bidirectional real-time connection.", "priority": "imp" },
            {
              "id": "node-socketio",
              "title": "Socket.io",
              "description": "WebSocket library with fallbacks and features. Rooms, namespaces, broadcasting. Easy client-server setup. Most popular real-time library for Node.js.",
              "briefDescription": "Feature-rich WebSocket library.",
              "priority": "must",
              "children": [
                { "id": "socketio-rooms", "title": "Rooms & Namespaces", "description": "socket.join('room1'). io.to('room1').emit('event', data). Namespaces: io.of('/chat'). Segment connections by feature. Targeted broadcasts.", "briefDescription": "Group and segment connections.", "priority": "imp" },
                { "id": "socketio-broadcasting", "title": "Broadcasting", "description": "io.emit() to all. socket.broadcast.emit() to all except sender. io.to('room').emit() to room. Efficient server-to-many communication.", "briefDescription": "Send to multiple clients.", "priority": "must" },
                { "id": "socketio-acknowledgements", "title": "Acknowledgements", "description": "socket.emit('event', data, (response) => {}). Server: (data, callback) => { callback('ack'); }. Confirm message receipt. Request-response over sockets.", "briefDescription": "Confirm message delivery.", "priority": "imp" },
                { "id": "socketio-error", "title": "Error Handling", "description": "socket.on('error', (error) => {}). socket.on('connect_error', (error) => {}). Handle connection failures. Reconnection logic. Graceful degradation.", "briefDescription": "Handle connection errors.", "priority": "imp" }
              ]
            },
            { "id": "node-sse", "title": "Server-Sent Events (SSE)", "description": "One-way server-to-client streaming. res.setHeader('Content-Type', 'text/event-stream'). res.write('data: message\\n\\n'). Native browser EventSource. Simpler than WebSocket for one-way.", "briefDescription": "Server push to browser.", "priority": "imp" }
          ]
        }
      ]
    },
    {
      "id": "expressjs",
      "title": "Express.js",
      "description": "Express is the most popular web framework for Node.js. It provides a robust set of features for building web applications and APIs: routing, middleware, templating, and more. Understanding Express deeply is essential for the backend of any MERN application.",
      "briefDescription": "Minimal web framework for Node.js.",
      "priority": "must",
      "children": [
        {
          "id": "express-basics",
          "title": "Basics",
          "description": "Get started with Express: create an app, handle requests and responses, understand the request/response objects. These fundamentals underpin everything in Express.",
          "briefDescription": "Express fundamentals.",
          "priority": "must",
          "children": [
            { "id": "express-create-app", "title": "Creating an Express App", "description": "const express = require('express'); const app = express(); Basic Express application. app is the core object. Configure with middleware, routes. Single app or multiple app.Router()s.", "briefDescription": "Initialize Express application.", "priority": "must" },
            { "id": "express-listen", "title": "app.listen", "description": "app.listen(3000, () => console.log('Server running')); Starts HTTP server. Returns http.Server. Can pass to socket.io. Optional callback for startup notification.", "briefDescription": "Start the HTTP server.", "priority": "must" },
            { "id": "express-req-res", "title": "Request & Response Objects", "description": "Express extends Node.js req/res with helpful properties and methods. Request has parsed data accessors. Response has chainable output methods. Central to every route handler.", "briefDescription": "Enhanced HTTP objects.", "priority": "must" },
            { "id": "express-req-props", "title": "req Properties", "description": "req.params (URL parameters), req.query (query string), req.body (parsed body, needs middleware), req.headers (HTTP headers), req.cookies (with cookie-parser). Access request data.", "briefDescription": "Request data accessors.", "priority": "must" },
            { "id": "express-res-methods", "title": "res Methods", "description": "res.json({data}) sends JSON. res.send('text') sends response. res.status(404) sets status. res.redirect('/path') redirects. res.render('view', data) renders template. Chainable: res.status(201).json({}).", "briefDescription": "Response output methods.", "priority": "must" }
          ]
        },
        {
          "id": "express-routing",
          "title": "Routing",
          "description": "Routing defines how your application responds to different URLs and HTTP methods. Express provides flexible routing with parameters, query strings, multiple handlers, and modular routers.",
          "briefDescription": "Define URL handlers.",
          "priority": "must",
          "children": [
            { "id": "express-route-methods", "title": "Route Methods", "description": "app.get(), app.post(), app.put(), app.patch(), app.delete(). Match HTTP methods. app.all() for all methods. Route-specific middleware possible.", "briefDescription": "HTTP method handlers.", "priority": "must" },
            { "id": "express-route-params", "title": "Route Parameters", "description": "app.get('/users/:id', (req, res) => { req.params.id }). :param captures value. Multiple: /users/:userId/posts/:postId. Optional: /:id?. Pattern matching possible.", "briefDescription": "Dynamic URL segments.", "priority": "must" },
            { "id": "express-query-params", "title": "Query Parameters", "description": "/search?q=node&page=1. Access: req.query.q, req.query.page. Always strings. Parse numbers manually. Good for filters, pagination, search.", "briefDescription": "URL query string access.", "priority": "must" },
            { "id": "express-multiple-handlers", "title": "Route Handlers", "description": "app.get('/path', handler1, handler2, handler3). Chain handlers. Call next() to proceed. Use for middleware-like behavior on specific routes. Last handler sends response.", "briefDescription": "Multiple callbacks per route.", "priority": "imp" },
            {
              "id": "express-router",
              "title": "express.Router",
              "description": "Create modular, mountable route handlers. Essential for organizing larger applications. Routers can have their own middleware and prefix.",
              "briefDescription": "Modular routing.",
              "priority": "must",
              "children": [
                { "id": "router-modular", "title": "Modular Routes", "description": "const router = express.Router(); router.get('/', handler); module.exports = router; Separate route files. Clean organization by resource or feature.", "briefDescription": "Separate route files.", "priority": "must" },
                { "id": "router-prefix", "title": "Route Prefixing", "description": "app.use('/api/users', userRouter). All routes in userRouter prefixed with /api/users. Clean separation. Routes inside relative to prefix.", "briefDescription": "Mount routers with prefix.", "priority": "must" },
                { "id": "router-middleware", "title": "Router-level Middleware", "description": "router.use(authMiddleware). Applies to all routes in router. Or per-route: router.get('/:id', validate, getUser). Scoped middleware.", "briefDescription": "Middleware for specific routers.", "priority": "imp" }
              ]
            },
            { "id": "express-route-chaining", "title": "Route Chaining (app.route)", "description": "app.route('/book').get(getBooks).post(createBook).put(updateBook). Chain methods for same path. DRY for CRUD endpoints. Cleaner than separate app.get(), app.post().", "briefDescription": "Chain methods for one path.", "priority": "imp" }
          ]
        },
        {
          "id": "express-middleware",
          "title": "Middleware",
          "description": "Middleware functions have access to request, response, and next. They can execute code, modify req/res, end the request-response cycle, or call next(). Middleware is the core pattern of Express.",
          "briefDescription": "Request processing functions.",
          "priority": "must",
          "children": [
            { "id": "middleware-concept", "title": "What is Middleware", "description": "(req, res, next) => { /* do something */ next(); }. Functions that run between request and response. Execute in order added. Core Express pattern for reusable logic.", "briefDescription": "Functions in the request pipeline.", "priority": "must" },
            { "id": "middleware-app-level", "title": "Application-level Middleware", "description": "app.use(middleware). Runs for all requests. app.use('/path', middleware) for specific paths. Order matters — first added runs first.", "briefDescription": "Global middleware.", "priority": "must" },
            { "id": "middleware-router-level", "title": "Router-level Middleware", "description": "router.use(middleware). Scoped to router. Runs before router's routes. Good for auth on specific route groups.", "briefDescription": "Middleware per router.", "priority": "imp" },
            {
              "id": "middleware-error",
              "title": "Error-handling Middleware",
              "description": "Express identifies error handlers by the 4-parameter signature. They catch errors thrown or passed to next(err). Centralized error handling is a best practice.",
              "briefDescription": "Handle errors centrally.",
              "priority": "must",
              "children": [
                { "id": "error-signature", "title": "4-parameter Signature", "description": "(err, req, res, next) => {}. MUST have all 4 parameters. Express recognizes this as error handler. Placed after all routes.", "briefDescription": "Error handler function signature.", "priority": "must" },
                { "id": "error-centralized", "title": "Centralized Error Handler", "description": "app.use((err, req, res, next) => { console.error(err); res.status(err.status || 500).json({ error: err.message }); }). One place for error responses. Logging, formatting, status codes.", "briefDescription": "Single error handling point.", "priority": "must" },
                { "id": "error-custom-classes", "title": "Custom Error Classes", "description": "class AppError extends Error { constructor(message, statusCode) { super(message); this.statusCode = statusCode; } }. throw new AppError('Not found', 404). Typed errors for different cases.", "briefDescription": "Typed error objects.", "priority": "imp" }
              ]
            },
            {
              "id": "middleware-builtin",
              "title": "Built-in Middleware",
              "description": "Express 4.16+ includes essential parsing middleware. No need for body-parser package anymore.",
              "briefDescription": "Express-included middleware.",
              "priority": "must",
              "children": [
                { "id": "middleware-json", "title": "express.json()", "description": "app.use(express.json()). Parses JSON body. Sets req.body. Must be before routes. Options: limit for max size. Essential for APIs.", "briefDescription": "Parse JSON request bodies.", "priority": "must" },
                { "id": "middleware-urlencoded", "title": "express.urlencoded()", "description": "app.use(express.urlencoded({ extended: true })). Parses URL-encoded body (form submissions). extended: true for rich objects with qs.", "briefDescription": "Parse form submissions.", "priority": "must" },
                { "id": "middleware-static", "title": "express.static()", "description": "app.use(express.static('public')). Serve static files from directory. /images/logo.png serves public/images/logo.png. Options: maxAge for caching.", "briefDescription": "Serve static files.", "priority": "must" }
              ]
            },
            {
              "id": "middleware-thirdparty",
              "title": "Third-party Middleware",
              "description": "Rich ecosystem of middleware for common needs. Install from npm, configure and use with app.use().",
              "briefDescription": "Community middleware packages.",
              "priority": "must",
              "children": [
                { "id": "middleware-cors", "title": "cors", "description": "app.use(cors({ origin: 'https://frontend.com' })). Enable CORS. Configure allowed origins, methods, headers. Essential for API consumed by different domain.", "briefDescription": "Cross-origin resource sharing.", "priority": "must" },
                { "id": "middleware-helmet", "title": "helmet", "description": "app.use(helmet()). Sets security headers. CSP, X-Frame-Options, etc. Sensible defaults. Configure individual headers as needed.", "briefDescription": "Security headers.", "priority": "must" },
                { "id": "middleware-morgan", "title": "morgan", "description": "app.use(morgan('dev')). HTTP request logging. Formats: 'combined', 'dev', 'tiny'. Custom tokens. Use in development.", "briefDescription": "Request logging.", "priority": "imp" },
                { "id": "middleware-compression", "title": "compression", "description": "app.use(compression()). Gzip/deflate responses. Reduces bandwidth. Threshold for minimum size. Use if not handled by reverse proxy.", "briefDescription": "Response compression.", "priority": "imp" },
                { "id": "middleware-cookie-parser", "title": "cookie-parser", "description": "app.use(cookieParser(secret)). Parses cookies into req.cookies. Signed cookies with secret. Essential for cookie-based sessions.", "briefDescription": "Parse request cookies.", "priority": "imp" },
                { "id": "middleware-rate-limit", "title": "express-rate-limit", "description": "const limiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 100 }). Prevent abuse. Per-IP limiting. Returns 429 Too Many Requests.", "briefDescription": "Request rate limiting.", "priority": "must" },
                { "id": "middleware-validator", "title": "express-validator", "description": "Validation and sanitization. body('email').isEmail().normalizeEmail(). Check in handler: validationResult(req). Input validation essential.", "briefDescription": "Request validation.", "priority": "must" }
              ]
            },
            {
              "id": "middleware-custom",
              "title": "Custom Middleware",
              "description": "Create your own middleware for authentication, logging, validation, and any reusable logic. Middleware pattern is simple but powerful.",
              "briefDescription": "Build your own middleware.",
              "priority": "must",
              "children": [
                { "id": "middleware-auth", "title": "Authentication Middleware", "description": "const auth = (req, res, next) => { const token = req.headers.authorization; if (!token) return res.status(401).json({error}); verify token; req.user = decoded; next(); };", "briefDescription": "Verify authentication.", "priority": "must" },
                { "id": "middleware-logging", "title": "Logging Middleware", "description": "const logger = (req, res, next) => { console.log(`${req.method} ${req.url}`); next(); };. Log requests. Add timestamp, IP, response time. Use instead of or with morgan.", "briefDescription": "Custom request logging.", "priority": "imp" },
                { "id": "middleware-request-validation", "title": "Request Validation Middleware", "description": "const validate = (schema) => (req, res, next) => { const { error } = schema.validate(req.body); if (error) return res.status(400).json({ error }); next(); };", "briefDescription": "Validate request data.", "priority": "imp" }
              ]
            },
            { "id": "middleware-order", "title": "Middleware Execution Order", "description": "Middleware runs in order added with app.use(). Error handlers should be last. Static files often first. Body parsers before routes. Order affects behavior.", "briefDescription": "Order matters.", "priority": "must" },
            { "id": "middleware-next", "title": "next() Function", "description": "next() passes to next middleware. next(err) passes to error handler. next('route') skips remaining handlers for this route. Must call next() or send response.", "briefDescription": "Control flow function.", "priority": "must" }
          ]
        },
        {
          "id": "express-validation",
          "title": "Request Validation",
          "description": "Validating user input is essential for security and data integrity. Use validation libraries to check and sanitize incoming data before processing.",
          "briefDescription": "Validate incoming data.",
          "priority": "must",
          "children": [
            {
              "id": "validation-express-validator",
              "title": "express-validator",
              "description": "The most popular validation library for Express. Chain validators and sanitizers. Check results in handlers or middleware.",
              "briefDescription": "Validation library for Express.",
              "priority": "must",
              "children": [
                { "id": "validator-locations", "title": "body(), param(), query()", "description": "body('email').isEmail(). param('id').isInt(). query('page').optional().isInt(). Validate different parts of request. Chain validators.", "briefDescription": "Validate request parts.", "priority": "must" },
                { "id": "validator-result", "title": "validationResult", "description": "const errors = validationResult(req); if (!errors.isEmpty()) return res.status(400).json({ errors: errors.array() });. Check validation in handler. Return errors to client.", "briefDescription": "Check validation results.", "priority": "must" },
                { "id": "validator-custom", "title": "Custom Validators", "description": ".custom(value => { if (!isValid(value)) throw new Error('Invalid'); return true; }). Or .custom(async (value) => { if (await exists(value)) throw new Error('Exists'); }).", "briefDescription": "Create custom validation logic.", "priority": "imp" },
                { "id": "validator-sanitization", "title": "Sanitization", "description": "body('email').normalizeEmail(). trim(), escape(), toInt(), toBoolean(). Clean data before use. Prevent XSS, normalize formats.", "briefDescription": "Clean and normalize input.", "priority": "must" }
              ]
            },
            { "id": "validation-joi", "title": "Joi", "description": "Schema-based validation. const schema = Joi.object({ email: Joi.string().email().required() }). schema.validate(data). Descriptive errors. Popular alternative, works anywhere.", "briefDescription": "Object schema validation.", "priority": "imp" },
            { "id": "validation-zod", "title": "Zod", "description": "TypeScript-first schema validation. const schema = z.object({ email: z.string().email() }). schema.parse(data) throws. schema.safeParse(data) returns result. Type inference included.", "briefDescription": "TypeScript schema validation.", "priority": "imp" },
            { "id": "validation-pattern", "title": "Schema Validation Pattern", "description": "Define schema per route. Validate in middleware. Reject early with 400 status. Same schema for TypeScript types. Validation as documentation.", "briefDescription": "Consistent validation approach.", "priority": "imp" }
          ]
        },
        {
          "id": "express-files",
          "title": "File Handling",
          "description": "Handle file uploads and downloads in Express. Multer for uploads, streaming for large files, proper security measures.",
          "briefDescription": "Upload and download files.",
          "priority": "imp",
          "children": [
            {
              "id": "express-multer",
              "title": "Multer",
              "description": "Middleware for handling multipart/form-data (file uploads). Configure storage, filtering, limits.",
              "briefDescription": "File upload middleware.",
              "priority": "must",
              "children": [
                { "id": "multer-single", "title": "Single File Upload", "description": "const upload = multer({ dest: 'uploads/' }); app.post('/upload', upload.single('file'), handler). req.file contains file info. 'file' is form field name.", "briefDescription": "Upload one file.", "priority": "must" },
                { "id": "multer-multiple", "title": "Multiple File Upload", "description": "upload.array('files', 5) for multiple. upload.fields([{ name: 'avatar' }, { name: 'gallery', maxCount: 8 }]) for different fields. req.files contains array.", "briefDescription": "Upload multiple files.", "priority": "imp" },
                { "id": "multer-filtering", "title": "File Filtering", "description": "fileFilter: (req, file, cb) => { if (file.mimetype.startsWith('image/')) cb(null, true); else cb(new Error('Not an image'), false); }. Validate file types.", "briefDescription": "Accept/reject files.", "priority": "must" },
                { "id": "multer-storage", "title": "Storage (disk, memory)", "description": "multer.diskStorage({ destination, filename }). multer.memoryStorage() for req.file.buffer (small files, streaming to cloud). Custom storage engines available.", "briefDescription": "Where to store uploads.", "priority": "imp" }
              ]
            },
            { "id": "express-streaming-upload", "title": "Streaming Uploads", "description": "req.pipe(writeStream) for large files. Stream to S3, GCS without disk. Busboy for lower-level control. Memory-efficient for large uploads.", "briefDescription": "Handle large uploads efficiently.", "priority": "look" },
            { "id": "express-download", "title": "File Download (res.download)", "description": "res.download(filePath, 'filename.pdf', (err) => {}). Sets Content-Disposition. Triggers browser download. Or res.sendFile() for inline viewing.", "briefDescription": "Send files to client.", "priority": "imp" }
          ]
        },
        {
          "id": "express-templates",
          "title": "Template Engines",
          "description": "Server-side rendering with template engines. Less common with React but useful for emails, simple pages, or hybrid apps.",
          "briefDescription": "Server-side HTML rendering.",
          "priority": "look",
          "children": [
            { "id": "template-ejs", "title": "EJS", "description": "app.set('view engine', 'ejs'). res.render('page', { title: 'Home' }). <%= title %> outputs escaped. <%- html %> unescaped. Familiar HTML-like syntax.", "briefDescription": "Embedded JavaScript templates.", "priority": "look" },
            { "id": "template-pug", "title": "Pug", "description": "Formerly Jade. Whitespace-based syntax. p Hello World. Includes, mixins, inheritance. Cleaner but learning curve. Less HTML-like.", "briefDescription": "Indentation-based templates.", "priority": "look" },
            { "id": "template-handlebars", "title": "Handlebars", "description": "{{variable}}, {{#if condition}}{{/if}}. Logic-less templates. Helpers for complex logic. Good separation of concerns.", "briefDescription": "Mustache-compatible templates.", "priority": "look" },
            { "id": "express-ssr", "title": "Server-Side Rendering with Express", "description": "Traditional SSR before React. Still useful for: SEO-critical pages, emails (Handlebars), simple admin dashboards. Hydrate with JS if needed.", "briefDescription": "Traditional server rendering.", "priority": "look" }
          ]
        },
        {
          "id": "express-session",
          "title": "Session & Cookies",
          "description": "Manage user sessions with cookies. Sessions store state across requests. Configure security options to protect user data.",
          "briefDescription": "Stateful user sessions.",
          "priority": "imp",
          "children": [
            {
              "id": "express-session-middleware",
              "title": "express-session",
              "description": "Session middleware for Express. Stores session data server-side, sends session ID cookie to client.",
              "briefDescription": "Session management middleware.",
              "priority": "imp",
              "children": [
                { "id": "session-stores", "title": "Session Store", "description": "Default: memory (dev only, leaks). connect-redis for Redis. connect-mongo for MongoDB. Production must use external store for persistence and scaling.", "briefDescription": "Where sessions are stored.", "priority": "must" },
                { "id": "session-config", "title": "Session Configuration", "description": "secret (required, sign cookie), resave (false usually), saveUninitialized (false for GDPR), cookie options. Secure defaults for production.", "briefDescription": "Configure session behavior.", "priority": "imp" }
              ]
            },
            {
              "id": "express-cookie-config",
              "title": "Cookie Configuration",
              "description": "Cookies need proper security settings. httpOnly, secure, sameSite, maxAge are essential for security.",
              "briefDescription": "Secure cookie settings.",
              "priority": "must",
              "children": [
                { "id": "cookie-security", "title": "httpOnly, secure, sameSite, maxAge", "description": "httpOnly: true (no JS access). secure: true (HTTPS only). sameSite: 'strict' or 'lax' (CSRF). maxAge in ms. Domain for subdomains.", "briefDescription": "Cookie security options.", "priority": "must" }
              ]
            },
            { "id": "express-signed-cookies", "title": "Signed Cookies", "description": "res.cookie('name', 'value', { signed: true }). Requires cookieParser(secret). Detects tampering. Access: req.signedCookies.name. Null if tampered.", "briefDescription": "Tamper-resistant cookies.", "priority": "imp" }
          ]
        },
        {
          "id": "express-architecture",
          "title": "Architecture Patterns",
          "description": "Structure Express applications for maintainability and testability. Apply established patterns for organizing code as applications grow.",
          "briefDescription": "Organize Express applications.",
          "priority": "must",
          "children": [
            { "id": "pattern-mvc", "title": "MVC Pattern", "description": "Model: data/database logic. View: response formatting (JSON, templates). Controller: request handling, orchestration. Separate concerns. Classic web pattern.", "briefDescription": "Model-View-Controller separation.", "priority": "must" },
            { "id": "pattern-service", "title": "Service Layer Pattern", "description": "Services contain business logic. Controllers call services. Services reusable across controllers. Services call repositories. Testable isolation.", "briefDescription": "Business logic layer.", "priority": "must" },
            { "id": "pattern-repository", "title": "Repository Pattern", "description": "Abstract database access. UserRepository.findById(id). Controller → Service → Repository → Database. Easy to swap database. Testable with mocks.", "briefDescription": "Abstract data access.", "priority": "imp" },
            { "id": "pattern-controller", "title": "Controller Pattern", "description": "One controller per resource. UserController: index, show, create, update, delete. Thin controllers — delegate to services. Single responsibility.", "briefDescription": "Request handlers per resource.", "priority": "must" },
            { "id": "pattern-flow", "title": "Route → Controller → Service → Model", "description": "Route defines HTTP interface. Controller parses input, calls service. Service contains logic, uses models. Model is data structure. Clear flow.", "briefDescription": "Standard request flow.", "priority": "must" },
            { "id": "pattern-di", "title": "Dependency Injection", "description": "Pass dependencies to constructors/functions. new UserService(userRepository). Enables testing with mocks. Libraries: tsyringe, inversify. Or manual DI.", "briefDescription": "Inject dependencies.", "priority": "imp" }
          ]
        },
        {
          "id": "express-error-patterns",
          "title": "Error Handling Patterns",
          "description": "Consistent error handling improves debugging and user experience. Handle async errors properly, use global handlers, and return consistent error responses.",
          "briefDescription": "Handle errors consistently.",
          "priority": "must",
          "children": [
            { "id": "error-try-catch", "title": "try/catch in Async Handlers", "description": "app.get('/', async (req, res, next) => { try { const data = await fetchData(); res.json(data); } catch (err) { next(err); } }). Must catch async errors and pass to next().", "briefDescription": "Catch async errors.", "priority": "must" },
            { "id": "error-async-handler", "title": "express-async-handler", "description": "const asyncHandler = require('express-async-handler'); app.get('/', asyncHandler(async (req, res) => { /* throws auto-caught */ })). Wrap handlers to auto-catch and forward errors.", "briefDescription": "Automatic async error catching.", "priority": "must" },
            { "id": "error-global-handler", "title": "Global Error Handler", "description": "app.use((err, req, res, next) => { const status = err.status || 500; res.status(status).json({ error: { message: err.message, ...(dev && { stack: err.stack }) } }); });", "briefDescription": "Centralized error responses.", "priority": "must" },
            { "id": "error-http-responses", "title": "HTTP Error Responses", "description": "400 Bad Request: validation errors. 401 Unauthorized: missing auth. 403 Forbidden: no permission. 404 Not Found: resource missing. 500 Internal Server Error: unexpected.", "briefDescription": "Proper status codes.", "priority": "must" },
            { "id": "error-logging", "title": "Error Logging", "description": "console.error in development. Winston, Pino for production. Log stack traces. Send to error tracking (Sentry, LogRocket). Don't expose stacks to users.", "briefDescription": "Log errors for debugging.", "priority": "imp" }
          ]
        }
      ]
    }
    ,
    {
      "id": "mongodb-mongoose",
      "title": "MongoDB & Mongoose",
      "description": "MongoDB is the NoSQL database used in the MERN stack, storing data as flexible JSON-like documents. Mongoose is the ODM (Object Data Modeling) library that adds schema, validation, middleware, and query helpers on top of MongoDB. Interviewers expect you to understand data modeling, querying, indexing, aggregation, scaling, and how Mongoose enforces structure.",
      "briefDescription": "Document database fundamentals and Mongoose ODM mastery.",
      "priority": "must",
      "children": [
        {
          "id": "mongodb-data-model",
          "title": "Data Model: Documents & Collections",
          "description": "MongoDB stores data as BSON documents inside collections. Documents can be nested, arrays are first-class, and schemas are flexible. Understanding document shape and how it maps to real-world entities is crucial for clean data design and efficient queries.",
          "briefDescription": "BSON documents, collections, and flexible schemas.",
          "priority": "must",
          "children": [
            { "id": "bson-basics", "title": "BSON vs JSON", "description": "BSON is a binary-encoded serialization of JSON-like documents with extra types (Date, ObjectId, Decimal128). It's faster to parse and stores type information. Understanding BSON types helps avoid subtle bugs, especially with dates and IDs.", "briefDescription": "Binary JSON with extra types like ObjectId and Date.", "priority": "imp" },
            { "id": "objectid", "title": "ObjectId", "description": "MongoDB's default primary key type. 12-byte value containing timestamp, machine, process, and counter. Enables sorting by creation time and uniqueness across distributed systems. Always treat as a string in APIs, but keep as ObjectId in DB for indexing and joins.", "briefDescription": "Default unique document identifier with timestamp component.", "priority": "must" },
            { "id": "embedded-docs", "title": "Embedded Documents", "description": "Embed related data directly inside a document (e.g., comments inside a post). Great for one-to-few relationships and read-heavy access patterns. Reduces joins but increases document size and write complexity.", "briefDescription": "Store related data inside a parent document.", "priority": "imp" },
            { "id": "referenced-docs", "title": "Referenced Documents", "description": "Store related data in separate collections and reference by ObjectId. Ideal for one-to-many or many-to-many relationships and frequently changing data. Requires manual joins via $lookup or Mongoose populate.", "briefDescription": "Use ObjectId references for related collections.", "priority": "imp" }
          ]
        },
        {
          "id": "mongodb-crud",
          "title": "CRUD Operations",
          "description": "Master create, read, update, and delete operations using MongoDB query operators. Interviews often test how to structure queries, use projection, and apply filters efficiently.",
          "briefDescription": "Insert, find, update, delete and query operators.",
          "priority": "must",
          "children": [
            { "id": "insert-ops", "title": "Insert Operations", "description": "insertOne, insertMany. Bulk inserts are faster for large datasets. Ordered vs unordered inserts control whether the operation stops on error. Understand how MongoDB assigns _id if not provided.", "briefDescription": "Insert single or many documents efficiently.", "priority": "must" },
            { "id": "find-ops", "title": "Find & Projection", "description": "find, findOne with filters. Projection controls returned fields: { name: 1, email: 1 }. Use sort, limit, skip for pagination. Efficient querying depends on proper indexes.", "briefDescription": "Filter and project documents with find queries.", "priority": "must" },
            { "id": "update-ops", "title": "Update Operators", "description": "updateOne, updateMany with operators like $set, $unset, $inc, $push, $pull. Avoid full document replacement unless needed. Use upsert to insert if not found.", "briefDescription": "Modify fields with update operators.", "priority": "must" },
            { "id": "delete-ops", "title": "Delete Operations", "description": "deleteOne, deleteMany. Use with caution; prefer soft deletes with a deletedAt field. Understand write concerns for durability.", "briefDescription": "Remove documents or use soft deletes.", "priority": "imp" }
          ]
        },
        {
          "id": "mongodb-indexing",
          "title": "Indexes",
          "description": "Indexes make queries fast but add write overhead. Knowing when and how to index is a core interview topic. You should understand index types, compound indexes, and index selection by the query planner.",
          "briefDescription": "Speed up queries with proper indexing.",
          "priority": "must",
          "children": [
            { "id": "single-compound", "title": "Single vs Compound Index", "description": "Single-field index accelerates queries on one field. Compound index supports multiple fields and respects prefix order (left-most fields). Choose field order based on query patterns and sort requirements.", "briefDescription": "Index one field or multiple fields in order.", "priority": "must" },
            { "id": "text-index", "title": "Text Index", "description": "Enable full-text search using $text and $search. Supports language-specific stemming and stop words. Only one text index per collection. Use for simple search, not for advanced ranking.", "briefDescription": "Full-text search with $text queries.", "priority": "imp" },
            { "id": "ttl-index", "title": "TTL Index", "description": "Automatically expire documents after a set time (e.g., sessions, logs). Create index with expireAfterSeconds. Uses a background thread with minute-level precision.", "briefDescription": "Auto-delete data after expiration time.", "priority": "imp" },
            { "id": "index-explain", "title": "Explain Plans", "description": "Use explain() to see if queries use indexes, scan count, and execution stats. Look for COLLSCAN vs IXSCAN. Essential for diagnosing slow queries.", "briefDescription": "Inspect query planner behavior and performance.", "priority": "must" }
          ]
        },
        {
          "id": "mongodb-aggregation",
          "title": "Aggregation Pipeline",
          "description": "Aggregation transforms and analyzes data in stages. Pipelines are used for analytics, reports, and complex transformations. Knowing key stages and how to optimize them is interview-critical.",
          "briefDescription": "Stage-based data processing and analytics.",
          "priority": "must",
          "children": [
            { "id": "agg-match-group", "title": "$match & $group", "description": "$match filters documents early (like WHERE). $group aggregates by keys (like SQL GROUP BY). Always place $match early for performance. Use $sum, $avg, $count in $group.", "briefDescription": "Filter early and aggregate by key.", "priority": "must" },
            { "id": "agg-project", "title": "$project", "description": "Reshape documents: include/exclude fields, compute new fields. Use for clean outputs and smaller payloads. $project after $group to format aggregated results.", "briefDescription": "Select and compute output fields.", "priority": "imp" },
            { "id": "agg-lookup", "title": "$lookup (Joins)", "description": "Perform left outer joins across collections. Useful for normalized schemas but can be expensive at scale. Understand localField/foreignField vs pipeline-based $lookup.", "briefDescription": "Join documents across collections.", "priority": "imp" },
            { "id": "agg-unwind", "title": "$unwind", "description": "Deconstruct array fields into multiple documents. Useful before $group to aggregate array elements. Can preserve empty arrays with preserveNullAndEmptyArrays.", "briefDescription": "Flatten arrays into separate documents.", "priority": "imp" }
          ]
        },
        {
          "id": "mongodb-schema-design",
          "title": "Schema Design",
          "description": "MongoDB is schema-flexible, but design still matters. Choose embedding vs referencing, avoid unbounded document growth, and design with query patterns in mind.",
          "briefDescription": "Design collections based on access patterns.",
          "priority": "must",
          "children": [
            { "id": "embed-vs-reference", "title": "Embed vs Reference", "description": "Embed for one-to-few and read-heavy access. Reference for many-to-many or frequently changing data. Consider update frequency, read patterns, and document size limits (16MB).", "briefDescription": "Choose data modeling strategy per relationship.", "priority": "must" },
            { "id": "avoid-unbounded", "title": "Avoid Unbounded Arrays", "description": "Documents have a 16MB limit. Arrays that grow without bound (logs, events) can break limits and degrade performance. Use separate collections for unbounded data and reference back to parent.", "briefDescription": "Prevent documents from growing indefinitely.", "priority": "must" },
            { "id": "read-write-patterns", "title": "Model for Query Patterns", "description": "Design schema around your most common queries. Favor read efficiency: denormalize when needed. Measure and optimize with explain plans and indexes.", "briefDescription": "Schema should match real query patterns.", "priority": "imp" }
          ]
        },
        {
          "id": "mongodb-transactions",
          "title": "Transactions & Consistency",
          "description": "MongoDB supports multi-document ACID transactions. Use them for operations that must be all-or-nothing, but be aware of performance overhead. Most workloads still benefit from single-document atomicity.",
          "briefDescription": "Multi-document ACID transactions and tradeoffs.",
          "priority": "imp",
          "children": [
            { "id": "single-doc-atomic", "title": "Single-Document Atomicity", "description": "All writes to a single document are atomic. Structure related data in one document when you need atomic updates without transactions. This is a major advantage of document databases.", "briefDescription": "Atomic updates within one document.", "priority": "must" },
            { "id": "multi-doc-tx", "title": "Multi-Document Transactions", "description": "Use session.startTransaction(), commitTransaction(), abortTransaction(). Requires replica set (even single-node). Adds latency and locks; use only when needed.", "briefDescription": "ACID transactions across multiple documents.", "priority": "imp" }
          ]
        },
        {
          "id": "mongodb-scaling",
          "title": "Replication & Sharding",
          "description": "MongoDB scales via replica sets (high availability) and sharding (horizontal scale). Understanding when to use each and how they affect read/write behavior is a common interview topic.",
          "briefDescription": "High availability and horizontal scaling.",
          "priority": "imp",
          "children": [
            { "id": "replica-sets", "title": "Replica Sets", "description": "Primary handles writes, secondaries replicate. Automatic failover. Read preferences control where reads go (primary, secondary, nearest). Ensures availability and durability.", "briefDescription": "High availability with primary-secondary replication.", "priority": "imp" },
            { "id": "sharding", "title": "Sharding", "description": "Partition data across shards using a shard key. Choose shard key carefully to avoid hot spots. Involves mongos router and config servers. Enables horizontal scaling for large datasets.", "briefDescription": "Horizontal scaling via partitioning.", "priority": "imp" }
          ]
        },
        {
          "id": "mongoose-odm",
          "title": "Mongoose ODM",
          "description": "Mongoose adds structure and convenience on top of MongoDB. Learn schemas, models, validation, middleware, and how to optimize query performance.",
          "briefDescription": "Schemas, models, validation, and middleware in Mongoose.",
          "priority": "must",
          "children": [
            { "id": "mongoose-schemas", "title": "Schemas", "description": "Define document structure: new Schema({ name: { type: String, required: true } }). Supports default values, enums, nested schemas, arrays. Enables validation and casting.", "briefDescription": "Define structure and constraints for documents.", "priority": "must" },
            { "id": "mongoose-models", "title": "Models", "description": "Models compile schemas into classes: const User = mongoose.model('User', userSchema). Use for CRUD operations. Models map to collections (lowercase plural by default).", "briefDescription": "Compiled schema classes for querying.", "priority": "must" },
            { "id": "mongoose-queries", "title": "Queries & Query Helpers", "description": "Chainable queries: User.find({}).select('name').sort('-createdAt').lean(). Query helpers add reusable filters. Use exec() to get a real Promise.", "briefDescription": "Chainable query API with helpers.", "priority": "must" },
            { "id": "mongoose-validation", "title": "Validation", "description": "Built-in validators (required, min, max, match) and custom validators. Validation runs on save/create by default. Use validateBeforeSave or validateSync. Always validate input server-side too.", "briefDescription": "Enforce data correctness with validators.", "priority": "must" },
            { "id": "mongoose-middleware", "title": "Middleware (Hooks)", "description": "pre('save'), post('save'), pre('find'), etc. Useful for hashing passwords, auditing, or automatic timestamps. Be careful with async hooks to avoid double-calls.", "briefDescription": "Hook into lifecycle events.", "priority": "imp" },
            { "id": "mongoose-populate", "title": "populate()", "description": "Populate replaces referenced ObjectId with full document: User.find().populate('posts'). Similar to joins. Be mindful of N+1 queries and performance. Use select in populate to limit fields.", "briefDescription": "Join-like behavior for referenced documents.", "priority": "must" },
            { "id": "mongoose-lean", "title": "lean()", "description": "Return plain JavaScript objects instead of Mongoose documents. Faster and less memory. Use for read-heavy endpoints when you don't need document methods or virtuals.", "briefDescription": "Faster reads with plain objects.", "priority": "imp" },
            { "id": "mongoose-connection", "title": "Connection Management", "description": "Use mongoose.connect with pooled connections. Handle connection events: connected, error, disconnected. Reuse connection for serverless by caching in global scope.", "briefDescription": "Manage connections for stability and performance.", "priority": "imp" }
          ]
        }
      ]
    }
    ,
    {
      "id": "redis",
      "title": "Redis",
      "description": "Redis is an in-memory data store used for caching, sessions, real-time features, queues, and distributed coordination in MERN systems. Interviewers expect you to know data types, persistence modes, cache patterns, client usage, and scaling with clusters and Sentinel.",
      "briefDescription": "In-memory data store for caching, queues, and real-time features.",
      "priority": "must",
      "children": [
        {
          "id": "redis-fundamentals",
          "title": "Redis Fundamentals",
          "description": "Understand Redis as an in-memory, single-threaded, data-structure server. Learn its key-value model, persistence options, CLI basics, and server configuration essentials.",
          "briefDescription": "Core Redis concepts and persistence.",
          "priority": "must",
          "children": [
            { "id": "redis-in-memory", "title": "In-Memory Data Store", "description": "Data lives in RAM for extremely fast reads/writes. Optional persistence protects against data loss. Memory limits drive eviction policies; design keys accordingly.", "briefDescription": "RAM-based data store with optional persistence.", "priority": "must" },
            { "id": "redis-key-value", "title": "Key-Value Model", "description": "Everything is accessed by key. Keys map to rich data types (strings, hashes, lists, sets, zsets, streams). Naming conventions matter for clarity and tooling.", "briefDescription": "Keys map to data structures.", "priority": "must" },
            {
              "id": "redis-persistence",
              "title": "Persistence",
              "description": "Redis offers snapshot and log-based persistence to recover data after restarts. Choose the right durability/performance trade-off for your workload.",
              "briefDescription": "Durability options for Redis data.",
              "priority": "imp",
              "children": [
                { "id": "redis-rdb", "title": "RDB Snapshots", "description": "Point-in-time snapshots written to disk at intervals. Fast restart, smaller files, but potential data loss between snapshots. Good for backups.", "briefDescription": "Periodic disk snapshots.", "priority": "imp" },
                { "id": "redis-aof", "title": "AOF (Append Only File)", "description": "Logs each write operation. More durable with configurable fsync policies (always/everysec/no). Larger files but less data loss.", "briefDescription": "Append-only write log.", "priority": "imp" },
                { "id": "redis-hybrid", "title": "Hybrid Persistence", "description": "Combines RDB preamble with AOF tail for faster restarts and better durability. Balances snapshot size and log speed.", "briefDescription": "RDB + AOF combined mode.", "priority": "look" }
              ]
            },
            { "id": "redis-cli", "title": "Redis CLI", "description": "redis-cli is the command-line interface for running commands, inspecting keys, and debugging. Common tasks: ping, info, monitor, and scanning keys safely.", "briefDescription": "Command-line interface usage.", "priority": "must" },
            { "id": "redis-config", "title": "Redis Server Configuration", "description": "redis.conf controls memory limits, eviction policies, persistence, networking, and security. Know common settings: maxmemory, maxmemory-policy, requirepass, bind, protected-mode.", "briefDescription": "Key server configuration options.", "priority": "imp" }
          ]
        },
        {
          "id": "redis-data-types",
          "title": "Data Types",
          "description": "Redis provides multiple built-in data structures. Choose the right type for the problem to optimize performance and simplify operations.",
          "briefDescription": "Strings, lists, sets, zsets, hashes, streams, and more.",
          "priority": "must",
          "children": [
            {
              "id": "redis-strings",
              "title": "Strings",
              "description": "Simple key-value values used for counters, tokens, flags, and cached JSON. String operations are O(1) and extremely fast.",
              "briefDescription": "Basic key-value string operations.",
              "priority": "must",
              "children": [
                { "id": "redis-string-basic", "title": "SET, GET, INCR, DECR, APPEND", "description": "Core string commands for storing and mutating values. INCR/DECR are atomic for counters, avoiding race conditions.", "briefDescription": "Core string commands.", "priority": "must" },
                { "id": "redis-string-advanced", "title": "SETEX, SETNX, MSET, MGET", "description": "SETEX sets value with TTL, SETNX sets only if absent (locks). MSET/MGET handle multiple keys in one round trip.", "briefDescription": "TTL, conditional, and multi-key string ops.", "priority": "imp" }
              ]
            },
            {
              "id": "redis-lists",
              "title": "Lists",
              "description": "Ordered collections ideal for queues, recent activity, and pipelines. Support push/pop from both ends.",
              "briefDescription": "Ordered list operations.",
              "priority": "must",
              "children": [
                { "id": "redis-list-push-pop", "title": "LPUSH, RPUSH, LPOP, RPOP", "description": "Push and pop from left/right. Build queues and stacks. O(1) operations for ends.", "briefDescription": "Push/pop list endpoints.", "priority": "must" },
                { "id": "redis-list-range", "title": "LRANGE, LLEN, LINDEX", "description": "LRANGE reads slices, LLEN returns size, LINDEX reads by index. Useful for feeds and pagination of recent items.", "briefDescription": "Read list ranges and length.", "priority": "imp" },
                { "id": "redis-list-blocking", "title": "Blocking Operations (BLPOP, BRPOP)", "description": "Blocking pop waits for data. Used in worker queues to avoid busy polling. Supports timeouts.", "briefDescription": "Blocking queue consumption.", "priority": "imp" }
              ]
            },
            {
              "id": "redis-sets",
              "title": "Sets",
              "description": "Unordered unique collections. Great for tags, membership checks, and de-duplication.",
              "briefDescription": "Unique unordered collections.",
              "priority": "must",
              "children": [
                { "id": "redis-set-basic", "title": "SADD, SREM, SMEMBERS, SISMEMBER", "description": "Add/remove members, list members, and test membership. O(1) membership checks.", "briefDescription": "Basic set operations.", "priority": "must" },
                { "id": "redis-set-ops", "title": "SUNION, SINTER, SDIFF", "description": "Set union, intersection, and difference. Useful for recommendations, common followers, or feature flags.", "briefDescription": "Set algebra operations.", "priority": "imp" }
              ]
            },
            {
              "id": "redis-zsets",
              "title": "Sorted Sets (ZSets)",
              "description": "Sets with scores enabling ranking. Perfect for leaderboards, rate limits, and time-ordered data.",
              "briefDescription": "Ranked collections with scores.",
              "priority": "must",
              "children": [
                { "id": "redis-zset-basic", "title": "ZADD, ZREM, ZRANGE, ZREVRANGE", "description": "Insert/remove members and get ranges by score order. ZRANGE returns ascending; ZREVRANGE descending.", "briefDescription": "Basic sorted set ops.", "priority": "must" },
                { "id": "redis-zset-scores", "title": "ZSCORE, ZRANK, ZRANGEBYSCORE", "description": "Fetch scores, ranks, and members in score ranges. Enables pagination and top-N queries.", "briefDescription": "Score and rank queries.", "priority": "imp" },
                { "id": "redis-zset-leaderboards", "title": "Leaderboards", "description": "Use ZINCRBY to update scores, ZREVRANGE for top players, and ZRANK for a user's position. Common interview use case.", "briefDescription": "Leaderboard patterns with zsets.", "priority": "must" }
              ]
            },
            {
              "id": "redis-hashes",
              "title": "Hashes",
              "description": "Key-value maps inside a single key. Ideal for storing objects with fields like user:1 {name, email, score}.",
              "briefDescription": "Field-value maps per key.",
              "priority": "must",
              "children": [
                { "id": "redis-hash-basic", "title": "HSET, HGET, HGETALL, HDEL", "description": "Set/get/delete fields in a hash. HGETALL retrieves entire object; HGET for specific fields.", "briefDescription": "Basic hash commands.", "priority": "must" },
                { "id": "redis-hash-incr", "title": "HINCRBY", "description": "Atomic increment for numeric fields within a hash. Useful for counters per object.", "briefDescription": "Increment hash fields atomically.", "priority": "imp" },
                { "id": "redis-hash-objects", "title": "Object Storage Pattern", "description": "Store small objects as hashes to avoid serialization overhead. Use HSET for fields and TTL for expiration.", "briefDescription": "Store objects efficiently with hashes.", "priority": "imp" }
              ]
            },
            {
              "id": "redis-streams",
              "title": "Streams",
              "description": "Append-only log data structure. Great for event sourcing, messaging, and queueing with consumer groups.",
              "briefDescription": "Event log data type.",
              "priority": "imp",
              "children": [
                { "id": "redis-stream-basic", "title": "XADD, XREAD, XRANGE", "description": "Append entries, read from stream, and scan ranges. Use IDs for ordering and time-based queries.", "briefDescription": "Core stream commands.", "priority": "imp" },
                { "id": "redis-stream-groups", "title": "Consumer Groups", "description": "Groups enable scalable processing with multiple consumers. Each message is delivered to one consumer, enabling work distribution.", "briefDescription": "Scale stream processing.", "priority": "imp" },
                { "id": "redis-stream-acks", "title": "Acknowledgements", "description": "XACK marks messages as processed. Pending entries can be claimed by other consumers for reliability.", "briefDescription": "Reliable processing with ack tracking.", "priority": "imp" }
              ]
            },
            { "id": "redis-bitmaps", "title": "Bitmaps", "description": "Use BITOP and GETBIT/SETBIT for compact boolean flags (e.g., daily active users). Efficient for large sets of binary data.", "briefDescription": "Compact boolean flags with bits.", "priority": "look" },
            { "id": "redis-hyperloglog", "title": "HyperLogLog", "description": "Approximate cardinality counting with low memory usage. Use PFADD and PFCOUNT for unique visitor estimation.", "briefDescription": "Approximate unique counts.", "priority": "look" },
            { "id": "redis-geospatial", "title": "Geospatial", "description": "Store geo points with GEOADD and query with GEORADIUS/GEODIST. Useful for location-based search and proximity queries.", "briefDescription": "Location-based indexing and queries.", "priority": "look" }
          ]
        },
        {
          "id": "redis-key-management",
          "title": "Key Management",
          "description": "Keys are the backbone of Redis. Learn expiration, scanning safely, naming conventions, and deletion semantics to avoid production pitfalls.",
          "briefDescription": "Expiration, scanning, and naming patterns.",
          "priority": "must",
          "children": [
            { "id": "redis-expiration", "title": "Key Expiration (EXPIRE, TTL, PERSIST)", "description": "Set TTL with EXPIRE or SETEX, inspect with TTL, remove expiry with PERSIST. Essential for caches and session data.", "briefDescription": "Manage key lifetimes.", "priority": "must" },
            { "id": "redis-key-patterns", "title": "Key Patterns (KEYS, SCAN)", "description": "Avoid KEYS in production (blocking). Use SCAN for incremental iteration. Pattern-based key design helps targeted scans.", "briefDescription": "Safe key discovery in production.", "priority": "must" },
            { "id": "redis-key-naming", "title": "Key Naming Conventions", "description": "Use namespaces like user:123:profile. Consistent naming improves readability, key discovery, and avoids collisions.", "briefDescription": "Namespace and structure key names.", "priority": "imp" },
            { "id": "redis-del-vs-unlink", "title": "DEL vs UNLINK", "description": "DEL removes keys synchronously (blocking on large values). UNLINK is async deletion, safer for big keys.", "briefDescription": "Delete keys safely under load.", "priority": "imp" }
          ]
        },
        {
          "id": "redis-cache",
          "title": "Redis as Cache",
          "description": "Caching is Redis’s most common use case. Know cache patterns, eviction policies, TTL strategies, and client usage in Node.js.",
          "briefDescription": "Cache patterns and Redis client usage.",
          "priority": "must",
          "children": [
            { "id": "redis-cache-aside", "title": "Cache-Aside Pattern", "description": "Application checks cache first; on miss, load from DB and populate cache. Most common pattern. Requires invalidation on writes.", "briefDescription": "Read-through via app logic.", "priority": "must" },
            { "id": "redis-write-through", "title": "Write-Through Cache", "description": "Writes go through cache and DB together. Cache always up-to-date but adds latency on writes.", "briefDescription": "Write to cache and DB together.", "priority": "imp" },
            { "id": "redis-write-behind", "title": "Write-Behind Cache", "description": "Writes update cache immediately and DB asynchronously. High write throughput but risk of data loss without strong durability.", "briefDescription": "Async DB writes with cache.", "priority": "look" },
            { "id": "redis-cache-invalidation", "title": "Cache Invalidation Strategies", "description": "Invalidate on writes, use TTLs, or versioned keys. Cache invalidation is hard; pick a strategy that fits data volatility.", "briefDescription": "Keep cached data correct.", "priority": "must" },
            { "id": "redis-ttl", "title": "TTL-based Expiration", "description": "Set per-key TTLs to limit staleness and memory usage. Align TTLs with business requirements.", "briefDescription": "Expire cache entries automatically.", "priority": "must" },
            { "id": "redis-lru", "title": "LRU Eviction Policy", "description": "Eviction policies (allkeys-lru, volatile-lru) control which keys are removed when memory is full. Understand trade-offs for caches vs sessions.", "briefDescription": "Eviction strategy for memory pressure.", "priority": "imp" },
            { "id": "redis-stampede", "title": "Cache Stampede Prevention", "description": "Use request coalescing, locks, or early expiration jitter to avoid thundering herds on popular keys.", "briefDescription": "Prevent cache thundering herd.", "priority": "imp" },
            {
              "id": "redis-node-client",
              "title": "Node.js Redis Client (ioredis / node-redis)",
              "description": "Use a Redis client in Node.js to connect, execute commands, and manage pooling. Understand connection options and error handling.",
              "briefDescription": "Use Redis from Node.js apps.",
              "priority": "must",
              "children": [
                { "id": "redis-client-connection", "title": "Connection & Configuration", "description": "Configure host/port, password, TLS, retry strategies, and connection pooling. Handle reconnects and errors gracefully.", "briefDescription": "Configure Redis client connections.", "priority": "must" },
                { "id": "redis-client-pipelining", "title": "Pipelining", "description": "Batch multiple commands in one round trip to reduce latency. Useful for bulk operations and performance-sensitive paths.", "briefDescription": "Batch commands to reduce latency.", "priority": "imp" },
                { "id": "redis-client-transactions", "title": "Transactions (MULTI/EXEC)", "description": "MULTI queues commands and EXEC runs atomically. Use WATCH for optimistic concurrency control.", "briefDescription": "Atomic multi-command execution.", "priority": "imp" }
              ]
            }
          ]
        },
        {
          "id": "redis-pubsub",
          "title": "Redis Pub/Sub",
          "description": "Redis supports lightweight pub/sub messaging. Use it for real-time events, notifications, and chat, with awareness of delivery guarantees.",
          "briefDescription": "Publish/subscribe messaging.",
          "priority": "imp",
          "children": [
            { "id": "redis-publish-subscribe", "title": "PUBLISH, SUBSCRIBE, UNSUBSCRIBE", "description": "Publish messages to channels and subscribe to receive them. Clients that are offline miss messages (no persistence).", "briefDescription": "Basic pub/sub commands.", "priority": "imp" },
            { "id": "redis-psubscribe", "title": "Pattern Subscriptions (PSUBSCRIBE)", "description": "Subscribe to channel patterns like news.* to receive multiple related streams. Helpful for multi-tenant or topic-based messaging.", "briefDescription": "Subscribe by channel pattern.", "priority": "look" },
            { "id": "redis-notifications", "title": "Real-time Notifications", "description": "Use pub/sub to push notifications, invalidate caches, or broadcast events to WebSocket servers.", "briefDescription": "Broadcast events in real time.", "priority": "imp" },
            { "id": "redis-chat", "title": "Chat Applications", "description": "Pub/sub can power basic chat. For persistence and delivery guarantees, use Streams or a message queue.", "briefDescription": "Messaging for chat scenarios.", "priority": "look" }
          ]
        },
        {
          "id": "redis-mern",
          "title": "Redis in MERN Stack",
          "description": "Redis enhances MERN apps with sessions, rate limiting, queues, real-time features, and distributed locks. Understand common patterns and libraries.",
          "briefDescription": "Practical MERN use cases for Redis.",
          "priority": "must",
          "children": [
            { "id": "redis-sessions", "title": "Session Storage", "description": "Store sessions in Redis using connect-redis. Enables horizontal scaling across multiple Node.js servers.", "briefDescription": "Centralized session store.", "priority": "must" },
            { "id": "redis-rate-limiting", "title": "Rate Limiting", "description": "Use INCR + EXPIRE or libraries to track requests per IP/user. Redis offers atomic counters for distributed throttling.", "briefDescription": "Distributed request throttling.", "priority": "must" },
            {
              "id": "redis-job-queues",
              "title": "Job Queues (Bull / BullMQ)",
              "description": "Bull/BullMQ use Redis for job queues with retries, delays, and concurrency. Common for background tasks like emails or video processing.",
              "briefDescription": "Background job processing.",
              "priority": "must",
              "children": [
                { "id": "queue-worker-job", "title": "Queue, Worker, Job", "description": "Queue enqueues jobs, workers process them, job objects store data and state. Core mental model for Bull/BullMQ.", "briefDescription": "Core queue components.", "priority": "must" },
                { "id": "queue-delayed", "title": "Delayed Jobs", "description": "Schedule jobs to run in the future (e.g., reminder emails). Redis stores the delay and promotes jobs when due.", "briefDescription": "Run jobs in the future.", "priority": "imp" },
                { "id": "queue-repeatable", "title": "Repeatable Jobs", "description": "Cron-like jobs (e.g., nightly reports). Ensure idempotency and proper error handling.", "briefDescription": "Recurring background jobs.", "priority": "imp" },
                { "id": "queue-events", "title": "Job Events", "description": "Listen to completed, failed, and stalled events for monitoring. Useful for dashboards and alerting.", "briefDescription": "Job lifecycle events.", "priority": "imp" },
                { "id": "queue-concurrency", "title": "Concurrency", "description": "Configure worker concurrency to control throughput and resource usage. Too high can overwhelm DB or external services.", "briefDescription": "Parallel job processing control.", "priority": "imp" }
              ]
            },
            { "id": "redis-realtime", "title": "Real-time Features", "description": "Use Redis pub/sub or streams to broadcast updates to WebSocket servers for chat, notifications, and live dashboards.", "briefDescription": "Real-time events and updates.", "priority": "imp" },
            { "id": "redis-api-cache", "title": "Caching API Responses", "description": "Cache GET responses for hot endpoints. Use TTLs and invalidation on writes to keep data fresh.", "briefDescription": "Cache hot API responses.", "priority": "must" },
            { "id": "redis-distributed-locks", "title": "Distributed Locks (Redlock)", "description": "Use Redlock to coordinate actions across multiple servers (e.g., one-time jobs). Be aware of failure modes and timeouts.", "briefDescription": "Coordinate work across servers.", "priority": "imp" }
          ]
        },
        {
          "id": "redis-cluster",
          "title": "Redis Cluster",
          "description": "Scale Redis with replication, Sentinel for HA, and cluster mode for sharding. Understand how data is partitioned and how failover works.",
          "briefDescription": "High availability and horizontal scaling.",
          "priority": "imp",
          "children": [
            { "id": "redis-replication", "title": "Replication", "description": "Primary-replica replication improves read scalability and provides redundancy. Async replication means replicas may lag slightly.", "briefDescription": "Primary-replica data copying.", "priority": "imp" },
            { "id": "redis-sentinel", "title": "Sentinel (High Availability)", "description": "Sentinel monitors Redis instances and performs automatic failover. Clients use Sentinel to discover the current primary.", "briefDescription": "Automatic failover management.", "priority": "imp" },
            { "id": "redis-cluster-mode", "title": "Cluster Mode", "description": "Redis Cluster shards data across nodes using hash slots. Provides horizontal scaling and automatic failover, but requires client cluster support.", "briefDescription": "Sharded Redis for scale.", "priority": "imp" },
            { "id": "redis-partitioning", "title": "Partitioning", "description": "Data is partitioned by key hash slot. Key tags (e.g., {user}:profile) keep related keys on same shard for multi-key ops.", "briefDescription": "Shard keys and slot distribution.", "priority": "imp" }
          ]
        },
        {
          "id": "redis-performance",
          "title": "Redis Performance",
          "description": "Performance tuning helps Redis scale under high load. Learn pipelining, Lua scripting, memory optimization, and diagnostics like slowlog.",
          "briefDescription": "Optimize Redis for throughput and latency.",
          "priority": "imp",
          "children": [
            { "id": "redis-perf-pipelining", "title": "Pipelining", "description": "Send multiple commands in one TCP round-trip to reduce latency. Especially important for high-throughput workloads.", "briefDescription": "Reduce network latency with pipelines.", "priority": "imp" },
            { "id": "redis-lua", "title": "Lua Scripting", "description": "EVAL scripts run atomically in Redis. Use for complex operations without race conditions. Beware of long-running scripts blocking the server.", "briefDescription": "Atomic server-side scripting.", "priority": "imp" },
            { "id": "redis-memory", "title": "Memory Optimization", "description": "Use appropriate data types, compression, and TTLs. Monitor memory usage with INFO and tune maxmemory and eviction policy.", "briefDescription": "Control memory usage effectively.", "priority": "imp" },
            { "id": "redis-slowlog", "title": "Slow Log", "description": "SLOWLOG shows commands exceeding a threshold. Use it to find bottlenecks and optimize queries or data structures.", "briefDescription": "Find slow commands and bottlenecks.", "priority": "imp" }
          ]
        }
      ]
    }
    ,
    {
      "id": "auth-security",
      "title": "Authentication & Security",
      "description": "Authentication and security are critical for protecting user data and preventing attacks. You must understand different auth methods, authorization patterns, password security, and common web vulnerabilities. Interviewers often test knowledge of JWT, OWASP Top 10, CSRF, XSS, and security best practices.",
      "briefDescription": "User authentication and web application security.",
      "priority": "must",
      "children": [
        {
          "id": "auth-methods",
          "title": "Authentication Methods",
          "description": "Different ways to verify user identity. Choose the right method based on security requirements, user experience, and system architecture.",
          "briefDescription": "Ways to verify user identity.",
          "priority": "must",
          "children": [
            {
              "id": "session-auth",
              "title": "Session-based Authentication",
              "description": "Traditional authentication using server-side sessions and cookies. Session ID stored in cookie, session data on server.",
              "briefDescription": "Server-side session management.",
              "priority": "must",
              "children": [
                { "id": "cookie-session-id", "title": "Cookie + Session ID", "description": "Server generates unique session ID, stores in cookie. Session data lives server-side. Stateful but simple and secure when configured properly.", "briefDescription": "Cookie with server session storage.", "priority": "must" },
                { "id": "session-store", "title": "Session Store (Memory, Redis, MongoDB)", "description": "Memory: dev only, doesn't scale. Redis: fast, scalable. MongoDB: persistent, slower. Choose based on scale and persistence needs.", "briefDescription": "Where session data is stored.", "priority": "must" },
                { "id": "session-hijacking", "title": "Session Hijacking Prevention", "description": "Use HTTPS, secure/httpOnly cookies, regenerate session IDs on login, implement session timeouts. Monitor for suspicious activity.", "briefDescription": "Protect against session theft.", "priority": "imp" }
              ]
            },
            {
              "id": "token-auth",
              "title": "Token-based Authentication",
              "description": "Stateless authentication using tokens. Popular for APIs and SPAs. JWT is the most common token format.",
              "briefDescription": "Stateless token-based auth.",
              "priority": "must",
              "children": [
                {
                  "id": "jwt",
                  "title": "JWT (JSON Web Token)",
                  "description": "Self-contained tokens with header, payload, and signature. Stateless, scalable, but need careful handling for security.",
                  "briefDescription": "JSON Web Token standard.",
                  "priority": "must",
                  "children": [
                    { "id": "jwt-structure", "title": "Header, Payload, Signature", "description": "Header: algorithm, type. Payload: claims (user data). Signature: prevents tampering. Base64 encoded, dot-separated.", "briefDescription": "JWT three-part structure.", "priority": "must" },
                    { "id": "jwt-tokens", "title": "Access Token vs Refresh Token", "description": "Access: short-lived (15min), for resource access. Refresh: long-lived (days/weeks), to get new access tokens. Reduces exposure if access token stolen.", "briefDescription": "Short and long-lived tokens.", "priority": "must" },
                    { "id": "jwt-storage", "title": "Token Storage (httpOnly Cookie vs localStorage)", "description": "httpOnly cookie: XSS-resistant, CSRF-vulnerable. localStorage: accessible to JS, vulnerable to XSS. Consider security trade-offs.", "briefDescription": "Where to store JWT tokens.", "priority": "must" },
                    { "id": "jwt-expiration", "title": "Token Expiration & Renewal", "description": "Set short expiry times. Use refresh tokens to renew. Handle expired tokens gracefully in frontend. Monitor for unusual refresh patterns.", "briefDescription": "Manage token lifecycle.", "priority": "must" },
                    { "id": "jwt-verification", "title": "JWT Verification", "description": "Always verify signature and expiration. Check issuer and audience if used. Use established libraries, never implement JWT verification manually.", "briefDescription": "Validate JWT tokens safely.", "priority": "must" },
                    { "id": "jwt-algorithms", "title": "Signing Algorithms (HS256, RS256)", "description": "HS256: symmetric, shared secret. RS256: asymmetric, public/private keys. RS256 better for distributed systems, HS256 simpler for single service.", "briefDescription": "JWT signing methods.", "priority": "imp" }
                  ]
                },
                { "id": "bearer-token", "title": "Bearer Token", "description": "Authorization: Bearer <token>. Simple token auth without specific format. Can be JWT or opaque. Standard for API authentication.", "briefDescription": "Authorization header token pattern.", "priority": "must" }
              ]
            },
            {
              "id": "oauth2",
              "title": "OAuth 2.0",
              "description": "Authorization framework for third-party access. Multiple flows for different scenarios. Foundation for social login.",
              "briefDescription": "Authorization delegation framework.",
              "priority": "imp",
              "children": [
                { "id": "oauth-auth-code", "title": "Authorization Code Flow", "description": "Most secure flow for server-side apps. User redirected to auth server, code exchanged for tokens. Prevents token exposure to browser.", "briefDescription": "Secure server-side OAuth flow.", "priority": "imp" },
                { "id": "oauth-pkce", "title": "PKCE Flow", "description": "Authorization Code + Proof Key for Code Exchange. Secure for mobile and SPA. Prevents code interception attacks.", "briefDescription": "Secure mobile/SPA OAuth flow.", "priority": "imp" },
                { "id": "oauth-implicit", "title": "Implicit Flow (Deprecated)", "description": "Directly returns access token to browser. Deprecated due to security issues. Use Authorization Code + PKCE instead.", "briefDescription": "Deprecated browser OAuth flow.", "priority": "look" },
                { "id": "oauth-client-credentials", "title": "Client Credentials Flow", "description": "Service-to-service authentication. Client ID and secret for token. No user involvement.", "briefDescription": "Machine-to-machine OAuth.", "priority": "imp" },
                { "id": "oauth-scopes", "title": "Scopes & Permissions", "description": "Granular permissions (read, write, admin). Users consent to specific access. Principle of least privilege.", "briefDescription": "Limited permission grants.", "priority": "imp" },
                { "id": "oauth-refresh", "title": "Refresh Tokens", "description": "Long-lived tokens to renew access tokens. Can be revoked. Store securely, use HTTPS, implement rotation.", "briefDescription": "Token renewal mechanism.", "priority": "imp" }
              ]
            },
            { "id": "oidc", "title": "OpenID Connect (OIDC)", "description": "Identity layer on OAuth 2.0. Standardizes user info, ID tokens. Enables single sign-on. Built on JWT.", "briefDescription": "Identity layer for OAuth 2.0.", "priority": "imp" },
            { "id": "social-login", "title": "Social Login (Google, GitHub, Facebook)", "description": "Use OAuth providers for user authentication. Reduces friction, improves security. Handle account linking and data syncing.", "briefDescription": "Third-party authentication.", "priority": "imp" },
            { "id": "magic-links", "title": "Magic Links", "description": "Passwordless auth via email links. Good UX, eliminates password problems. Requires secure email delivery and link expiration.", "briefDescription": "Email-based passwordless auth.", "priority": "imp" },
            { "id": "passwordless", "title": "Passwordless Authentication", "description": "SMS OTP, email OTP, FIDO2/WebAuthn. Improves security and UX. Reduces password-related attacks.", "briefDescription": "Authentication without passwords.", "priority": "imp" },
            {
              "id": "mfa",
              "title": "Multi-Factor Authentication (MFA/2FA)",
              "description": "Additional security layer beyond passwords. Something you know + have + are. Critical for sensitive applications.",
              "briefDescription": "Multiple authentication factors.",
              "priority": "must",
              "children": [
                { "id": "mfa-totp", "title": "TOTP (Google Authenticator)", "description": "Time-based one-time passwords. Apps generate codes from shared secret. Works offline, more secure than SMS.", "briefDescription": "App-based time codes.", "priority": "must" },
                { "id": "mfa-sms", "title": "SMS OTP", "description": "Text message codes. Convenient but vulnerable to SIM swapping and interception. Better than no 2FA.", "briefDescription": "Text message verification.", "priority": "imp" },
                { "id": "mfa-backup", "title": "Backup Codes", "description": "One-time use codes for device loss. Store securely, track usage. Essential recovery mechanism.", "briefDescription": "Recovery codes for device loss.", "priority": "imp" }
              ]
            },
            {
              "id": "passportjs",
              "title": "Passport.js",
              "description": "Popular Node.js authentication middleware. Strategy-based, supports 500+ providers. Simplifies complex authentication flows.",
              "briefDescription": "Node.js authentication middleware.",
              "priority": "imp",
              "children": [
                { "id": "passport-strategies", "title": "Strategies (Local, JWT, Google, GitHub)", "description": "Modular authentication methods. Local for username/password, JWT for tokens, OAuth for social login. Mix and match.", "briefDescription": "Pluggable auth methods.", "priority": "imp" },
                { "id": "passport-serialize", "title": "Serialize/Deserialize", "description": "Convert user object to/from session format. serializeUser stores minimal data, deserializeUser rebuilds user object.", "briefDescription": "User session persistence.", "priority": "imp" },
                { "id": "passport-session", "title": "Session Integration", "description": "Works with express-session. Manages login state across requests. Configure session store for production.", "briefDescription": "Session-based login state.", "priority": "imp" }
              ]
            }
          ]
        },
        {
          "id": "authorization",
          "title": "Authorization",
          "description": "Control what authenticated users can access. Different models for different use cases, from simple roles to complex attribute-based control.",
          "briefDescription": "Control access to resources.",
          "priority": "must",
          "children": [
            { "id": "rbac", "title": "Role-Based Access Control (RBAC)", "description": "Users have roles, roles have permissions. Simple and widely used. Examples: admin, user, moderator. Good for hierarchical access.", "briefDescription": "Role-based permissions.", "priority": "must" },
            { "id": "permission-based", "title": "Permission-Based Access Control", "description": "Direct permission assignments to users. More granular than roles. Useful when roles don't fit cleanly.", "briefDescription": "Direct user permissions.", "priority": "imp" },
            { "id": "abac", "title": "Attribute-Based Access Control (ABAC)", "description": "Policies based on attributes (user, resource, environment). Very flexible but complex. Good for fine-grained control.", "briefDescription": "Attribute-based policies.", "priority": "imp" },
            { "id": "middleware-auth", "title": "Middleware-based Authorization", "description": "Check permissions in Express middleware. Protect routes before handlers run. Common pattern: requireRole('admin').", "briefDescription": "Route-level authorization checks.", "priority": "must" },
            { "id": "route-guards", "title": "Route Guards (Frontend)", "description": "React Router protection. Check auth state before rendering components. Redirect to login if unauthorized.", "briefDescription": "Frontend route protection.", "priority": "must" },
            { "id": "api-authorization", "title": "API Authorization Patterns", "description": "Consistent API protection. Resource-based permissions, owner checks, admin overrides. Return 403 for insufficient permissions.", "briefDescription": "API access control patterns.", "priority": "must" }
          ]
        },
        {
          "id": "password-security",
          "title": "Password Security",
          "description": "Proper password handling prevents data breaches. Never store plain text passwords, use strong hashing, implement reset flows securely.",
          "briefDescription": "Secure password handling.",
          "priority": "must",
          "children": [
            { "id": "password-hashing", "title": "Hashing (bcrypt, argon2, scrypt)", "description": "bcrypt: industry standard, good security. argon2: newer, more secure. scrypt: memory-hard. Never use MD5, SHA1 for passwords.", "briefDescription": "Strong password hashing algorithms.", "priority": "must" },
            { "id": "password-salting", "title": "Salting", "description": "Random data added before hashing. Prevents rainbow table attacks. bcrypt includes salt automatically. Use cryptographically secure random.", "briefDescription": "Prevent rainbow table attacks.", "priority": "must" },
            { "id": "password-policies", "title": "Password Policies", "description": "Length (min 8-12), complexity requirements, common password blocking. Balance security and usability. Communicate requirements clearly.", "briefDescription": "Password strength requirements.", "priority": "imp" },
            { "id": "password-reset", "title": "Password Reset Flow", "description": "Secure token generation, email delivery, expiration, one-time use. Don't reveal if email exists. Rate limit requests.", "briefDescription": "Secure forgot password flow.", "priority": "must" },
            { "id": "forgot-password", "title": "Forgot Password Implementation", "description": "Generate crypto-random token, store with expiry, send via email. Validate token, allow password change, invalidate token.", "briefDescription": "Reset password securely.", "priority": "must" }
          ]
        },
        {
          "id": "web-security",
          "title": "Web Security",
          "description": "Understanding common web vulnerabilities and their prevention is crucial. Learn OWASP Top 10, implement security headers, validate input properly.",
          "briefDescription": "Common web vulnerabilities and prevention.",
          "priority": "must",
          "children": [
            { "id": "owasp-top-10", "title": "OWASP Top 10", "description": "Most critical web security risks. Study current list: injection, broken auth, sensitive data, XXE, broken access, security misconfig, XSS, insecure deserialization, vulnerable components, insufficient logging.", "briefDescription": "Top web security risks.", "priority": "must" },
            {
              "id": "xss",
              "title": "Cross-Site Scripting (XSS)",
              "description": "Malicious scripts injected into web pages. Can steal sessions, deface sites, redirect users. Three main types with different attack vectors.",
              "briefDescription": "Script injection attacks.",
              "priority": "must",
              "children": [
                { "id": "xss-stored", "title": "Stored XSS", "description": "Malicious script stored in database, served to users. Most dangerous. Example: comment with <script>. Escape output, validate input.", "briefDescription": "Persistent script injection.", "priority": "must" },
                { "id": "xss-reflected", "title": "Reflected XSS", "description": "Script in URL parameters reflected to page. Social engineering via malicious links. Validate and escape query parameters.", "briefDescription": "URL-based script injection.", "priority": "must" },
                { "id": "xss-dom", "title": "DOM-based XSS", "description": "Client-side script manipulation. JavaScript modifies DOM with untrusted data. Validate client-side input, use safe DOM methods.", "briefDescription": "Client-side script attacks.", "priority": "imp" },
                { "id": "xss-prevention", "title": "Prevention (Sanitization, CSP)", "description": "Escape output, sanitize input, Content Security Policy headers. Use template engines that auto-escape. Whitelist allowed HTML tags.", "briefDescription": "XSS protection techniques.", "priority": "must" }
              ]
            },
            {
              "id": "csrf",
              "title": "Cross-Site Request Forgery (CSRF)",
              "description": "Unauthorized commands transmitted from trusted user. Exploits site trust in user's browser. Affects state-changing operations.",
              "briefDescription": "Unauthorized request submissions.",
              "priority": "must",
              "children": [
                { "id": "csrf-tokens", "title": "CSRF Tokens", "description": "Include random token in forms, verify in backend. Synchronizer token pattern. Embed in meta tags or hidden fields.", "briefDescription": "Form-based CSRF protection.", "priority": "must" },
                { "id": "samesite-cookies", "title": "SameSite Cookies", "description": "SameSite=Strict/Lax prevents cross-site cookie sending. Strict blocks all, Lax allows top-level navigation. Modern CSRF defense.", "briefDescription": "Cookie-based CSRF protection.", "priority": "must" },
                { "id": "double-submit", "title": "Double Submit Cookie", "description": "Token in both cookie and request. Attacker can't read cookie value due to same-origin policy. Stateless CSRF protection.", "briefDescription": "Stateless CSRF token approach.", "priority": "imp" }
              ]
            },
            {
              "id": "injection",
              "title": "SQL / NoSQL Injection",
              "description": "Malicious input manipulates database queries. Can expose data, modify records, or escalate privileges. Prevention through proper query construction.",
              "briefDescription": "Database query manipulation attacks.",
              "priority": "must",
              "children": [
                { "id": "query-parameterization", "title": "Query Parameterization", "description": "Use prepared statements with parameters. Separate SQL structure from data. Never concatenate user input into queries.", "briefDescription": "Safe query construction.", "priority": "must" },
                { "id": "mongodb-injection", "title": "MongoDB Injection Prevention", "description": "Validate input types, use Mongoose schemas, avoid where() with user input. MongoDB less vulnerable but still requires validation.", "briefDescription": "NoSQL injection protection.", "priority": "must" }
              ]
            },
            {
              "id": "security-headers",
              "title": "Security Headers",
              "description": "HTTP headers that control browser security behavior. Essential defense-in-depth measure. Use Helmet.js for Express apps.",
              "briefDescription": "Browser security control headers.",
              "priority": "must",
              "children": [
                { "id": "csp", "title": "Content-Security-Policy", "description": "Controls resource loading sources. Prevents XSS by restricting script sources. Start with default-src 'self', gradually tighten.", "briefDescription": "Resource loading restrictions.", "priority": "must" },
                { "id": "content-type-options", "title": "X-Content-Type-Options", "description": "nosniff prevents MIME type confusion attacks. Forces browsers to respect Content-Type header. Prevents script execution via file upload.", "briefDescription": "MIME type enforcement.", "priority": "imp" },
                { "id": "frame-options", "title": "X-Frame-Options", "description": "DENY or SAMEORIGIN prevents clickjacking. Controls whether page can be embedded in iframe. Protects against UI redression.", "briefDescription": "Clickjacking prevention.", "priority": "imp" },
                { "id": "hsts", "title": "Strict-Transport-Security (HSTS)", "description": "Forces HTTPS connections. includeSubDomains for subdomain protection. preload for browser built-in list.", "briefDescription": "HTTPS enforcement.", "priority": "must" },
                { "id": "xss-protection", "title": "X-XSS-Protection", "description": "Legacy XSS filter control. Modern CSP preferred. 1; mode=block enables browser XSS filtering.", "briefDescription": "Browser XSS filter control.", "priority": "look" },
                { "id": "referrer-policy", "title": "Referrer-Policy", "description": "Controls referrer header information. no-referrer for privacy, strict-origin-when-cross-origin for balance.", "briefDescription": "Referrer header control.", "priority": "imp" }
              ]
            },
            {
              "id": "cors-security",
              "title": "CORS",
              "description": "Cross-Origin Resource Sharing controls browser access from different domains. Misconfiguration can expose APIs to unauthorized sites.",
              "briefDescription": "Cross-origin access control.",
              "priority": "must",
              "children": [
                { "id": "cors-origins", "title": "Origin, Methods, Headers", "description": "Whitelist specific origins, methods, and headers. Avoid wildcard (*) with credentials. Configure per environment.", "briefDescription": "CORS configuration options.", "priority": "must" },
                { "id": "cors-credentials", "title": "Credentials", "description": "withCredentials: true sends cookies/auth. Requires specific origin (not *). Use carefully for authenticated APIs.", "briefDescription": "Cross-origin authentication.", "priority": "must" },
                { "id": "cors-preflight", "title": "Preflight Requests (OPTIONS)", "description": "Browser checks permissions before complex requests. Handle OPTIONS method. Cache preflight responses for performance.", "briefDescription": "CORS permission checks.", "priority": "imp" },
                { "id": "cors-whitelist", "title": "Whitelisting Origins", "description": "Maintain allowed origin list. Environment-specific configuration. Validate origin format to prevent bypass.", "briefDescription": "Allowed domain management.", "priority": "must" }
              ]
            },
            { "id": "https-tls", "title": "HTTPS & TLS", "description": "Encrypt data in transit. Use TLS 1.2+ only, strong cipher suites, valid certificates. HTTP Strict Transport Security recommended.", "briefDescription": "Transport layer security.", "priority": "must" },
            { "id": "rate-limiting-security", "title": "Rate Limiting & Brute Force Protection", "description": "Prevent abuse and brute force attacks. Implement per-IP, per-user limits. Progressive delays, account lockout. Use Redis for distributed systems.", "briefDescription": "Abuse prevention mechanisms.", "priority": "must" },
            { "id": "input-validation", "title": "Input Validation & Sanitization", "description": "Validate type, length, format, range. Whitelist approach preferred. Sanitize for output context. Server-side validation essential.", "briefDescription": "Secure input handling.", "priority": "must" },
            { "id": "clickjacking", "title": "Clickjacking Prevention", "description": "X-Frame-Options: DENY or frame-ancestors in CSP. Prevents UI redressing attacks. Iframe sandbox attribute for trusted embeds.", "briefDescription": "UI redressing attack prevention.", "priority": "imp" },
            { "id": "file-upload-security", "title": "File Upload Security", "description": "Validate file type, size, extension. Scan for malware, store outside web root. Never execute uploaded files. Use CDN for serving.", "briefDescription": "Secure file handling.", "priority": "imp" },
            { "id": "ssrf", "title": "Server-Side Request Forgery (SSRF)", "description": "Server makes unauthorized requests. Validate URLs, whitelist domains, block internal IPs. Common in webhook and proxy features.", "briefDescription": "Server request manipulation.", "priority": "imp" },
            { "id": "idor", "title": "Insecure Direct Object References (IDOR)", "description": "Direct access to objects without authorization. Authorize every resource access. Use UUIDs instead of sequential IDs.", "briefDescription": "Unauthorized resource access.", "priority": "must" }
          ]
        }
      ]
    }
    ,
    {
      "id": "rest-api-design",
      "title": "REST API Design",
      "description": "REST (Representational State Transfer) is an architectural style for designing distributed systems, particularly web APIs. Good REST API design follows conventions that make APIs intuitive, scalable, and maintainable. Understanding REST principles, HTTP semantics, URL design patterns, status codes, and documentation standards is essential for building APIs that developers love to use. Modern MERN applications rely heavily on well-designed REST APIs for client-server communication, and interviewers frequently test knowledge of RESTful design principles.",
      "briefDescription": "Architectural style for scalable web APIs.",
      "priority": "must",
      "children": [
        {
          "id": "rest-principles",
          "title": "REST Principles",
          "description": "REST is built on six architectural constraints that guide API design. These principles ensure scalability, reliability, and performance. Understanding these constraints helps you design APIs that scale to millions of users and integrate well with web infrastructure.",
          "briefDescription": "Core architectural constraints of REST.",
          "priority": "must",
          "children": [
            { "id": "rest-statelessness", "title": "Statelessness", "description": "Each request must contain all information needed to process it. The server stores no client context between requests. This improves scalability since servers don't need to maintain session state, enables easy load balancing across multiple servers, and makes the system more reliable as there's no shared state to corrupt. Session data should be stored client-side (JWT tokens) or in external stores (Redis). This constraint is fundamental to horizontal scaling.", "briefDescription": "No server-side session state between requests.", "priority": "must" },
            { "id": "rest-client-server", "title": "Client-Server", "description": "Clear separation between user interface concerns (client) and data storage concerns (server). Clients don't need to know about database schemas, storage, or business logic implementation details. Servers don't care about user interface or platform specifics. This separation allows independent evolution - you can update the mobile app without changing the API, or refactor the backend without breaking clients. It also enables multiple client types (web, mobile, IoT) to use the same API.", "briefDescription": "Separation of client and server concerns.", "priority": "must" },
            { "id": "rest-uniform-interface", "title": "Uniform Interface", "description": "Consistent conventions across the entire API create predictability and reduce cognitive load. This includes standard HTTP methods (GET, POST, PUT, DELETE), consistent URL patterns (/users, /users/:id), standard status codes (200, 404, 500), and uniform response formats (always JSON with consistent error structure). When developers learn one endpoint, they intuitively understand others. This is what makes REST APIs self-documenting and easy to explore.", "briefDescription": "Consistent conventions across all endpoints.", "priority": "must" },
            { "id": "rest-cacheable", "title": "Cacheable", "description": "Responses must explicitly indicate whether they're cacheable to improve performance and reduce server load. HTTP provides built-in caching mechanisms through headers like Cache-Control, ETag, and Last-Modified. GET requests are typically cacheable, while POST/PUT/DELETE are not. Proper caching can reduce response times from 500ms to 50ms and decrease server load by 80%. Design APIs with caching in mind - use ETags for conditional requests, set appropriate cache headers, and structure URLs to maximize cache hit rates.", "briefDescription": "Responses indicate cacheability for performance.", "priority": "imp" },
            { "id": "rest-layered-system", "title": "Layered System", "description": "API architecture can be composed of hierarchical layers where each layer only interacts with immediate neighbors. Clients don't know if they're connected directly to the server or through intermediaries like load balancers, CDNs, gateways, or proxies. This enables deployment flexibility, security through firewalls and gateways, performance optimization through caching layers, and incremental system evolution. For example: Client → CDN → Load Balancer → API Gateway → Microservice.", "briefDescription": "Hierarchical component layers for scalability.", "priority": "imp" },
            { "id": "rest-resource-based", "title": "Resource-based", "description": "APIs are organized around resources (nouns) rather than actions (verbs). Resources represent domain entities like users, products, orders, or posts. Each resource has a unique URL identifier and supports standard operations through HTTP methods. This creates intuitive APIs where /users represents all users, /users/123 represents one user, and actions are expressed through HTTP verbs. Resources can have sub-resources (/users/123/posts) and relationships are expressed through URL structure. This approach maps naturally to object-oriented programming and database entities.", "briefDescription": "APIs organized around domain entities.", "priority": "must" }
          ]
        },
        {
          "id": "url-design",
          "title": "URL Design", 
          "description": "Well-designed URLs are intuitive, hierarchical, and follow consistent patterns. They should read like sentences and clearly indicate what resource they represent. Good URL design reduces documentation needs and makes APIs self-discoverable.",
          "briefDescription": "Intuitive and consistent URL patterns.",
          "priority": "must",
          "children": [
            { "id": "restful-naming", "title": "RESTful Naming Conventions", "description": "Use nouns for resources, not verbs. Resources should represent entities in your domain. Good: /users, /products, /orders. Bad: /getUsers, /createProduct, /deleteOrder. Use lowercase letters, separate words with hyphens (kebab-case), and keep URLs readable. Avoid abbreviations unless they're universally understood. URLs should be predictable - if /users exists, users expect /products to follow the same pattern. Think of URLs as file paths to your data.", "briefDescription": "Noun-based resource naming without verbs.", "priority": "must" },
            { "id": "plural-nouns", "title": "Plural Nouns", "description": "Use plural nouns for collections even when dealing with single items. /users/123 is better than /user/123 because it maintains consistency with the collection URL /users. This pattern is universal across REST APIs and reduces cognitive load. The HTTP method indicates the operation (GET for read, POST for create), not the URL. Plural forms also make it clear that this is part of a collection, which maps well to database tables and programming arrays.", "briefDescription": "Collections use plural resource names.", "priority": "must" },
            { "id": "nested-resources", "title": "Nested Resources", "description": "Express relationships through URL hierarchy when one resource belongs to another. /users/123/posts shows posts that belong to user 123. /companies/456/employees shows employees of company 456. Keep nesting shallow (max 2-3 levels) to avoid complex URLs. For deep relationships, provide top-level access: both /users/123/posts/789 and /posts/789 should work. Nested URLs are great for scoped operations but can become unwieldy - balance hierarchy with usability.", "briefDescription": "Hierarchical URLs for resource relationships.", "priority": "must" },
            { "id": "query-parameters", "title": "Query Parameters", "description": "Use query parameters for optional data that modifies the response but doesn't change the resource identity. Common uses: filtering (?status=active), sorting (?sort=name), pagination (?page=2&limit=10), search (?q=javascript), and field selection (?fields=id,name). Query parameters should be optional - the endpoint should work without them. Use consistent naming across your API. Multiple values can be comma-separated (?tags=javascript,react) or repeated (?tag=javascript&tag=react).", "briefDescription": "Optional parameters for filtering and modification.", "priority": "must" },
            { "id": "filtering-sorting-pagination", "title": "Filtering, Sorting, Pagination", "description": "Essential for performance and usability in production APIs. Filtering: ?status=active&category=tech reduces dataset size. Sorting: ?sort=name,-created_at (minus for descending) provides predictable ordering. Pagination: ?page=1&limit=20 or ?offset=0&limit=20 prevents memory issues with large datasets. Always include total count and pagination metadata in responses. Set reasonable default limits (10-100 items). Use cursor-based pagination for real-time data. These parameters dramatically improve API performance and user experience.", "briefDescription": "Essential query parameters for data management.", "priority": "must" },
            { "id": "api-versioning", "title": "Versioning (URL, Header, Query)", "description": "Plan for API evolution from day one. URL versioning (/v1/users, /v2/users) is most explicit and cacheable but creates URL proliferation. Header versioning (Accept: application/vnd.api+json;version=1) keeps URLs clean but is less visible. Query versioning (?version=1) is simple but can be ignored by caches. Choose one strategy and stick to it. Semantic versioning (v1.2.3) for breaking changes. Support multiple versions during transition periods. Good versioning prevents breaking existing integrations.", "briefDescription": "API evolution strategy without breaking changes.", "priority": "must" }
          ]
        },
        {
          "id": "http-methods",
          "title": "HTTP Methods",
          "description": "HTTP verbs define the action to perform on resources. Each method has specific semantics regarding safety, idempotency, and expected behavior. Using methods correctly creates predictable APIs that work well with HTTP infrastructure.",
          "briefDescription": "Standard HTTP verbs with specific semantics.",
          "priority": "must",
          "children": [
            { "id": "http-crud-methods", "title": "GET, POST, PUT, PATCH, DELETE", "description": "Core CRUD operations mapped to HTTP methods. GET retrieves data (SELECT), POST creates new resources (INSERT), PUT replaces entire resources (UPDATE/UPSERT), PATCH partially updates resources (UPDATE), DELETE removes resources. Each method has specific semantics: GET and DELETE are idempotent (same result when repeated), POST is not idempotent (creates new resources), PUT is idempotent (same final state). Understanding these semantics is crucial for reliable API behavior and proper HTTP caching.", "briefDescription": "CRUD operations via HTTP verbs.", "priority": "must" },
            { "id": "http-idempotency", "title": "Idempotency", "description": "Idempotent operations produce the same result when repeated multiple times. GET, PUT, PATCH, DELETE should be idempotent - calling them multiple times has the same effect as calling once. POST is not idempotent - each call creates a new resource. This property is essential for reliable distributed systems where network failures can cause request retries. Design PUT to replace entire resources, not append data. Use PATCH for incremental updates. Idempotency enables safe automatic retries and simplifies client error handling.", "briefDescription": "Operations produce same result when repeated.", "priority": "must" },
            { "id": "http-safe-methods", "title": "Safe Methods", "description": "Safe methods don't modify server state. GET and HEAD are safe - they only retrieve information. Safe methods enable aggressive caching, prefetching, and crawling without side effects. Never use GET for operations that change data (like deleting users). This breaks HTTP semantics and causes issues with browser prefetching, search engine crawlers, and proxy caches. Safe methods should be implemented without side effects - a GET request shouldn't increment view counters or log user activity that affects application behavior.", "briefDescription": "Methods that don't modify server state.", "priority": "must" },
            { "id": "http-head-options", "title": "HEAD, OPTIONS", "description": "HEAD returns same headers as GET but without response body. Use for checking resource existence, getting metadata, or checking cache validity without transferring large payloads. OPTIONS returns allowed methods and CORS headers for a resource. Essential for CORS preflight requests and API discovery. Clients can use OPTIONS to determine what operations are allowed on a resource. Implement these methods for complete HTTP compliance and better developer experience with tools like Postman.", "briefDescription": "Metadata and method discovery operations.", "priority": "imp" }
          ]
        },
        {
          "id": "status-codes",
          "title": "Status Codes",
          "description": "HTTP status codes provide immediate feedback about request results. Use appropriate codes to enable proper client error handling, caching behavior, and debugging. Status codes are part of the API contract and affect how browsers, proxies, and tools behave.",
          "briefDescription": "HTTP response codes for different scenarios.", 
          "priority": "must",
          "children": [
            { "id": "success-codes", "title": "200 OK, 201 Created, 204 No Content", "description": "Success codes indicate the request was processed successfully. 200 OK for successful GET/PUT/PATCH with response body. 201 Created for successful POST that creates a resource - include Location header with new resource URL. 204 No Content for successful operations without response body (like DELETE or PUT without returning data). These distinctions help clients understand what happened and whether to expect response data. Proper success codes enable better caching and clearer API semantics.", "briefDescription": "Successful operation status codes.", "priority": "must" },
            { "id": "redirect-codes", "title": "301 Moved Permanently, 304 Not Modified", "description": "Redirection codes to manage resource locations and caching. 301 when a resource has permanently moved to a new URL - search engines transfer SEO value, clients should update bookmarks. 304 Not Modified for conditional requests when resource hasn't changed since last fetch - enables efficient caching with ETags and Last-Modified headers. Use 302 for temporary redirects, 307/308 for method-preserving redirects. Proper redirect codes optimize bandwidth and improve user experience through effective caching.", "briefDescription": "Redirection and cache-related codes.", "priority": "imp" },
            { "id": "client-error-codes", "title": "400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 409 Conflict, 422 Unprocessable Entity, 429 Too Many Requests", "description": "Client error codes indicate problems with the request. 400 for malformed requests (invalid JSON, missing required fields). 401 when authentication is required or failed. 403 when authenticated user lacks permission. 404 when resource doesn't exist. 409 for conflicts (email already exists, resource locked). 422 for valid requests with semantic errors (password too weak, invalid business logic). 429 for rate limit exceeded. Specific codes enable better client error handling and user experience. Include helpful error messages with actionable guidance.", "briefDescription": "Client-side error codes with specific meanings.", "priority": "must" },
            { "id": "server-error-codes", "title": "500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable", "description": "Server error codes indicate problems on the server side. 500 for unexpected server errors - log details but don't expose internal information to clients. 502 when acting as gateway/proxy and upstream server returns invalid response. 503 when service is temporarily unavailable (maintenance, overloaded) - include Retry-After header with suggested wait time. These codes help distinguish between client mistakes (4xx) and server problems (5xx), enabling appropriate retry logic and error reporting.", "briefDescription": "Server-side error indicators.", "priority": "must" }
          ]
        },
        {
          "id": "request-response",
          "title": "Request/Response",
          "description": "Consistent request and response formats improve developer experience and enable tooling. Well-designed message formats reduce integration effort and prevent common mistakes.",
          "briefDescription": "Consistent message formatting standards.",
          "priority": "must",
          "children": [
            { "id": "content-accept-headers", "title": "Content-Type & Accept Headers", "description": "Content-Type header specifies request body format (application/json, multipart/form-data, application/x-www-form-urlencoded). Accept header specifies desired response format(s). Support content negotiation - clients can request JSON, XML, or other formats based on capabilities. Always validate Content-Type on requests to prevent security issues. Use application/json as default for APIs. For file uploads, use multipart/form-data. Proper content type handling enables better client-server communication and security.", "briefDescription": "Content format negotiation headers.", "priority": "must" },
            { "id": "json-response-format", "title": "JSON Response Format", "description": "Establish consistent JSON structure across your API. Use camelCase for property names to match JavaScript conventions. Include metadata like timestamps, pagination info, and request IDs. Consider envelope patterns for consistency: {\"data\": {...}, \"meta\": {...}, \"errors\": [...]}. Always return arrays for collections, even with one item. Use null for missing values, not undefined. Consistent formatting reduces client-side processing and prevents integration errors. Include helpful metadata like total counts, pagination links, and request tracing IDs.", "briefDescription": "Standardized JSON structure and naming.", "priority": "must" },
            { "id": "error-response-format", "title": "Error Response Format", "description": "Standardize error responses for better client handling. Include error code, human-readable message, and optional details. Format: {\"error\": {\"code\": \"VALIDATION_ERROR\", \"message\": \"Invalid input\", \"details\": [{\"field\": \"email\", \"message\": \"Invalid format\"}]}}. Machine-readable codes enable programmatic handling. Human-readable messages help debugging. Field-specific details guide users to fix problems. Include request ID for support troubleshooting. Don't expose sensitive information like stack traces or database errors in production.", "briefDescription": "Structured error information format.", "priority": "must" },
            { "id": "hateoas", "title": "HATEOAS", "description": "Hypermedia as the Engine of Application State - include links to related resources and available actions in responses. Example: {\"id\": 123, \"name\": \"John\", \"links\": {\"self\": \"/users/123\", \"posts\": \"/users/123/posts\", \"edit\": \"/users/123\", \"delete\": \"/users/123\"}}. This makes APIs self-documenting and discoverable. Clients can follow links without constructing URLs. Changes to URL structure don't break clients. HATEOAS enables true REST but adds complexity. Consider for public APIs where discoverability matters.", "briefDescription": "Self-documenting APIs with hypermedia links.", "priority": "imp" },
            { "id": "envelope-pattern", "title": "Envelope Pattern", "description": "Wrap all responses in consistent envelope structure: {\"data\": actualContent, \"meta\": {\"page\": 1, \"total\": 100}, \"errors\": null}. This provides consistent location for metadata, error information, and pagination details. Enables graceful degradation - clients always know where to find data vs. metadata. Useful for APIs consumed by multiple client types. Some prefer direct responses for simplicity, others prefer envelopes for consistency. Choose based on API complexity and client needs.", "briefDescription": "Consistent response wrapper structure.", "priority": "imp" }
          ]
        },
        {
          "id": "pagination",
          "title": "Pagination",
          "description": "Pagination prevents memory issues and improves performance when dealing with large datasets. Choose the right pagination strategy based on data characteristics and use case requirements.",
          "briefDescription": "Handling large dataset navigation efficiently.",
          "priority": "must",
          "children": [
            { "id": "offset-based-pagination", "title": "Offset-based", "description": "Traditional pagination using offset and limit parameters: ?offset=20&limit=10 or ?page=3&size=10. Simple to implement and understand. Works well for stable datasets where total count matters (like admin interfaces). Include total count in response for page calculation: {\"data\": [...], \"total\": 1000, \"page\": 3, \"pages\": 100}. Problems: performance degrades with large offsets (database has to skip many records), inconsistent results if data changes during pagination. Best for small-medium datasets with occasional use.", "briefDescription": "Page-based navigation with offset/limit.", "priority": "must" },
            { "id": "cursor-based-pagination", "title": "Cursor-based", "description": "Use cursors (usually timestamps or IDs) to mark position: ?cursor=2023-01-15T10:30:00Z&limit=10. More efficient for large datasets as it uses indexed fields for seeking. Consistent results even when data changes during pagination. Use in response: {\"data\": [...], \"nextCursor\": \"2023-01-15T11:00:00Z\", \"hasMore\": true}. Perfect for real-time feeds, message threads, or large datasets. Downside: can't jump to arbitrary pages, total count is expensive. Choose for performance-critical APIs with large datasets.", "briefDescription": "Position-based navigation with cursors.", "priority": "imp" },
            { "id": "page-based-pagination", "title": "Page-based", "description": "Simple page numbers: ?page=3&per_page=20. Most intuitive for users, easy to implement pagination controls in UIs. Include page metadata: {\"data\": [...], \"page\": 3, \"per_page\": 20, \"total_pages\": 50, \"total_count\": 1000}. Good for search results, product catalogs, and user-facing interfaces where users need to jump between pages. Has same performance issues as offset-based for large offsets. Set reasonable limits on page size (max 100 items) to prevent abuse.", "briefDescription": "Human-friendly page number navigation.", "priority": "must" },
            { "id": "link-headers", "title": "Link Headers", "description": "Include pagination links in HTTP Link header following RFC 5988: Link: </api/users?page=1>; rel=\"first\", </api/users?page=3>; rel=\"next\", </api/users?page=5>; rel=\"last\". This keeps pagination metadata separate from response body. GitHub API is famous example. Useful for APIs consumed by sophisticated clients that parse HTTP headers. Less discoverable than response body links. Consider including both header and body links for maximum compatibility. Standard relations: first, prev, next, last.", "briefDescription": "HTTP header-based pagination links.", "priority": "imp" }
          ]
        },
        {
          "id": "api-documentation",
          "title": "API Documentation", 
          "description": "Comprehensive documentation is crucial for API adoption and developer experience. Good documentation includes examples, error cases, and interactive tools for exploration.",
          "briefDescription": "Essential API reference and exploration tools.",
          "priority": "must",
          "children": [
            { "id": "openapi-swagger", "title": "Swagger / OpenAPI", "description": "OpenAPI Specification (formerly Swagger) is the industry standard for REST API documentation. Define endpoints, request/response schemas, authentication, and examples in YAML/JSON format. Generate interactive documentation with Swagger UI where developers can test API calls directly. Auto-generate client SDKs and server stubs from specifications. Tools like swagger-jsdoc extract specs from code comments. Keep specs in sync with implementation through automation. OpenAPI enables API-first development and better team collaboration.", "briefDescription": "Industry standard API specification format.", "priority": "must" },
            { "id": "postman-collections", "title": "Postman Collections", "description": "Postman collections provide shareable API examples with pre-configured requests, environment variables, and test scripts. Developers can import collections and immediately start testing APIs. Include authentication setup, common request examples, and error scenarios. Use environment variables for different deployment stages (dev, staging, production). Collections serve as executable documentation - if examples work, documentation is current. Combine with automated testing to ensure examples stay valid.", "briefDescription": "Shareable API examples and testing.", "priority": "imp" },
            { "id": "api-blueprint", "title": "API Blueprint", "description": "Markdown-based API documentation format that's human-readable and machine-processable. Emphasizes examples and user stories alongside technical specifications. Good for API design discussions and stakeholder communication. Tools like Aglio generate HTML documentation from Blueprint files. Less tooling ecosystem than OpenAPI but more readable for non-technical stakeholders. Consider for APIs where design communication is important or when you prefer markdown workflow.", "briefDescription": "Markdown-based API documentation format.", "priority": "look" }
          ]
        },
        {
          "id": "api-versioning-strategy", 
          "title": "API Versioning",
          "description": "Version management strategy is critical for evolving APIs without breaking existing clients. Plan versioning approach from the beginning, even for internal APIs, as requirements always change over time.",
          "briefDescription": "Managing API evolution and backward compatibility.",
          "priority": "must",
          "children": [
            { "id": "versioning-strategies", "title": "Versioning Strategies", "description": "URL versioning (/v1/users) is most explicit and visible. Header versioning (API-Version: v1) keeps URLs clean but less discoverable. Query parameter versioning (?version=1) is simple but easily omitted. Media type versioning (Accept: application/vnd.api.v1+json) follows HTTP standards but complex. Choose one strategy consistently. URL versioning is most common for public APIs due to visibility. Consider semantic versioning (v1.2.3) for detailed change communication. Plan deprecation timeline and migration path from day one.", "briefDescription": "Different approaches to API version management.", "priority": "must" }
          ]
        },
        {
          "id": "rate-limiting-api",
          "title": "Rate Limiting",
          "description": "Protect APIs from abuse and ensure fair resource usage among clients. Rate limiting prevents denial-of-service attacks, maintains performance under load, and enables sustainable API scaling.",
          "briefDescription": "API usage control and abuse prevention.",
          "priority": "must", 
          "children": [
            { "id": "token-bucket", "title": "Token Bucket", "description": "Allow burst traffic by maintaining bucket of tokens that refill at steady rate. Client consumes tokens for requests - when bucket empty, requests are rejected. Good for APIs that need to allow occasional bursts (like batch operations) while maintaining average rate limits. Example: 100 tokens, refill 10/minute allows immediate burst of 100 requests followed by sustainable 10/minute. More complex to implement but provides better user experience for bursty workloads.", "briefDescription": "Burst-friendly rate limiting with token accumulation.", "priority": "imp" },
            { "id": "sliding-window", "title": "Sliding Window", "description": "Track requests within rolling time window - more accurate than fixed windows but computationally expensive. Maintains exact request count over past N seconds. Prevents end-of-window bursts that break spirit of rate limiting. Example: exactly 100 requests per 60-second window, not 100 per minute. Requires more memory and processing but provides smoothest rate limiting experience. Good for high-value APIs where precise control matters more than performance.", "briefDescription": "Precise rolling window rate calculation.", "priority": "imp" },
            { "id": "fixed-window", "title": "Fixed Window", "description": "Simple counter reset at regular intervals (per minute, hour, day). Easiest to implement and lowest resource usage. Problem: clients can double limits at window boundaries (99 requests at 10:59, 100 more at 11:00). Despite limitations, widely used due to simplicity and efficiency. Good for basic protection where perfect smoothing isn't critical. Include reset time in headers so clients can adjust behavior: X-RateLimit-Reset: 1609459200.", "briefDescription": "Simple periodic counter reset approach.", "priority": "must" }
          ]
        },
        {
          "id": "file-upload-apis",
          "title": "File Upload APIs",
          "description": "Handle file uploads efficiently and securely. Consider file size, type validation, storage location, and processing requirements when designing upload endpoints.",
          "briefDescription": "Secure and efficient file handling endpoints.",
          "priority": "imp",
          "children": [
            { "id": "multipart-form-data", "title": "Multipart/form-data", "description": "Standard encoding for file uploads, allows mixing files with text fields in single request. Use middleware like Multer (Node.js) to parse multipart data. Validate file types, sizes, and names to prevent security issues. Support progress tracking for large files. Example: POST /avatars with Content-Type: multipart/form-data containing file and metadata. Good for simple file uploads with form data, but can be memory-intensive for large files without streaming.", "briefDescription": "Standard form-based file upload encoding.", "priority": "must" },
            { "id": "streaming-uploads", "title": "Streaming", "description": "Process files as they upload without loading entirely into memory. Essential for large files or high-concurrency applications. Stream directly to cloud storage (S3, Google Cloud) to avoid local disk usage. Use libraries that support backpressure handling to prevent memory exhaustion. Example: pipe upload stream directly to cloud storage with progress callbacks. More complex but enables uploading files larger than server memory and better resource utilization.", "briefDescription": "Memory-efficient large file processing.", "priority": "imp" },
            { "id": "presigned-urls", "title": "Presigned URLs (S3)", "description": "Generate temporary URLs that allow clients to upload directly to cloud storage, bypassing your server entirely. Provide secure, limited-time access to specific S3 bucket locations. Client gets presigned URL from your API, then uploads directly to S3. Reduces server bandwidth, improves upload speed, and scales infinitely. Include content type restrictions and size limits in presigned URL policy. Perfect for user-generated content like photos, videos, or documents where server processing isn't needed.", "briefDescription": "Direct-to-cloud upload with temporary URLs.", "priority": "imp" }
          ]
        }
      ]
    }
    ,
    {
      "id": "graphql",
      "title": "GraphQL",
      "description": "GraphQL is a query language for APIs and a runtime for executing those queries with your existing data. Developed by Facebook and open-sourced in 2015, GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools. Unlike REST where you make multiple requests to different endpoints to fetch related data, GraphQL allows clients to request all needed data in a single query with precisely the fields they want. This eliminates over-fetching and under-fetching problems common in REST APIs. GraphQL is strongly typed, enabling powerful validation, auto-completion, and documentation generation. Understanding GraphQL is increasingly important for MERN stack developers as it's widely adopted by companies like GitHub, Shopify, and Airbnb for modern API development.",
      "briefDescription": "Query language for APIs with precise data fetching.",
      "priority": "must",
      "children": [
        {
          "id": "graphql-core-concepts",
          "title": "Core Concepts",
          "description": "GraphQL's core concepts define how you describe your data, request information, and modify state. The schema defines what data is available and how it's structured, while queries, mutations, and subscriptions define how clients interact with that data. Resolvers are the functions that actually fetch the data. Understanding these concepts is fundamental to working with GraphQL.",
          "briefDescription": "Fundamental GraphQL building blocks.",
          "priority": "must",
          "children": [
            { "id": "graphql-sdl", "title": "Schema Definition Language (SDL)", "description": "SDL is GraphQL's type system language for defining your API schema. It's a human-readable syntax that describes the structure of your data, the relationships between types, and the operations available. Example: 'type User { id: ID! name: String! email: String! posts: [Post!]! }' defines a User type with required ID, name, email, and a non-null list of posts. SDL is declarative and database-agnostic - you describe what data looks like, not how to fetch it. The schema serves as a contract between client and server, enabling powerful tooling like auto-completion, type checking, and documentation generation. Comments are written with # and descriptions with triple quotes. SDL files typically use .graphql or .gql extensions.", "briefDescription": "Type system language for schema definition.", "priority": "must" },
            { "id": "graphql-types", "title": "Types (Scalar, Object, Input, Enum, Union, Interface)", "description": "GraphQL has several type categories. Scalars are primitive types: Int, Float, String, Boolean, ID (unique identifier serialized as string). Object types represent complex objects with fields: 'type User { name: String }'. Input types are special object types used for mutation arguments: 'input CreateUserInput { name: String! email: String! }'. Enums define allowed values: 'enum Role { ADMIN USER GUEST }'. Unions represent one of several types: 'union SearchResult = User | Post | Comment'. Interfaces define shared fields that types must implement: 'interface Node { id: ID! }' then 'type User implements Node { id: ID! name: String }'. Each type serves a specific purpose and enables type safety throughout your API.", "briefDescription": "GraphQL type system components.", "priority": "must" },
            { "id": "graphql-queries", "title": "Queries", "description": "Queries are read operations in GraphQL, equivalent to GET requests in REST. Clients specify exactly which fields they want and can nest related data in a single request. Example: 'query { user(id: \"123\") { name email posts { title comments { text } } } }' fetches user with posts and comments in one request. Queries can have arguments for filtering, parameters for pagination, and aliases to rename fields in the response. You can request multiple root fields in one query and use fragments to reuse field selections. Queries are defined in the schema's Query type and executed by the GraphQL runtime which calls the appropriate resolvers. The ability to request exactly what you need eliminates over-fetching and reduces bandwidth usage significantly.", "briefDescription": "Read operations with precise field selection.", "priority": "must" },
            { "id": "graphql-mutations", "title": "Mutations", "description": "Mutations are write operations in GraphQL, equivalent to POST, PUT, PATCH, DELETE in REST. They modify server-side data and return the updated data. Example: 'mutation { createUser(input: { name: \"John\" email: \"john@example.com\" }) { id name email } }' creates a user and returns specified fields. Mutations are defined in the schema's Mutation type. Unlike queries which can execute in parallel, mutations in a single request execute sequentially to prevent race conditions. This guarantees order of execution which is crucial for dependent operations. Mutations should follow the pattern of taking input objects (using input types) and returning the modified resource plus any metadata like errors or success messages. Always return useful data from mutations to update client caches without additional queries.", "briefDescription": "Write operations that modify server data.", "priority": "must" },
            { "id": "graphql-subscriptions", "title": "Subscriptions", "description": "Subscriptions enable real-time updates by maintaining a persistent connection between client and server. When subscribed data changes, the server pushes updates to clients. Example: 'subscription { messageAdded(channelId: \"general\") { id text author { name } } }' receives real-time messages. Subscriptions are defined in the schema's Subscription type and typically use WebSockets for transport. They're perfect for chat applications, live dashboards, notifications, or any real-time feature. Implementation requires a pub/sub system (like Redis) for scaling across multiple servers. Subscriptions add complexity compared to queries/mutations but provide superior user experience for real-time features compared to polling. Be mindful of scaling challenges as each active subscription maintains an open connection.", "briefDescription": "Real-time data updates via persistent connections.", "priority": "imp" },
            { "id": "graphql-resolvers", "title": "Resolvers", "description": "Resolvers are functions that fetch the data for fields in your schema. Each field in your schema can have a resolver that returns that field's value. Resolvers receive four arguments: parent (the return value of the parent field's resolver), args (arguments provided to the field), context (shared across all resolvers, typically contains auth, database connections, etc.), and info (information about the execution state). Example: 'const resolvers = { Query: { user: (parent, { id }, context, info) => context.db.getUserById(id) }, User: { posts: (user) => db.getPostsByUserId(user.id) } }'. GraphQL calls resolvers in a cascading manner - the Query resolver runs first, then field resolvers for each requested field. This resolver chain enables efficient data loading and relationship traversal.", "briefDescription": "Functions that fetch data for schema fields.", "priority": "must" },
            { "id": "graphql-root-types", "title": "Root Types (Query, Mutation, Subscription)", "description": "Root types are the entry points into your GraphQL schema. The Query type defines all read operations available to clients: 'type Query { user(id: ID!): User users: [User!]! }'. The Mutation type defines all write operations: 'type Mutation { createUser(input: CreateUserInput!): User! updateUser(id: ID!, input: UpdateUserInput!): User }'. The Subscription type defines real-time subscriptions: 'type Subscription { messageAdded(channelId: ID!): Message! }'. These three types are special - they define what operations clients can perform. All other types in your schema are reachable through fields on these root types. A schema must have a Query type, while Mutation and Subscription types are optional. Root types organize your API's capabilities and serve as the top-level navigation for clients.", "briefDescription": "Entry point types for API operations.", "priority": "must" }
          ]
        },
        {
          "id": "graphql-schema-design",
          "title": "Schema Design",
          "description": "Good schema design is crucial for API evolution, client usability, and server performance. GraphQL's type system offers powerful tools for modeling data relationships, handling null values, and organizing schemas across teams. Understanding these patterns helps you design schemas that are both flexible and maintainable.",
          "briefDescription": "Patterns for effective schema structure.",
          "priority": "must",
          "children": [
            { "id": "graphql-type-relationships", "title": "Type Relationships", "description": "GraphQL excels at modeling relationships between data types. One-to-one: 'type User { profile: Profile }'. One-to-many: 'type User { posts: [Post!]! }'. Many-to-many: 'type Post { tags: [Tag!]! } type Tag { posts: [Post!]! }'. Self-referencing: 'type User { friends: [User!]! }'. Relationships are expressed through fields that return other types. Design relationships based on how clients will query data - nest related data that's frequently fetched together. Use connection patterns (edges/nodes/pageInfo) for paginated relationships. Be mindful of the N+1 problem where naive resolvers make separate database queries for each item in a list. Good schema design considers both data structure and query patterns to enable efficient data loading.", "briefDescription": "Modeling data connections between types.", "priority": "must" },
            { "id": "graphql-nullable", "title": "Nullable vs Non-Nullable", "description": "Fields in GraphQL are nullable by default - they can return null. The exclamation mark (!) makes fields non-nullable. 'name: String' can be null, 'name: String!' cannot. This applies to types in lists too: '[Post]' - list can be null, items can be null. '[Post]!' - list cannot be null but items can. '[Post!]' - list can be null but items cannot. '[Post!]!' - neither list nor items can be null. Non-nullable fields are a contract - GraphQL will return an error rather than null if the resolver fails. Use non-null for required fields (like user IDs) and nullable for optional fields (like profile bio). Over-using non-null makes schema rigid and can cause entire queries to fail; under-using it makes client code verbose with null checks. Balance based on data requirements and client needs.", "briefDescription": "Field nullability and type safety.", "priority": "must" },
            { "id": "graphql-lists", "title": "Lists & Non-Null Lists", "description": "Lists represent arrays of values in GraphQL. The syntax combines [] for lists with ! for non-null constraints: 'posts: [Post]' - can return null, empty array, or array with null items. 'posts: [Post]!' - cannot return null but can return empty array or array with nulls. 'posts: [Post!]' - can return null or empty array but array items cannot be null. 'posts: [Post!]!' - must return array (potentially empty) with non-null items. This granular control over nullability enables precise contracts between client and server. For required collections that might be empty, use [Type!]! to guarantee an array with non-null items. This eliminates defensive null checks in client code while allowing empty results. Lists in arguments work the same way and enable batch operations like 'deleteUsers(ids: [ID!]!): Boolean'.", "briefDescription": "Array types with nullability control.", "priority": "imp" },
            { "id": "graphql-custom-scalars", "title": "Custom Scalars", "description": "Beyond built-in scalars (Int, Float, String, Boolean, ID), you can define custom scalar types for domain-specific data. Common examples: DateTime for timestamps, Email for validated emails, URL for web addresses, JSON for arbitrary JSON data, Upload for file uploads. Define with 'scalar DateTime' in schema, then implement serialization, deserialization, and validation: 'const dateTimeScalar = new GraphQLScalarType({ name: \"DateTime\", parseValue(value) { return new Date(value); }, serialize(value) { return value.toISOString(); }, parseLiteral(ast) { return new Date(ast.value); } })'. Custom scalars enable type safety for special data formats, provide validation at the schema level, and improve API documentation. Use libraries like graphql-scalars for common types rather than implementing from scratch.", "briefDescription": "Domain-specific primitive types.", "priority": "imp" },
            { "id": "graphql-directives", "title": "Directives (@deprecated, @skip, @include)", "description": "Directives provide a way to modify query execution or schema behavior. Built-in directives: @deprecated(reason: String) marks fields as outdated with migration guidance. @skip(if: Boolean) excludes field from results if argument is true. @include(if: Boolean) includes field only if true. Example: 'query($withEmail: Boolean!) { user { name email @include(if: $withEmail) } }' conditionally fetches email. Custom directives can implement authorization, formatting, caching, or other cross-cutting concerns: '@auth(requires: ADMIN)' or '@cacheControl(maxAge: 3600)'. Directives enable declarative field-level behavior without polluting resolver logic. They're powerful for schema evolution (deprecating fields gradually) and dynamic queries (conditional field inclusion based on permissions or client capabilities).", "briefDescription": "Modifiers for schema and query behavior.", "priority": "imp" },
            { "id": "graphql-schema-stitching", "title": "Schema Stitching", "description": "Schema stitching combines multiple GraphQL schemas into one unified schema. This enables a microservices architecture where each service has its own GraphQL schema, but clients interact with a single API gateway. Example: User service has user schema, Product service has product schema, gateway stitches them together and adds relationships. Stitching involves merging type definitions, combining resolvers, and potentially adding new fields that span services. Challenges include handling type conflicts, maintaining consistent error handling, and managing schema versions across services. Tools like Apollo Federation or GraphQL Tools provide stitching capabilities. Modern approach favors Federation over stitching for clearer ownership and better distributed schema management.", "briefDescription": "Combining multiple schemas into one.", "priority": "look" },
            { "id": "graphql-federation", "title": "Federation", "description": "Apollo Federation is a modern approach to distributed GraphQL architecture where multiple services own portions of the schema. Each service (subgraph) defines its types with @key directive for entities: 'type User @key(fields: \"id\") { id: ID! name: String }'. Other services can extend entities: 'extend type User @key(fields: \"id\") { id: ID! @external posts: [Post!]! }'. The Apollo Gateway composes subgraphs into a single unified schema (supergraph). Federation enables true microservices where teams own their domains, schemas evolve independently, and the gateway handles query planning across services. It solves schema stitching problems with clear entity ownership, type-safe extensions, and optimized query execution. Essential for large organizations with multiple teams building GraphQL APIs.", "briefDescription": "Distributed schema architecture pattern.", "priority": "imp" }
          ]
        },
        {
          "id": "graphql-resolvers-advanced",
          "title": "Resolvers",
          "description": "Resolvers are where GraphQL meets your business logic and data sources. Understanding resolver arguments, chaining, optimization, and error handling is crucial for building performant GraphQL APIs. Advanced resolver patterns prevent common pitfalls like the N+1 query problem.",
          "briefDescription": "Advanced resolver implementation patterns.",
          "priority": "must",
          "children": [
            { "id": "resolver-arguments", "title": "Resolver Arguments (parent, args, context, info)", "description": "Every GraphQL resolver receives four arguments. 'parent' (also called 'root' or 'source') contains the return value of the parent field's resolver - this is how data flows down the resolver chain. 'args' contains the arguments provided in the query for this field. 'context' is shared across all resolvers in a request - use it for authentication, database connections, data loaders, and any request-scoped data. 'info' contains information about the execution state including the query AST, schema, and field path - useful for advanced optimizations. Example: 'const resolver = { Query: { user: (parent, args, context, info) => { const userId = args.id; const user = await context.db.findUser(userId); return user; } } }'. Understanding these arguments is fundamental to implementing resolvers correctly and efficiently.", "briefDescription": "Four parameters passed to resolver functions.", "priority": "must" },
            { "id": "resolver-chains", "title": "Resolver Chains", "description": "GraphQL resolvers execute in a cascading chain, with parent resolvers' return values becoming the first argument to child resolvers. Example: Query.user resolver returns { id: 1, name: 'John' }, then User.posts resolver receives that object as parent and can access parent.id to fetch posts. This chain continues for nested fields: User.posts returns posts array, then Post.author resolver runs for each post. Understanding resolver chains is crucial for efficient data loading - you can attach data at parent level and access it in child resolvers without additional queries. Resolver chains enable GraphQL's flexibility but require careful design to avoid performance problems. Default resolvers automatically return matching properties from parent object if no explicit resolver is defined.", "briefDescription": "Cascading execution from parent to child.", "priority": "must" },
            { "id": "dataloader", "title": "DataLoader (N+1 Problem)", "description": "The N+1 problem occurs when resolvers make separate database queries for each item in a list. Example: fetching 100 users, then querying posts for each user = 101 queries. DataLoader solves this by batching and caching requests. Instead of 100 separate getUserPosts(userId) calls, DataLoader batches them into one getUserPosts([userId1, userId2, ...]) call. Implementation: 'const userLoader = new DataLoader(async (userIds) => { const users = await db.getUsersByIds(userIds); return userIds.map(id => users.find(u => u.id === id)); }); context.loaders = { user: userLoader }; // In resolver: const user = await context.loaders.user.load(userId)'. DataLoader also provides per-request caching to prevent fetching the same data multiple times. Essential for production GraphQL APIs to maintain performance.", "briefDescription": "Batching and caching to solve N+1 queries.", "priority": "must" },
            { "id": "auth-in-resolvers", "title": "Authentication in Resolvers", "description": "Implement authentication and authorization in resolvers or directive-based middleware. Common pattern: authenticate in context creation, authorize in resolvers. Example: 'const server = new ApolloServer({ context: ({ req }) => { const token = req.headers.authorization; const user = verifyToken(token); return { user, db }; }, resolvers: { Query: { secretData: (parent, args, context) => { if (!context.user) throw new AuthenticationError(\"Not authenticated\"); if (context.user.role !== \"ADMIN\") throw new ForbiddenError(\"Not authorized\"); return fetchSecretData(); } } })'. For field-level auth, check permissions before returning data. Consider GraphQL Shield or custom directives for declarative authorization: '@auth(requires: ADMIN)'. Put authentication (who are you) in context, authorization (what can you do) in resolvers or directives.", "briefDescription": "Securing resolvers with auth checks.", "priority": "must" },
            { "id": "resolver-error-handling", "title": "Error Handling", "description": "GraphQL returns partial data with errors array when fields fail. Throw errors in resolvers: 'throw new GraphQLError(\"User not found\", { extensions: { code: \"USER_NOT_FOUND\", userId } })'. Apollo Server provides error classes: UserInputError, AuthenticationError, ForbiddenError. Extensions add metadata to errors for client handling. Errors in non-nullable fields bubble up - if User.email! fails, entire User object becomes null; if Query.user! fails, entire query fails. This makes error handling strict but predictable. Global error handling: 'new ApolloServer({ formatError: (error) => { logError(error); if (error.message.includes(\"database\")) return new Error(\"Internal error\"); return error; } })'. Don't expose sensitive information in production. Use error codes for programmatic handling and user-friendly messages for display.", "briefDescription": "GraphQL error patterns and handling.", "priority": "must" }
          ]
        },
        {
          "id": "apollo-server",
          "title": "Apollo Server",
          "description": "Apollo Server is the most popular GraphQL server implementation for Node.js. It provides production-ready features like schema stitching, subscriptions, caching, error handling, and developer tools. Understanding Apollo Server is essential for building GraphQL APIs in the MERN stack.",
          "briefDescription": "Production GraphQL server for Node.js.",
          "priority": "must",
          "children": [
            { "id": "apollo-express-setup", "title": "Setup with Express", "description": "Integrate Apollo Server with Express for full control over middleware and routing. Example: 'const { ApolloServer } = require(\"apollo-server-express\"); const express = require(\"express\"); const app = express(); const server = new ApolloServer({ typeDefs, resolvers }); await server.start(); server.applyMiddleware({ app, path: \"/graphql\" }); app.listen(4000);'. This setup allows adding Express middleware for authentication, logging, file uploads, etc. Apollo Server handles GraphQL execution while Express handles HTTP concerns. Use apollo-server-express for existing Express apps or apollo-server for standalone GraphQL servers. Integration enables combining REST and GraphQL endpoints, using Express middleware ecosystem, and gradual migration from REST to GraphQL.", "briefDescription": "Integrate Apollo Server with Express.", "priority": "must" },
            { "id": "apollo-sandbox", "title": "Apollo Sandbox", "description": "Apollo Sandbox is a modern GraphQL IDE accessible in the browser. When Apollo Server runs in development mode, navigate to the server URL to access Sandbox. Features include: interactive schema exploration with auto-complete, query building with documentation, variables editor, response visualization, operation history, and sharing queries via URL. Sandbox replaces the older GraphQL Playground. It provides better UX, embedded documentation from schema descriptions, real-time schema updates, and connection to Apollo Studio for production monitoring. Essential tool for API development and testing. Configure with 'new ApolloServer({ introspection: true, playground: false }) for production (disable introspection in prod).", "briefDescription": "Interactive GraphQL development IDE.", "priority": "imp" },
            { "id": "apollo-context", "title": "Context Function", "description": "Context function runs for every request and creates context object shared across all resolvers. Use for authentication, database connections, data loaders, and request-scoped utilities. Example: 'new ApolloServer({ context: async ({ req }) => { const token = req.headers.authorization || \"\"; const user = await getUserFromToken(token); return { user, db: database, loaders: createLoaders() }; } })'. Context can be async, allowing database calls or external API requests. Access in resolvers via third parameter: '(parent, args, context) => context.db.query()'. Context is created per-request ensuring isolation between concurrent requests. Essential pattern for dependency injection in GraphQL. Put everything resolvers need here rather than importing directly - improves testability.", "briefDescription": "Request-scoped data for all resolvers.", "priority": "must" },
            { "id": "apollo-plugins", "title": "Plugins", "description": "Apollo Server plugins hook into the request lifecycle for logging, tracing, caching, and custom behavior. Example: 'const server = new ApolloServer({ plugins: [{ requestDidStart(requestContext) { console.log(\"Request started\"); return { didEncounterErrors(requestContext) { console.error(requestContext.errors); }, willSendResponse(requestContext) { console.log(\"Sending response\"); } }; } }] })'. Built-in plugins: ApolloServerPluginLandingPageGraphQLPlayground for Playground UI, ApolloServerPluginUsageReporting for Apollo Studio metrics. Custom plugins enable request tracing, performance monitoring, authentication logging, and integrations with APM tools. Plugins have access to request context, schema, and execution phases. Powerful for cross-cutting concerns without polluting resolver logic.", "briefDescription": "Request lifecycle hooks and extensions.", "priority": "imp" }
          ]
        },
        {
          "id": "apollo-client",
          "title": "Apollo Client",
          "description": "Apollo Client is a comprehensive state management library for JavaScript that enables you to manage both local and remote data with GraphQL. It's the most popular GraphQL client for React applications, providing intelligent caching, optimistic UI updates, and seamless integration with React hooks.",
          "briefDescription": "GraphQL client with intelligent caching.",
          "priority": "must",
          "children": [
            { "id": "apollo-cache", "title": "InMemoryCache", "description": "InMemoryCache is Apollo Client's normalized caching system. It stores query results in a flat lookup table by type and ID, enabling automatic cache updates when data changes. Configuration: 'const cache = new InMemoryCache({ typePolicies: { Query: { fields: { users: { merge(existing, incoming) { return incoming; } } } }, User: { keyFields: [\"id\"] } } })'. Cache normalizes data automatically - if multiple queries return the same user, it's stored once. Updates to cached data automatically update all components using that data. TypePolicies customize caching behavior per type. KeyFields determine cache ID (defaults to id or _id). InMemoryCache eliminates redundant network requests and provides instant UI updates for cached data. Understanding cache behavior is crucial for optimal Apollo Client usage.", "briefDescription": "Normalized data caching system.", "priority": "must" },
            { "id": "apollo-hooks", "title": "useQuery, useMutation, useSubscription", "description": "React hooks for GraphQL operations. useQuery: 'const { data, loading, error } = useQuery(GET_USER, { variables: { id: \"1\" } })' fetches data on mount, handles loading/error states, and caches results. useMutation: 'const [createUser, { data, loading, error }] = useMutation(CREATE_USER)' returns function to trigger mutation. Call with 'createUser({ variables: { input: {...} } })'. useSubscription: 'const { data } = useSubscription(MESSAGE_ADDED)' maintains WebSocket connection for real-time updates. Hooks integrate with React rendering - component re-renders when data changes. Features include automatic refetching, polling, optimistic responses, and cache updates. Hooks make GraphQL feel native to React components. They handle complex async states so you focus on UI logic.", "briefDescription": "React hooks for GraphQL operations.", "priority": "must" },
            { "id": "cache-policies", "title": "Cache Policies (cache-first, network-only, cache-and-network)", "description": "Fetch policies control how Apollo Client uses cache. 'cache-first' (default) returns cached data if available, otherwise fetches from network - best for data that doesn't change often. 'network-only' always fetches from network, updates cache but doesn't read from it - use for critical real-time data. 'cache-and-network' returns cached data immediately then fetches from network updating cache and component - best UX for frequently changing data. 'no-cache' never uses cache - for one-off queries. 'cache-only' only reads from cache, errors if not present - offline functionality. Example: 'useQuery(GET_USER, { fetchPolicy: \"cache-and-network\" })'. Choose policy based on data freshness requirements and user experience. Default cache-first is good for most cases.", "briefDescription": "Control cache vs network data fetching.", "priority": "must" },
            { "id": "optimistic-ui", "title": "Optimistic UI", "description": "Optimistic UI immediately updates UI as if mutation succeeded, then reconciles with server response. Provides instant feedback and perceived performance. Example: 'useMutation(CREATE_POST, { optimisticResponse: { createPost: { __typename: \"Post\", id: \"temp-id\", title: input.title, content: input.content } }, update: (cache, { data }) => { const existing = cache.readQuery({ query: GET_POSTS }); cache.writeQuery({ query: GET_POSTS, data: { posts: [...existing.posts, data.createPost] } }); } })'. Optimistic response uses temporary data, update function modifies cache. When server responds, Apollo replaces optimistic data with real data. If mutation fails, Apollo rolls back cache changes. Critical for responsive UIs in social apps, todo lists, or any frequent mutations.", "briefDescription": "Instant UI updates before server confirms.", "priority": "imp" },
            { "id": "local-state", "title": "Local State Management", "description": "Apollo Client can manage local state alongside remote GraphQL data, eliminating need for Redux or Context API in many cases. Define local-only fields with @client directive: 'query GetCart { cart @client { items { id name } } }'. Implement with reactive variables or field policies: 'const cartVar = makeVar([]); const cache = new InMemoryCache({ typePolicies: { Query: { fields: { cart: { read() { return cartVar(); } } } } } })'. Local state uses same API as remote data - useQuery, mutations, cache updates. This unifies state management under GraphQL. Good for UI state, user preferences, or derived data. For complex local state, consider dedicated state management. Apollo excels when local and remote data interact frequently.", "briefDescription": "Manage local state with GraphQL.", "priority": "imp" },
            { "id": "apollo-pagination", "title": "Pagination (fetchMore, cursor-based)", "description": "Apollo Client supports multiple pagination patterns. fetchMore loads additional pages: 'const { data, fetchMore } = useQuery(GET_POSTS, { variables: { limit: 10, offset: 0 } }); // Later: fetchMore({ variables: { offset: data.posts.length } })'. Cursor-based pagination uses cursors for efficient loading: 'query GetPosts($after: String) { posts(first: 10, after: $after) { edges { node { id title } cursor } pageInfo { hasNextPage endCursor } } }'. Configure field policy for automatic merge: 'typePolicies: { Query: { fields: { posts: { keyArgs: false, merge(existing = [], incoming) { return [...existing, ...incoming]; } } } } }'. Apollo handles merging new results into cache. Pagination is crucial for performance with large datasets. Choose pattern based on data characteristics.", "briefDescription": "Load additional data pages efficiently.", "priority": "must" }
          ]
        },
        {
          "id": "graphql-vs-rest",
          "title": "Comparison with REST",
          "description": "Understanding when to use GraphQL versus REST helps you choose the right tool for each project. GraphQL excels in certain scenarios while REST remains superior for others. Both have their place in modern web development.",
          "briefDescription": "GraphQL and REST trade-offs.",
          "priority": "must",
          "children": [
            { "id": "over-under-fetching", "title": "Over-fetching & Under-fetching", "description": "Over-fetching: REST endpoints return fixed data structures, often including fields clients don't need. Fetching /users returns id, name, email, avatar, bio, createdAt even if you only need name. This wastes bandwidth and processing. Under-fetching: REST requires multiple requests for related data. Fetching user posts requires /users/123 then /users/123/posts then /posts/456/comments. Each request has latency overhead. GraphQL solves both: clients request exactly what they need in one request - 'query { user(id: 123) { name posts { title } } }'. This is GraphQL's killer feature, especially for mobile apps on slow networks where every byte and round trip matters. REST can optimize with custom endpoints but lacks GraphQL's flexibility.", "briefDescription": "GraphQL requests exactly what's needed.", "priority": "must" },
            { "id": "when-graphql", "title": "When to Use GraphQL", "description": "Use GraphQL when: you have complex interconnected data (social networks, e-commerce), multiple client types with different data needs (web, mobile, IoT), rapidly evolving product requirements (GraphQL changes don't break existing clients), bandwidth and latency are critical (mobile apps), you want strong typing and auto-generated documentation, teams work on frontend and backend simultaneously (schema as contract), you need fine-grained field-level permissions, or you're building developer-facing APIs (GitHub, Shopify). GraphQL shines with graph-like data, diverse clients, and evolving requirements. The learning curve and complexity are worth it for these scenarios. Companies like Facebook, GitHub, and Shopify bet on GraphQL for good reasons.", "briefDescription": "Ideal GraphQL use cases.", "priority": "must" },
            { "id": "when-rest", "title": "When to Stay with REST", "description": "Use REST when: you have simple CRUD operations with predictable access patterns, heavy reliance on HTTP caching (CDNs, browser caches work better with REST), file uploads/downloads are primary use case (GraphQL file handling is complex), team lacks GraphQL experience and timeline is tight, you need mature tooling ecosystem for specific use cases, bandwidth optimization isn't critical, microservices with clear boundaries (each service's REST API). REST is simpler to understand, has decades of tooling, integrates seamlessly with HTTP infrastructure, and works great for resource-oriented APIs. Don't use GraphQL just because it's trendy. For simple APIs or pure CRUD apps, REST's simplicity often wins. You can also use both - GraphQL for complex queries, REST for file uploads or webhook receivers.", "briefDescription": "When REST is the better choice.", "priority": "must" }
          ]
        }
      ]
    }
    ,
    {
      "id": "testing",
      "title": "Testing",
      "description": "Testing is fundamental to building reliable, maintainable software. A comprehensive testing strategy catches bugs early, enables confident refactoring, serves as living documentation, and improves code design. The MERN stack requires testing at multiple levels: unit tests for business logic, integration tests for API endpoints and database interactions, component tests for React UIs, and end-to-end tests for critical user flows. Modern JavaScript testing evolved from frameworks like Mocha and Jasmine to the current ecosystem dominated by Jest for unit/integration testing, React Testing Library for component testing, and Cypress/Playwright for E2E testing. Understanding testing philosophies (TDD, BDD), test organization, mocking strategies, and appropriate test coverage helps you build robust applications. Good tests run fast, are deterministic, test behavior not implementation, and provide clear failure messages. Interviewers assess not just whether you write tests, but whether you understand what and how to test effectively.",
      "briefDescription": "Comprehensive testing strategies for MERN applications.",
      "priority": "must",
      "children": [
        {
          "id": "testing-fundamentals",
          "title": "Testing Fundamentals",
          "description": "Understanding different test types, methodologies, and metrics forms the foundation of effective testing. Each testing level serves a specific purpose in your quality assurance strategy, from fast unit tests that verify individual functions to comprehensive E2E tests that validate entire user journeys.",
          "briefDescription": "Core testing concepts and methodologies.",
          "priority": "must",
          "children": [
            { "id": "unit-testing", "title": "Unit Testing", "description": "Unit tests verify individual functions, methods, or components in isolation. They're the foundation of test pyramids - fast, numerous, and focused on single units of behavior. Test pure functions, business logic, utility functions, and isolated components. Example: testing a calculateTotal() function with different inputs, edge cases, and error conditions. Unit tests avoid external dependencies like databases, APIs, or file systems by using mocks and stubs. Benefits: rapid execution (milliseconds), pinpoint failures to specific code, enable fearless refactoring, serve as executable documentation. Write unit tests first for critical business logic. Aim for high coverage of complex algorithms, edge cases, and error paths. Keep tests focused - one assertion per test when possible. Unit tests should be deterministic and independent - same input always produces same output, any order execution works.", "briefDescription": "Test individual functions in isolation.", "priority": "must" },
            { "id": "integration-testing", "title": "Integration Testing", "description": "Integration tests verify how multiple components work together. Test interactions between modules, API endpoints with databases, service integrations, and component compositions. Example: testing Express route that queries MongoDB and returns formatted JSON. Integration tests use real dependencies or test doubles that behave like production systems. Benefits: catch interface mismatches, verify correct data flow between layers, test actual database queries and transactions, validate API contracts. Trade-offs: slower than unit tests, require setup/teardown, more brittle to changes. Use integration tests for critical paths - user authentication, payment processing, data persistence. Test database constraints, transaction rollbacks, and error conditions. Integration tests bridge the gap between pure unit tests and expensive E2E tests.", "briefDescription": "Test component interactions and integrations.", "priority": "must" },
            { "id": "e2e-testing", "title": "End-to-End Testing", "description": "E2E tests simulate real user scenarios from start to finish in a browser environment. They click buttons, fill forms, navigate pages, and verify outcomes exactly as users would. Example: complete signup flow - fill registration form, submit, verify email sent, click confirmation link, login, verify dashboard. E2E tests run against the full application stack including frontend, backend, database, and external services. Benefits: highest confidence that features work for real users, catch issues unit/integration tests miss (CSS hiding buttons, race conditions, cross-browser issues). Drawbacks: slowest tests (seconds to minutes), most brittle to UI changes, harder to debug failures, expensive to maintain. Reserve E2E tests for critical user journeys and happy paths. Keep E2E test count low but coverage high for business value. Use them as smoke tests for deployments.", "briefDescription": "Test complete user flows in browser.", "priority": "must" },
            { "id": "tdd", "title": "Test-Driven Development (TDD)", "description": "TDD is a development methodology where you write tests before writing implementation code. The cycle: Red (write failing test) → Green (write minimal code to pass) → Refactor (improve code while keeping tests green). Example: write test for addUser(email), see it fail, implement addUser, verify test passes, refactor for edge cases. TDD benefits: prevents over-engineering, ensures all code is tested, improves design through testability thinking, provides immediate feedback, creates comprehensive test suite organically. TDD forces you to define behavior before implementation, leading to clearer APIs and better separation of concerns. Challenges: initial slowdown, requires discipline, not suitable for all scenarios (exploratory coding, prototypes). Best for: well-understood requirements, bug fixes (write failing test reproducing bug), refactoring existing code, libraries and frameworks.", "briefDescription": "Write tests before implementation code.", "priority": "imp" },
            { "id": "bdd", "title": "Behavior-Driven Development (BDD)", "description": "BDD extends TDD with natural language specifications that describe expected behavior. Tests are written in Given-When-Then format readable by non-technical stakeholders. Example: 'Given user is logged in, When user clicks logout, Then user is redirected to homepage and session is cleared'. Tools like Cucumber enable BDD with feature files. Benefits: shared understanding between developers, testers, and product owners; tests serve as living documentation; focuses on user value over technical implementation. BDD scenarios become acceptance criteria. Structure: Given (setup/context), When (action/trigger), Then (expected outcome). BDD is valuable for complex domains where communication between technical and non-technical team members is crucial. Overhead makes it less suitable for simple applications or internal tools.", "briefDescription": "Specification-based testing with natural language.", "priority": "imp" },
            { "id": "testing-pyramid", "title": "Testing Pyramid", "description": "The testing pyramid is a strategy for balancing test types: broad base of unit tests (70%), moderate integration tests (20%), narrow top of E2E tests (10%). Rationale: unit tests are fast and cheap; E2E tests are slow and expensive. Pyramid shape ensures fast feedback and manageable test suite. Anti-pattern is inverted pyramid (ice cream cone) - few unit tests, many E2E tests leads to slow CI pipelines, flaky tests, high maintenance. Modern variations include testing diamond (more integration tests) or testing trophy (emphasized integration). Choose based on architecture: microservices favor more integration tests, monoliths can use traditional pyramid. Key principle: write tests at the lowest level that gives confidence. Don't test implementation details with E2E when unit tests suffice.", "briefDescription": "Test distribution strategy across levels.", "priority": "must" },
            { "id": "test-coverage", "title": "Test Coverage", "description": "Code coverage measures percentage of code executed during tests. Metrics: line coverage (lines run), branch coverage (conditional paths taken), function coverage (functions called), statement coverage (statements executed). Tools like Jest provide coverage reports with --coverage flag showing covered/uncovered lines. High coverage (80-100%) indicates thorough testing but doesn't guarantee quality - you can have 100% coverage with poor assertions. Coverage reveals untested code but not missing tests for edge cases. Use coverage to find blind spots, not as quality metric. Focus on critical paths, complex logic, and error handling. Don't chase 100% - some code (generated code, simple getters, configuration) doesn't merit tests. Coverage is a tool, not a goal. Meaningful tests matter more than coverage percentages.", "briefDescription": "Measure code execution during tests.", "priority": "imp" }
          ]
        },
        {
          "id": "jest",
          "title": "Jest",
          "description": "Jest is a delightful JavaScript testing framework by Facebook, designed for simplicity and comprehensive features. It's the de facto standard for testing React applications and Node.js backends. Jest provides test runner, assertion library, mocking capabilities, coverage reporting, and snapshot testing in one package. Zero configuration for most projects, parallel test execution for speed, built-in code coverage, and intelligent watch mode make Jest developer-friendly. Understanding Jest thoroughly is essential for MERN stack testing.",
          "briefDescription": "Comprehensive JavaScript testing framework.",
          "priority": "must",
          "children": [
            { "id": "jest-structure", "title": "Test Structure (describe, it, test)", "description": "Jest organizes tests with describe blocks (test suites) and it/test blocks (individual tests). 'describe(\"Calculator\", () => { it(\"adds numbers\", () => { expect(add(2, 3)).toBe(5); }); it(\"subtracts numbers\", () => { expect(subtract(5, 2)).toBe(3); }); });'. describe groups related tests and can be nested for hierarchical organization. it and test are aliases - use whichever reads better ('it should...', 'test that...'). Descriptive names are crucial - test names should describe expected behavior, not implementation. Good: 'returns 404 when user not found'. Bad: 'test getUserById'. Use describe.only/it.only to run specific tests during development. Use describe.skip/it.skip to temporarily disable tests. Proper structure makes test output readable and failures easy to locate.", "briefDescription": "Organize tests with describe and it blocks.", "priority": "must" },
            { "id": "jest-assertions", "title": "Assertions (expect, toBe, toEqual, toContain, toThrow, toHaveBeenCalled)", "description": "Jest assertions verify expected outcomes. expect(value) creates assertion object. Matchers define expectations: toBe(value) - strict equality (===), for primitives. toEqual(value) - deep equality, for objects/arrays. toBeNull(), toBeUndefined(), toBeDefined(), toBeTruthy(), toBeFalsy() - value checks. toBeGreaterThan(num), toBeLessThan(num) - numeric comparisons. toContain(item) - array/string includes item. toMatch(/regex/) - string pattern matching. toThrow(error) - function throws error. toHaveBeenCalled(), toHaveBeenCalledWith(args) - mock function assertions. not inverts matchers: expect(value).not.toBe(other). Assertions read like English making tests self-documenting. Chain matchers for complex assertions. Custom matchers extend Jest for domain-specific assertions.", "briefDescription": "Verify expected test outcomes.", "priority": "must" },
            { "id": "jest-lifecycle", "title": "Setup & Teardown (beforeAll, beforeEach, afterAll, afterEach)", "description": "Lifecycle hooks manage test state. beforeAll runs once before all tests in describe block - use for expensive setup like database connection. beforeEach runs before each test - use for resetting state, creating fresh instances. afterEach runs after each test - use for cleanup, clearing mocks. afterAll runs once after all tests - use for closing connections, cleaning up resources. Example: 'beforeEach(() => { database = createTestDatabase(); }); afterEach(() => { database.clear(); });'. Hooks run in order: beforeAll → beforeEach → test → afterEach → afterAll. Nested describe blocks inherit parent hooks. Lifecycle hooks ensure test isolation - each test starts with clean state. Proper cleanup prevents test pollution where one test affects another. Critical for reliable, deterministic tests.", "briefDescription": "Manage test state with lifecycle hooks.", "priority": "must" },
            {
              "id": "jest-mocking",
              "title": "Mocking",
              "description": "Mocking replaces real dependencies with controlled substitutes for isolated testing. Jest provides powerful mocking capabilities essential for unit testing complex systems.",
              "briefDescription": "Control dependencies in tests.",
              "priority": "must",
              "children": [
                { "id": "jest-fn", "title": "jest.fn()", "description": "jest.fn() creates mock function to track calls and control return values. Basic: 'const mockFn = jest.fn(); mockFn(); expect(mockFn).toHaveBeenCalled();'. With return value: 'const mockFn = jest.fn(() => 42); expect(mockFn()).toBe(42);'. Track calls: 'mockFn(\"arg1\", \"arg2\"); expect(mockFn).toHaveBeenCalledWith(\"arg1\", \"arg2\"); expect(mockFn.mock.calls.length).toBe(1);'. Mock implementations: 'mockFn.mockReturnValue(value)', 'mockFn.mockResolvedValue(value)' for promises, 'mockFn.mockImplementation(fn)' for custom logic. Access call data: mockFn.mock.calls, mockFn.mock.results. Reset between tests: mockFn.mockClear() (clears calls), mockFn.mockReset() (clears and removes implementation). Mock functions enable testing without dependencies and verifying interactions.", "briefDescription": "Create trackable mock functions.", "priority": "must" },
                { "id": "jest-mock", "title": "jest.mock()", "description": "jest.mock() mocks entire modules. Automatically mocks all exports: 'jest.mock(\"axios\"); // All axios methods become jest.fn()'. Partial mock with implementation: 'jest.mock(\"./userService\", () => ({ getUser: jest.fn(() => ({ id: 1, name: \"Test\" })), __esModule: true }));'. Mock modules before importing: jest.mock runs before imports due to hoisting. Access and manipulate mocked modules: 'import { getUser } from \"./userService\"; getUser.mockResolvedValue({ id: 2 });'. Clear between tests: jest.clearAllMocks() in beforeEach. Mock modules enable testing components without real API calls, database queries, or external services. Essential for fast, reliable unit tests.", "briefDescription": "Mock entire module dependencies.", "priority": "must" },
                { "id": "jest-spyon", "title": "jest.spyOn()", "description": "jest.spyOn() mocks methods while preserving original implementation. Spy on object methods: 'const spy = jest.spyOn(object, \"method\"); object.method(); expect(spy).toHaveBeenCalled(); spy.mockRestore();'. Override implementation: 'jest.spyOn(Math, \"random\").mockReturnValue(0.5);'. Useful for: testing that functions call other functions, controlling non-deterministic behavior (Date.now, Math.random), verifying side effects. Unlike jest.mock which replaces entire modules, spyOn targets specific methods. Restore original: spy.mockRestore() or jest.restoreAllMocks(). SpyOn is perfect for partial mocking where most of module stays real but specific methods need control.", "briefDescription": "Spy on and mock specific methods.", "priority": "imp" },
                { "id": "jest-manual-mocks", "title": "Manual Mocks", "description": "Manual mocks provide custom implementations for modules. Create __mocks__ folder next to node_modules or module: '__mocks__/axios.js' contains mock axios implementation. Manual mocks activate automatically when jest.mock(\"axios\") is called. Useful for: complex modules needing sophisticated mocks, consistent mocks across many tests, mocking node modules. Example manual mock: 'module.exports = { get: jest.fn(() => Promise.resolve({ data: {} })), post: jest.fn(() => Promise.resolve({ data: {} })) };'. Manual mocks reduce boilerplate when many tests need similar mocking. Keep manual mocks simple and focused on testing needs.", "briefDescription": "Custom module mock implementations.", "priority": "imp" },
                { "id": "jest-module-mocking", "title": "Module Mocking", "description": "Mocking strategies for different module types. ES6 modules: jest.mock works with import/export. CommonJS: works with require. Mocking defaults vs named exports: 'jest.mock(\"module\", () => ({ default: mockDefault, namedExport: mockNamed }));'. Mocking constants and utilities: often better to use real implementations unless costly. Mocking constructors: 'jest.mock(\"./Database\", () => { return jest.fn().mockImplementation(() => ({ query: jest.fn() })); });'. Hoisting: jest.mock statements hoist to top automatically. Factory functions enable dynamic mocks. Understanding module mocking enables isolating units completely - test business logic without databases, APIs, file systems, or other external dependencies.", "briefDescription": "Strategies for different module types.", "priority": "imp" }
              ]
            },
            {
              "id": "jest-async",
              "title": "Async Testing",
              "description": "JavaScript's async nature requires special testing patterns. Jest provides multiple ways to test promises, callbacks, and async/await code correctly.",
              "briefDescription": "Test asynchronous code patterns.",
              "priority": "must",
              "children": [
                { "id": "jest-done-callback", "title": "done Callback", "description": "done callback signals async test completion. Jest passes done to test: 'test(\"async with callback\", (done) => { fetchData((data) => { expect(data).toBe(\"value\"); done(); }); });'. Call done() when assertions complete. Test waits until done() or timeout (5s default). Call done.fail(error) to fail test. Legacy pattern for callback-based code. Modern code prefers promises or async/await. Common mistake: forgetting done() causes test to pass incorrectly or timeout. Use done for testing libraries that only provide callbacks, otherwise prefer promise-based patterns.", "briefDescription": "Signal completion for callback tests.", "priority": "imp" },
                { "id": "jest-promises", "title": "Promises", "description": "Test promises by returning them from test: 'test(\"fetches data\", () => { return fetchData().then(data => { expect(data).toBe(\"value\"); }); });'. Must return promise or Jest won't wait. Alternative with resolves matcher: 'test(\"fetches data\", () => { return expect(fetchData()).resolves.toBe(\"value\"); });'. Test rejections with rejects: 'test(\"throws error\", () => { return expect(fetchData()).rejects.toThrow(\"error\"); });'. Returning promises is cleaner than done callback. Forgetting return is common mistake that causes incomplete tests. Modern approach for promise-based APIs.", "briefDescription": "Test promise-based asynchronous code.", "priority": "must" },
                { "id": "jest-async-await", "title": "async/await", "description": "async/await provides cleanest async testing. Mark test function async: 'test(\"fetches data\", async () => { const data = await fetchData(); expect(data).toBe(\"value\"); });'. Error handling with try/catch: 'test(\"handles errors\", async () => { try { await fetchData(); fail(\"should have thrown\"); } catch (error) { expect(error.message).toBe(\"Network error\"); } });'. Use with resolves/rejects matchers: 'await expect(fetchData()).resolves.toBe(\"value\");'. Async/await is preferred pattern - reads like synchronous code, easier error handling, better stack traces. Works with any promise-based code. Essential for testing async functions, API calls, database queries, and setTimeout/setInterval with fake timers.", "briefDescription": "Modern async testing with await.", "priority": "must" }
              ]
            },
            { "id": "jest-snapshots", "title": "Snapshot Testing", "description": "Snapshot testing captures serialized output and compares against stored snapshots on subsequent runs. Useful for: React components, API responses, configuration objects, error messages. Create snapshot: 'expect(component).toMatchSnapshot();'. First run creates snapshot file. Future runs compare against snapshot - fail if different. Update snapshots: jest -u or press 'u' in watch mode. Snapshots prevent unintended changes by making changes explicit. Avoid for: frequently changing data, non-deterministic output, large objects missing specific assertions. Best practices: review snapshot diffs carefully before updating, combine with specific assertions for critical fields, keep snapshots small and focused. Snapshots complement traditional assertions - they catch unexpected changes while explicit assertions test specific behavior.", "briefDescription": "Capture and compare serialized output.", "priority": "imp" },
            { "id": "jest-coverage", "title": "Code Coverage (--coverage)", "description": "Jest built-in coverage via --coverage flag or package.json script: 'jest --coverage'. Generates coverage report showing uncovered lines, branches, functions, statements. HTML report in coverage/ directory for detailed visualization. Configure coverage in jest.config.js: collectCoverageFrom (specify files), coverageThreshold (enforce minimums), coverageReporters (output formats). Thresholds enforce quality: 'coverageThreshold: { global: { branches: 80, functions: 80, lines: 80, statements: 80 } }'. CI fails if coverage drops below thresholds. Use coverage to find untested code, not as primary metric. Focus on testing behavior, not achieving percentages. Exclude generated files, test utilities, and configuration from coverage. Coverage guides testing efforts but meaningful tests matter more than numbers.", "briefDescription": "Measure and enforce test coverage.", "priority": "must" },
            { "id": "jest-configuration", "title": "Configuration (jest.config.js)", "description": "jest.config.js customizes Jest behavior. Key options: testEnvironment (\"node\" for backend, \"jsdom\" for frontend), setupFilesAfterEnv (run before tests, for global mocks/matchers), moduleNameMapper (resolve path aliases), transform (babel/typescript), testMatch (test file patterns), collectCoverageFrom (coverage scope), coverageThreshold (minimum coverage), globals (global variables), testTimeout (default timeout). Example config: 'module.exports = { testEnvironment: \"node\", setupFilesAfterEnv: [\"./jest.setup.js\"], moduleNameMapper: { \"^@/(.*)$\": \"<rootDir>/src/$1\" }, coverageThreshold: { global: { lines: 80 } } };'. Configuration enables: TypeScript support, path aliases matching webpack, global test utilities, environment-specific setups, coverage enforcement. Good configuration reduces test boilerplate and ensures consistent test environment.", "briefDescription": "Customize Jest test environment.", "priority": "imp" },
            { "id": "jest-custom-matchers", "title": "Custom Matchers", "description": "Extend Jest with domain-specific matchers for readable assertions. Define matcher: 'expect.extend({ toBeValidEmail(received) { const pass = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(received); return { pass, message: () => `Expected ${received} ${pass ? \"not \" : \"\"}to be valid email` }; } });'. Use in tests: 'expect(\"user@example.com\").toBeValidEmail();'. Custom matchers improve: readability (domain language instead of generic matchers), reusability (DRY for common assertions), error messages (specific to domain). Examples: toBeWithinRange(min, max), toHaveValidSchema(schema), toMatchModel(model). Place in setup file to share across tests. Good matchers read like English and provide helpful failure messages. Balance custom matchers with standard ones - too many custom matchers hurt portability and require learning.", "briefDescription": "Create domain-specific assertion matchers.", "priority": "imp" }
          ]
        },
        {
          "id": "react-testing-library",
          "title": "React Testing Library",
          "description": "React Testing Library (RTL) is the recommended approach for testing React components, focusing on testing behavior rather than implementation details. It encourages writing tests that resemble how users interact with your application. RTL is built on DOM Testing Library and works seamlessly with Jest. The core philosophy: test components from user perspective, avoid testing implementation details (state, props, lifecycle), query elements how users find them (by text, role, label), ensure tests work with refactors. RTL promotes accessible applications - if your tests can't find elements, neither can assistive technologies. Understanding RTL principles and APIs is essential for robust React testing that provides confidence without brittleness.",
          "briefDescription": "Test React components like users interact.",
          "priority": "must",
          "children": [
            { "id": "rtl-principles", "title": "Guiding Principles", "description": "RTL core principles: 1) Test behavior, not implementation - don't test state/props directly, test resulting DOM and effects. 2) Query by accessibility - prefer getByRole, getByLabelText over getByTestId. 3) Resemble user interactions - use userEvent over fireEvent for realistic behavior. 4) Find elements like users do - by text content, labels, roles, not CSS classes or test IDs. 5) Avoid testing implementation details - component internals may change, behavior shouldn't. Benefits: tests survive refactors, encourage accessible markup, catch real bugs users encounter, provide confidence. Bad tests: wrapper.state(), component.instance(), checking if useState was called. Good tests: clicking button updates displayed count, form submission shows success message, invalid input shows error. RTL makes good practices easy and bad practices hard.", "briefDescription": "Testing philosophy and best practices.", "priority": "must" },
            { "id": "rtl-queries", "title": "Queries (getBy, queryBy, findBy, getAllBy)", "description": "RTL queries find elements in DOM. Three query types with different behaviors: getBy* - returns element, throws if not found or multiple found. Use for elements that should exist. Returns: single element. Example: 'getByText(\"Submit\")'. queryBy* - returns element or null, doesn't throw. Use for asserting non-existence. Returns: single element or null. Example: 'expect(queryByText(\"Error\")).toBeNull()'. findBy* - returns promise resolving to element. Use for async elements. Returns: Promise<element>. Example: 'await findByText(\"Loaded\")'. Each has *AllBy variant returning array: getAllByRole, queryAllByText, findAllByLabelText. Query priority (best to worst): getByRole (most accessible), getByLabelText (forms), getByPlaceholderText, getByText, getByDisplayValue, getByAltText, getByTitle, getByTestId (last resort). Choose queries that reflect how users find elements. Accessible queries improve both tests and UX.", "briefDescription": "Find elements in rendered components.", "priority": "must" },
            { "id": "rtl-screen", "title": "screen Object", "description": "screen provides all queries bound to document.body, eliminating need to destructure from render. Modern preferred approach: 'import { screen } from \"@testing-library/react\"; render(<Component />); screen.getByRole(\"button\")'. Benefits over destructuring: auto-import one thing, no forgetting to destructure new queries, cleaner test code, easier debugging (screen.debug()). screen includes all query types: getBy*, queryBy*, findBy*, getAllBy*, queryAllBy*, findAllBy*. Also provides debug() for printing DOM: 'screen.debug()' prints entire document, 'screen.debug(screen.getByRole(\"button\"))' prints specific element. Use screen.logTestingPlaygroundURL() to generate Testing Playground link for crafting queries. screen is standard modern RTL approach - use it for all new tests.", "briefDescription": "Convenient query access and debugging.", "priority": "must" },
            { "id": "rtl-events", "title": "fireEvent vs userEvent", "description": "fireEvent and userEvent simulate user interactions but with different fidelity. fireEvent dispatches single DOM event: 'fireEvent.click(button)' dispatches click event only. Low-level, doesn't simulate full interaction. userEvent from @testing-library/user-event simulates complete user interactions: 'await userEvent.click(button)' triggers mousedown, mouseup, click, potentially focus events. Also types realistically: 'await userEvent.type(input, \"text\")' fires keydown, keypress, input, keyup for each character. userEvent is async and more realistic - use it preferentially. fireEvent for specific event testing or when userEvent doesn't support interaction. Example: 'await userEvent.click(screen.getByRole(\"button\"))' vs 'fireEvent.click(screen.getByRole(\"button\"))'. userEvent catches bugs fireEvent misses like missing event handlers. Modern tests should default to userEvent.setup() pattern for v14+.", "briefDescription": "Simulate user interactions realistically.", "priority": "must" },
            { "id": "rtl-async", "title": "waitFor & findBy (Async)", "description": "RTL async utilities handle loading states, API calls, and delayed updates. findBy* queries wait for elements to appear: 'await findByText(\"Loaded\")' polls until element appears or timeout (default 1000ms). Equivalent to waitFor + getBy. waitFor polls until callback doesn't throw: 'await waitFor(() => expect(screen.getByText(\"Done\")).toBeInTheDocument())'. Useful for complex assertions. Configure timeout: 'await findByText(\"Slow\", {}, { timeout: 5000 })'. waitForElementToBeRemoved waits for elements to disappear: 'await waitForElementToBeRemoved(() => screen.queryByText(\"Loading\"))'. Common pattern: render component → trigger async action → await findBy result. Example: 'render(<UserProfile />); await userEvent.click(screen.getByText(\"Load\")); expect(await screen.findByText(\"John Doe\")).toBeInTheDocument();'. Async queries are essential for testing components with loading states and API calls.", "briefDescription": "Handle asynchronous rendering and data.", "priority": "must" },
            { "id": "rtl-renderhook", "title": "renderHook", "description": "renderHook tests custom hooks in isolation without wrapping in component. Import from @testing-library/react: 'const { result } = renderHook(() => useCounter());'. Access hook return value via result.current: 'expect(result.current.count).toBe(0);'. Update hook with rerender: 'const { result, rerender } = renderHook(({ step }) => useCounter(step), { initialProps: { step: 1 } }); rerender({ step: 2 });'. Trigger hook actions with act: 'act(() => { result.current.increment(); }); expect(result.current.count).toBe(1);'. Test hooks with props, context, or complex state. Example testing useCounter: 'const { result } = renderHook(() => useCounter()); act(() => result.current.increment()); expect(result.current.count).toBe(1);'. renderHook is essential for testing complex custom hooks with internal state and effects.", "briefDescription": "Test custom hooks in isolation.", "priority": "must" },
            { "id": "rtl-custom-render", "title": "Custom Render (with Providers)", "description": "Custom render wraps components with necessary providers (Redux, Router, Theme, etc.) automatically. Create wrapper file: 'const AllTheProviders = ({ children }) => <ReduxProvider store={store}><ThemeProvider theme={theme}><Router>{children}</Router></ThemeProvider></ReduxProvider>; const customRender = (ui, options) => render(ui, { wrapper: AllTheProviders, ...options }); export * from \"@testing-library/react\"; export { customRender as render };'. Import from custom file: 'import { render, screen } from \"./test-utils\";'. Benefits: DRY - providers in one place, consistent test setup, easier to add global providers, cleaner test files. Custom render can include store with initial state: 'customRender(ui, { initialState, store })'. Essential for apps with context providers or global state. Eliminates boilerplate from every test.", "briefDescription": "Reusable render with global providers.", "priority": "imp" },
            { "id": "rtl-forms", "title": "Testing Forms", "description": "Test forms by simulating user interactions and validating outcomes. Find inputs by label: 'screen.getByLabelText(\"Email\")' encourages accessible forms. Type into inputs: 'await userEvent.type(emailInput, \"user@example.com\")'. Select options: 'await userEvent.selectOptions(screen.getByLabelText(\"Country\"), \"USA\")'. Check checkboxes: 'await userEvent.click(screen.getByLabelText(\"Agree to terms\"))'. Submit forms: 'await userEvent.click(screen.getByRole(\"button\", { name: \"Submit\" }))'. Assert validation errors: 'expect(await screen.findByText(\"Email is required\")).toBeInTheDocument()'. Test successful submission: mock API, submit form, verify success message or redirect. Example: test login form - enter credentials, submit, verify API called with correct data, verify redirect to dashboard. Test edge cases: empty fields, invalid format, server errors. Form testing ensures critical user flows work correctly.", "briefDescription": "Validate form interactions and submissions.", "priority": "must" },
            { "id": "rtl-routing", "title": "Testing Routing", "description": " Test components with React Router by rendering with MemoryRouter for controlled navigation. Provide initial routes: 'render(<App />, { wrapper: ({ children }) => <MemoryRouter initialEntries={[\"/profile\"]}>{children}</MemoryRouter> })'. Verify current route: check rendered content or use expect(window.location.pathname).toBe(\"/profile\"). Test navigation: 'await userEvent.click(screen.getByText(\"Go to Dashboard\")); expect(screen.getByRole(\"heading\", { name: \"Dashboard\" })).toBeInTheDocument()'. Test route params: 'render(<Route path=\"/users/:id\" component={UserProfile} />, { wrapper: ({ children }) => <MemoryRouter initialEntries={[\"/users/123\"]}>{children}</MemoryRouter> }); expect(screen.getByText(\"User: 123\")).toBeInTheDocument()'. Test protected routes: mock auth context, verify redirect for unauthorized users. MemoryRouter isolates routing from browser location, enabling deterministic tests.", "briefDescription": "Test React Router navigation and routes.", "priority": "must" },
            { "id": "rtl-context", "title": "Testing Context", "description": "Test components consuming context by providing context values in render. Simple provider: 'render(<Component />, { wrapper: ({ children }) => <UserContext.Provider value={{ user: mockUser }}>{children}</UserContext.Provider> })'. Test different context values: render same component with different provider values, verify different outcomes. Test context updates: render component, trigger action that updates context, verify component reflects update. Example testing auth context: 'const mockUser = { id: 1, name: \"John\" }; render(<UserProfile />, { wrapper: ({ children }) => <AuthContext.Provider value={{ user: mockUser }}>{children}</AuthContext.Provider> }); expect(screen.getByText(\"John\")).toBeInTheDocument()'. Include in custom render for app-wide context. Test both consumer components and context provider logic separately.", "briefDescription": "Test components with React Context.", "priority": "imp" },
            { "id": "rtl-custom-hooks-testing", "title": "Testing Custom Hooks", "description": "Test custom hooks using renderHook for hooks with complex logic, state, or effects. Test state updates: 'const { result } = renderHook(() => useToggle()); expect(result.current.value).toBe(false); act(() => result.current.toggle()); expect(result.current.value).toBe(true);'. Test effects: 'const { result } = renderHook(() => useFetch(\"url\")); expect(result.current.loading).toBe(true); await waitFor(() => expect(result.current.loading).toBe(false)); expect(result.current.data).toEqual(mockData);'. Test cleanup: verify useEffect cleanup runs on unmount. Test hooks with dependencies: change props, verify hook updates. Example testing useDebounce: render hook with value, change value multiple times, verify callback called once after delay. Custom hook testing ensures reusable logic works correctly across components.", "briefDescription": " Validate custom hook logic and state.", "priority": "must" }
          ]
        },
        {
          "id": "api-testing",
          "title": "API Testing",
          "description": "API testing verifies backend endpoints, middleware, error handling, and integrations. In MERN stack, this means testing Express routes, validating request/response contracts, ensuring proper error handling, and mocking external services. API tests sit between unit tests and E2E tests - they test multiple units working together but don't require full application stack. Tools like Supertest enable HTTP assertions against Express apps, MSW mocks external APIs, and Postman/Newman provide GUI and CI testing. Good API tests verify status codes, response bodies, headers, authentication, authorization, input validation, and error scenarios.",
          "briefDescription": "Test backend endpoints and integrations.",
          "priority": "must",
          "children": [
            {
              "id": "supertest",
              "title": "Supertest",
              "description": "Supertest is a library for testing HTTP servers like Express applications. It provides high-level abstraction for HTTP assertions integrated with test frameworks.",
              "briefDescription": "HTTP assertion library for testing APIs.",
              "priority": "must",
              "children": [
                { "id": "supertest-routes", "title": "Testing Express Routes", "description": "Supertest tests Express routes without starting server. Import app and supertest: 'const request = require(\"supertest\"); const app = require(\"./app\");'. Make requests: 'await request(app).get(\"/api/users\").expect(200)'. Chain assertions: expect status, headers, body. Example: 'const res = await request(app).get(\"/api/users/1\").expect(200).expect(\"Content-Type\", /json/); expect(res.body).toEqual({ id: 1, name: \"John\" });'. Test POST: 'await request(app).post(\"/api/users\").send({ name: \"Jane\" }).expect(201);'. Test authentication: 'await request(app).get(\"/api/protected\").set(\"Authorization\", \"Bearer token\").expect(200)'. Supertest works with mocked databases for integration tests. Test all HTTP methods: GET, POST, PUT, PATCH, DELETE. Verify response structure matches API contract.", "briefDescription": "Test API endpoints and responses.", "priority": "must" },
                { "id": "supertest-middleware", "title": "Testing Middleware", "description": "Test middleware by creating test routes and verifying behavior. Authentication middleware: 'app.use(\"/test\", authMiddleware); app.get(\"/test\", (req, res) => res.json({ userId: req.user.id })); await request(app).get(\"/test\").set(\"Authorization\", \"Bearer valid\").expect(200); await request(app).get(\"/test\").expect(401);'. Test middleware order: verify earlier middleware affects later handlers. Test error middleware: 'await request(app).get(\"/error-route\").expect(500);'. Validation middleware: send invalid data, verify 400 status with error details. Logging middleware: verify logs created. CORS middleware: check headers. Middleware tests ensure request processing pipeline works correctly. Test both successful flows and error conditions.", "briefDescription": "Validate middleware behavior and order.", "priority": "imp" },
                { "id": "supertest-errors", "title": "Testing Error Handlers", "description": "Test error handlers by triggering errors and validating responses. Create routes that throw errors: 'app.get(\"/error\", () => { throw new Error(\"Test\"); })'. Verify error handler catches: 'await request(app).get(\"/error\").expect(500).expect({ message: \"Test\" });'. Test different error types: validation errors (400), unauthorized (401), forbidden (403), not found (404), server errors (500). Test async errors: 'app.get(\"/async-error\", async () => { throw new Error(\"Async fail\"); });'. Verify error response format consistent. Test error logging: mock logger, verify called. Test production vs development error details. Example: 'const res = await request(app).post(\"/api/users\").send({ invalid: \"data\" }).expect(400); expect(res.body.errors).toContainEqual({ field: \"name\", message: \"required\" });'. Error handler testing ensures users get helpful error messages.", "briefDescription": "Verify error handling and responses.", "priority": "must" }
              ]
            },
            {
              "id": "msw",
              "title": "MSW (Mock Service Worker)",
              "description": "MSW (Mock Service Worker) intercepts network requests and returns mock responses. It works in both browser and Node.js, making it perfect for testing components that fetch data and for testing integrations without real APIs. MSW uses Service Workers in browser and native modules in Node, intercepting requests at network level rather than mocking axios/fetch. This provides realistic testing - your code uses real fetch/axios, MSW intercepts at network boundary.",
              "briefDescription": "Mock API requests at network level.",
              "priority": "imp",
              "children": [
                { "id": "msw-handlers", "title": "Request Handlers", "description": "MSW handlers define mock responses for requests. Create handlers: 'import { rest } from \"msw\"; const handlers = [rest.get(\"/api/users\", (req, res, ctx) => res(ctx.json([{ id: 1, name: \"John\" }]))), rest.post(\"/api/users\", async (req, res, ctx) => { const body = await req.json(); return res(ctx.status(201), ctx.json({ id: 2, ...body })); })];'. Handlers match HTTP method and URL. Use ctx for: json data (ctx.json), status codes (ctx.status), headers (ctx.set), delays (ctx.delay). Access request: query params (req.url.searchParams), body (await req.json()), headers (req.headers). Handlers enable testing with different API responses without actual backend. Test loading states, success, errors, edge cases by changing mock responses.", "briefDescription": "Define mock API responses.", "priority": "imp" },
                { "id": "msw-server", "title": "Server Setup", "description": "Setup MSW server for Node tests. Create server: 'import { setupServer } from \"msw/node\"; const server = setupServer(...handlers);'. Configure in test setup: 'beforeAll(() => server.listen()); afterEach(() => server.resetHandlers()); afterAll(() => server.close());'. Server intercepts all fetch/axios requests. Override handlers per test: 'server.use(rest.get(\"/api/users\", (req, res, ctx) => res(ctx.status(500))));'. Reset handlers after each test prevents tests affecting each other. MSW server enables testing API integrations without real backend. Tests are fast, deterministic, and don't require network. Example: test React component fetching data - MSW returns mock data, component renders correctly.", "briefDescription": "Configure MSW for Node.js tests.", "priority": "imp" },
                { "id": "msw-network-errors", "title": "Network Error Simulation", "description": "MSW simulates network failures for robust error handling tests. Return network error: 'rest.get(\"/api/users\", (req, res, ctx) => res(ctx.networkError(\"Connection failed\")))'. Timeout simulation: 'rest.get(\"/api/users\", (req, res, ctx) => res(ctx.delay(\"infinite\")))'. Test error states: mock failed request, verify component shows error message, retry button works. Example: 'server.use(rest.get(\"/api/users\", (req, res, ctx) => res(ctx.status(500), ctx.json({ error: \"Server error\" })))); render(<UserList />); expect(await screen.findByText(\"Failed to load users\")).toBeInTheDocument();'. Test different error codes: 400, 401, 403, 404, 500. Verify error handling, loading states, retry logic. MSW makes testing error scenarios easy without actually breaking backend.", "briefDescription": "Test error handling with mock failures.", "priority": "imp" }
              ]
            },
            { "id": "postman-newman", "title": "Postman / Newman", "description": "Postman is GUI tool for API development and testing. Newman is Postman's CLI for running collections in CI/CD. Postman features: create requests, organize in collections, write tests with JavaScript (pm.test), parameterize requests with variables, generate documentation. Write tests in Tests tab: 'pm.test(\"Status is 200\", () => pm.response.to.have.status(200)); pm.test(\"Has name\", () => pm.expect(pm.response.json().name).to.exist);'. Chain requests: set variables from responses, use in subsequent requests. Newman runs collections: 'newman run collection.json -e environment.json'. Integrate in CI: 'npm script: \"test:api\": \"newman run postman/collection.json\"'. Postman good for: exploratory testing, sharing API docs, manual QA, quick prototyping. Newman good for: automated API regression tests, smoke tests in deployment pipeline. Complement code-based tests with Postman for comprehensive API testing.", "briefDescription": "GUI and CLI for API testing workflows.", "priority": "look" }
          ]
        },
        {
          "id": "e2e-testing",
          "title": "E2E Testing",
          "description": "End-to-end testing validates complete user workflows from browser through backend to database. E2E tests simulate real user behavior - clicking, typing, navigating - and verify outcomes. They provide highest confidence but are slower and more brittle than unit/integration tests. Modern E2E tools like Cypress and Playwright offer excellent developer experience with automatic waiting, time travel debugging, and multi-browser support. Reserve E2E tests for critical paths: user registration, checkout, core features. Keep E2E suite small but covering high-value scenarios.",
          "briefDescription": "Full-stack user workflow testing.",
          "priority": "must",
          "children": [
            {
              "id": "cypress",
              "title": "Cypress",
              "description": "Cypress is all-in-one E2E testing framework with excellent DX. It runs in browser with automatic waiting, real-time reloading, time-travel debugging, and screenshot/video recording. Cypress architecture: tests run in browser with app, enabling native access to  everything. Automatic waiting eliminates flaky tests. Great for testing SPAs, API integration, visual regression. Not for: multi-browser testing (Chromium only in free version), multi-tab scenarios, native mobile.",
              "briefDescription": "Modern E2E testing framework for web apps.",
              "priority": "must",
              "children": [
                { "id": "cypress-commands", "title": "Commands (visit, get, click, type, should)", "description": "Cypress commands form test DSL. cy.visit(url) loads page. cy.get(selector) finds elements - use data attributes for stability: cy.get('[data-testid=\"submit\"]'). cy.click() clicks element. cy.type(text) types into input. cy.select(option) selects dropdown. cy.contains(text) finds by text content. Commands chain: 'cy.get(\"input[name=email]\").type(\"user@example.com\").should(\"have.value\", \"user@example.com\");'. Cypress retries commands until assertions pass or timeout. Automatic waiting handles async rendering. Example test: 'cy.visit(\"/login\"); cy.get(\"[data-testid=email]\").type(\"user@test.com\"); cy.get(\"[data-testid=password]\").type(\"password123\"); cy.get(\"button[type=submit]\").click(); cy.url().should(\"include\", \"/dashboard\");'. Cypress commands are expressive and reliable.", "briefDescription": "Core Cypress testing commands.", "priority": "must" },
                { "id": "cypress-assertions", "title": "Assertions", "description": "Cypress assertions verify expectations. should command is primary assertion: 'cy.get(\".error\").should(\"be.visible\")'. Chain multiple assertions: 'cy.get(\"h1\").should(\"be.visible\").and(\"contain\", \"Welcome\");'. Common assertions: existence (should(\"exist\")), visibility (should(\"be.visible\")), text (should(\"contain\", text)), values (should(\"have.value\", value)), classes (should(\"have.class\", className)), attributes (should(\"have.attr\", attr, value)), length (should(\"have.length\", n)). Negation with not: should(\"not.exist\"). Custom assertions with then: 'cy.get(\"li\").then($li => expect($li).to.have.length(3));'. Assertions retry until pass or timeout - build automatic waiting into tests. Clear assertions make test failures easy to diagnose.", "briefDescription": "Verify test expectations and outcomes.", "priority": "must" },
                { "id": "cypress-fixtures", "title": "Fixtures", "description": "Fixtures provide static test data from JSON files. Create fixture: cypress/fixtures/user.json contains '{ \"name\": \"John\", \"email\": \"john@test.com\" }'. Load fixture: 'cy.fixture(\"user\").then(user => { cy.get(\"[name=name]\").type(user.name); });'. Use with intercepts: 'cy.intercept(\"GET\", \"/api/users\", { fixture: \"users.json\" });'. Fixtures enable: reusable test data, consistent test state, testing with large/complex data. Organize fixtures by feature or entity. Use for: seed data, mock API responses, test different scenarios (valid user, invalid user). Fixtures keep tests clean and data separate. Load once, use everywhere. Essential for maintainable E2E tests.", "briefDescription": "Reusable static test data.", "priority": "imp" },
                { "id": "cypress-network", "title": "Intercepting Network Requests", "description": "Cypress intercepts network requests for control and assertions. cy.intercept mocks or spies on requests: 'cy.intercept(\"GET\", \"/api/users\", { statusCode: 200, body: [{ id: 1, name: \"John\" }] });'. Spy without mocking: 'cy.intercept(\"POST\", \"/api/users\").as(\"createUser\"); cy.wait(\"@createUser\");'. Assert request payload: 'cy.wait(\"@createUser\").its(\"request.body\").should(\"deep.equal\", { name: \"Jane\" });'. Simulate errors: 'cy.intercept(\"GET\", \"/api/users\", { forceNetworkError: true });'. Delay responses: 'cy.intercept(\"/api/users\", { delay: 2000, fixture: \"users\" });'. Intercepts enable: testing loading states, error handling, testing without backend, verifying API calls. Wait for requests before asserting: 'cy.wait(\"@getUsers\"); cy.get(\".user\").should(\"have.length\", 3);'. Network control makes E2E tests fast and reliable.", "briefDescription": "Control and spy on network calls.", "priority": "must" },
                { "id": "cypress-custom-commands", "title": "Custom Commands", "description": "Custom commands encapsulate reusable test logic. Define in cypress/support/commands.js: 'Cypress.Commands.add(\"login\", (email, password) => { cy.visit(\"/login\"); cy.get(\"[name=email]\").type(email); cy.get(\"[name=password]\").type(password); cy.get(\"button[type=submit]\").click(); cy.url().should(\"include\", \"/dashboard\"); });'. Use in tests: 'cy.login(\"user@test.com\", \"password123\");'. Custom commands reduce duplication across tests. Common use cases: login, logout, create resource, navigate to page, wait for loading. Chain custom commands: return cy to enable chaining. Overwrite existing commands for customization. Custom commands improve test readability and maintainability. Keep them simple and focused. Document parameters and behavior.", "briefDescription": "Reusable test command abstractions.", "priority": "imp" }
              ]
            },
            {
              "id": "playwright",
              "title": "Playwright",
              "description": "Playwright is modern E2E testing framework by Microsoft supporting all browsers (Chromium, Firefox, WebKit). It offers auto-waiting, powerful selectors, parallel execution, mobile emulation, and network interception. Playwright architecture runs out of browser via DevTools protocol, enabling testing against real browser engines. Excellent for: cross-browser testing, mobile web testing, parallel test execution, complex scenarios. Playwright is faster and more powerful than Selenium, comparable to Cypress with better multi-browser support.",
              "briefDescription": "Cross-browser E2E testing automation.",
              "priority": "must",
              "children": [
                { "id": "playwright-pom", "title": "Page Object Model", "description": "Page Object Model (POM) structures Playwright tests with reusable page classes. Create page class: 'class LoginPage { constructor(page) { this.page = page; this.emailInput = page.locator(\"[name=email]\"); this.passwordInput = page.locator(\"[name=password]\"); this.submitButton = page.locator(\"button[type=submit]\"); } async login(email, password) { await this.emailInput.fill(email); await this.passwordInput.fill(password); await this.submitButton.click(); } }'. Use in tests: 'const loginPage = new LoginPage(page); await loginPage.login(\"user@test.com\", \"password123\");'. Benefits: encapsulates page structure, reduces duplication, easier maintenance (selectors in one place), improves readability. Model pages, components, or flows. POM is essential for large E2E suites. Keeps tests clean and DRY.", "briefDescription": "Organize tests with reusable page classes.", "priority": "must" },
                { "id": "playwright-waiting", "title": "Auto-waiting", "description": "Playwright automatically waits for elements to be actionable before performing actions. Auto-wait checks: element attached to DOM, element visible, element stable (not animating), element enabled, element receives events. No manual waits needed: 'await page.click(\"button\")' waits for button to be clickable. Assertions also auto-wait: 'await expect(page.locator(\".error\")).toBeVisible()' retries until visible or timeout. Configure timeout: per action 'await page.click(\"button\", { timeout: 5000 })', globally in config 'timeout: 30000'. Explicit waits when needed: 'await page.waitForSelector(\".loaded\")', 'await page.waitForLoadState(\"networkidle\")'. Auto-waiting eliminates flaky tests from race conditions. Tests are more reliable and easier to write.", "briefDescription": "Automatic waiting for element readiness.", "priority": "must" },
                { "id": "playwright-browsers", "title": "Multi-browser Testing", "description": "Playwright supports testing across Chromium, Firefox, and WebKit with single API. Configure browsers in playwright.config.js: 'projects: [{ name: \"chromium\", use: { ...devices[\"Desktop Chrome\"] } }, { name: \"firefox\", use: { ...devices[\"Desktop Firefox\"] } }, { name: \"webkit\", use: { ...devices[\"Desktop Safari\"] } }]'. Run all browsers: 'npx playwright test', specific browser: 'npx playwright test --project=firefox'. Test mobile viewports: 'use: { ...devices[\"iPhone 12\"] }'. Tests run in parallel across browsers by default. Multi-browser testing catches: browser-specific bugs, CSS rendering differences, JavaScript compatibility issues, polyfill problems. Essential for production apps. Playwright makes cross-browser testing practical with parallel execution and consistent API. Run locally or in CI.", "briefDescription": "Test across Chrome, Firefox, Safari.", "priority": "must" }
              ]
            }
          ]
        },
        {
          "id": "mongodb-testing",
          "title": "MongoDB Testing",
          "description": "Testing MongoDB interactions requires isolated test databases that don't affect production data. mongodb-memory-server provides in-memory MongoDB instances perfect for testing - fast, isolated, no cleanup needed. Test database operations, schemas, validations, indexes, and complex queries with real MongoDB engine. Integration tests verify mongoose models, middleware, and business logic work correctly with actual database.",
          "briefDescription": "Test database operations in isolation.",
          "priority": "imp",
          "children": [
            { "id": "mongodb-memory-server", "title": "mongodb-memory-server", "description": "mongodb-memory-server spins up real MongoDB instance in memory for testing. Install: 'npm i -D mongodb-memory-server'. Setup: 'import { MongoMemoryServer } from \"mongodb-memory-server\"; let mongoServer; beforeAll(async () => { mongoServer = await MongoMemoryServer.create(); const uri = mongoServer.getUri(); await mongoose.connect(uri); }); afterAll(async () => { await mongoose.disconnect(); await mongoServer.stop(); });'. Each test suite gets clean database instance. Benefits: no external dependencies, tests isolated, fast, no cleanup, real MongoDB behavior. Test mongoose models, queries, aggregations, indexing. Example: 'test(\"creates user\", async () => { const user = await User.create({ name: \"John\", email: \"john@test.com\" }); expect(user.name).toBe(\"John\"); });'. Essential for integration testing mongoose models.", "briefDescription": "In-memory MongoDB for isolated tests.", "priority": "imp" },
            { "id": "test-db-lifecycle", "title": "Test Database Setup/Teardown", "description": "Manage test database lifecycle for clean, isolated tests. Setup before all tests: connect to db. Cleanup after each test: clear collections to prevent test pollution. Disconnect after all tests. Pattern: 'beforeAll(async () => { await connectDatabase(); }); beforeEach(async () => { await clearDatabase(); }); afterAll(async () => { await disconnectDatabase(); });'. clearDatabase implementation: 'const clearDatabase = async () => { const collections = await mongoose.connection.db.collections(); for (let collection of collections) { await collection.deleteMany({}); } };'. Ensures: each test starts with empty database, tests don't affect each other, deterministic test results. Some tests need persistent data across tests - use beforeAll to seed, afterAll to cleanup instead.", "briefDescription": "Manage database state between tests.", "priority": "imp" },
            { "id": "test-data-seeding", "title": "Seeding Test Data", "description": "Seed databases with known data for consistent tests. Create seed functions: 'const seedUsers = async () => { const users = [{ name: \"John\", email: \"john@test.com\" }, { name: \"Jane\", email: \"jane@test.com\" }]; await User.insertMany(users); return users; };'. Use in tests: 'beforeEach(async () => { await seedUsers(); }); test(\"finds all users\", async () => { const users = await User.find(); expect(users).toHaveLength(2); });'. Seed data enables: testing queries, testing relationships, testing complex scenarios. Create fixtures for different scenarios: empty state, single item, many items, edge cases. Factories generate varied test data: 'const createUser = (overrides = {}) => ({ name: \"Test User\", email: \"test@example.com\", ...overrides });'. Seeding makes tests readable and maintainable.", "briefDescription": "Populate database with test data.", "priority": "imp" }
          ]
        },
        {
          "id": "performance-testing",
          "title": "Performance Testing",
          "description": "Performance testing validates application behavior under load. It identifies bottlenecks, verifies scalability, establishes performance baselines, and prevents regressions. Types: load testing (expected traffic), stress testing (breaking point), spike testing (sudden traffic), soak testing (sustained load). Tools like k6 and Artillery simulate users and measure metrics: response time, throughput, error rate, resource usage. Performance testing is essential before launching features to ensure they scale.",
          "briefDescription": "Validate application performance under load.",
          "priority": "look",
          "children": [
            { "id": "load-testing-tools", "title": "Load Testing (k6, Artillery)", "description": "Load testing simulates normal to high traffic validating performance under expected conditions. k6 by Grafana uses JavaScript: 'import http from \"k6/http\"; import { check } from \"k6\"; export let options = { vus: 100, duration: \"30s\" }; export default function() { let res = http.get(\"https://api.example.com/users\"); check(res, { \"status is 200\": (r) => r.status === 200, \"response time < 500ms\": (r) => r.timings.duration < 500 }); }'. Run: 'k6 run script.js'. Artillery uses YAML: 'config: target: \"https://api.example.com\"; phases: - duration: 60; arrivalRate: 5; scenarios: - flow: - get: url: \"/users\"'. Run: 'artillery run config.yml'. Both measure latency percentiles (p95, p99), error rates, requests/sec. Use to: find performance bottlenecks, validate API can handle traffic, establish baselines, prevent regressions. Test early and often.", "briefDescription": "Simulate traffic to measure performance.", "priority": "look" },
            { "id": "stress-testing", "title": "Stress Testing", "description": "Stress testing pushes application beyond normal load to find breaking point. Gradually increase load until system fails, identifying: maximum capacity, failure mode (does it crash or degrade gracefully?), recovery time, bottlenecks. k6 stress test: 'export let options = { stages: [{ duration: \"2m\", target: 100 }, { duration: \"5m\", target: 100 }, { duration: \"2m\", target: 200 }, { duration: \"5m\", target: 200 }, { duration: \"2m\", target: 300 }, { duration: \"5m\", target: 300 }, { duration: \"10m\", target: 0 }] };'. Monitor: error rates, response times, resource usage (CPU, memory, database connections). Stress testing reveals: connection pool limits, memory leaks, resource exhaustion, cascading failures. Use findings to: set capacity limits, configure auto-scaling, improve error handling, add circuit breakers.", "briefDescription": "Find breaking point and failure modes.", "priority": "look" },
            { "id": "benchmark-testing", "title": "Benchmark Testing", "description": "Benchmark testing measures specific operation performance to compare implementations or track regressions. JavaScript benchmarks use libraries like Benchmark.js or performance.now(). Example: 'const start = performance.now(); for (let i = 0; i < 1000; i++) { someFunction(); } const duration = performance.now() - start; console.log(`Took ${duration}ms`);'. Compare algorithms: array methods vs loops, different data structures, synchronous vs async. Track trends: run benchmarks in CI, alert on regressions. Benchmark use cases: validating optimizations, comparing libraries, profiling hot paths. Avoid premature optimization - benchmark when performance matters. Focus on realistic scenarios, not microbenchmarks. Benchmark results vary by environment - run on production-like hardware.", "briefDescription": "Measure specific operation performance.", "priority": "look" }
          ]
        }
      ]
    },
    {
      "id": "system-design",
      "title": "System Design & Architecture",
      "description": "System Design is the process of defining the architecture, components, modules, interfaces, and data for a system to satisfy specified requirements. Essential for senior roles, it requires thinking broadly about how to build scalable, reliable, and maintainable systems. You must understand trade-offs between consistency and availability (CAP theorem), choose appropriate databases, design effective caching strategies, and structure microservices. It involves load balancing, sharding, replication, and message queues. You should be able to design systems like a URL shortener, Chat app, or E-commerce platform from high-level architecture down to API design and database schema. A good design handles failure gracefully, scales with traffic, and is cost-effective.",
      "briefDescription": "Architecting scalable and reliable software systems.",
      "priority": "must",
      "children": [
        {
          "id": "system-design-fundamentals",
          "title": "Fundamentals",
          "description": "Core concepts that underpin all distributed systems. Understanding these is prerequisite to designing any complex system.",
          "briefDescription": "Key concepts of distributed systems.",
          "priority": "must",
          "children": [
            { "id": "scalability", "title": "Scalability (Horizontal vs Vertical)", "description": "Scalability is a system's ability to handle growing interactions. Vertical Scaling (Scaling Up): Adding more power (CPU, RAM) to an existing server. Easiest to implement but has a hardware limit (ceiling) and single point of failure. Horizontal Scaling (Scaling Out): Adding more servers to the pool. Linearly scalable, resilient (if one fails, others take over), but requires load balancing and complicates data consistency. MERN apps usually scale horizontally (stateless Node.js/Express servers) while databases can be harder to scale out (sharding).", "briefDescription": "Growing system capacity (Up vs Out).", "priority": "must" },
            { "id": "reliability", "title": "Reliability", "description": "Reliability ensures the system continues to function correctly (performs the intended function) even when things go wrong (hardware failure, software faults, human error). It prevents catastrophic failure. Achieved through redundancy (removing single points of failure), fault tolerance (handling errors gracefully), and automated recovery. For example, if a database primary node fails, a replica should promote to primary automatically without downtime.", "briefDescription": "System functioning despite failures.", "priority": "must" },
            { "id": "availability", "title": "Availability", "description": "Availability is the percentage of time a system is operational and accessible to users. Often measured in nines (e.g., 99.9% = 8.7 hours downtime/year, 99.999% = 5 mins/year). It is not the same as reliability (a system can be available but returning errors). High availability is achieved via redundancy, load balancing across zones/regions, and failover mechanisms. SLAs (Service Level Agreements) define expected availability.", "briefDescription": "Uptime and accessibility of the system.", "priority": "must" },
            { "id": "latency-vs-throughput", "title": "Latency vs Throughput", "description": "Latency is the time taken to process a single request (response time). Throughput is the number of requests a system can handle per unit of time (load capacity). Low Latency: Fast response (essential for gaming, real-time chat). High Throughput: Handling massive data (essential for analytics, batch processing). Often a trade-off: batching improves throughput but increases latency. Optimizing latency involves caching, CDNs, and efficient code. Optimizing throughput involves parallel processing and queuing.", "briefDescription": "Response time vs handling capacity.", "priority": "must" },
            { "id": "cap-theorem", "title": "Consistency vs Availability (CAP)", "description": "CAP Theorem states a distributed data store can only guarantee two of three: Consistency (every read receives the most recent write or an error), Availability (every request receives a (non-error) response, without the guarantee that it contains the most recent write), and Partition Tolerance (system continues to operate despite network messages being dropped). In network partitions (P is unavoidable in distributed systems), you must choose between CP (Consistency - e.g., banking, wait for sync) or AP (Availability - e.g., social feeds, return stale data). MongoDB defaults to CP (strong consistency), Cassandra is AP.", "briefDescription": "Trade-offs in distributed data stores.", "priority": "must" },
            {
              "id": "load-balancing",
              "title": "Load Balancing",
              "description": "Distributing incoming network traffic across multiple servers to ensure no single server bears too much load. Improves responsiveness and availability.",
              "briefDescription": "Distributing traffic across servers.",
              "priority": "must",
              "children": [
                 { "id": "lb-algorithms", "title": "Algorithms", "description": "Round Robin: Requests distributed sequentially. Least Connections: Sent to server with fewest active connections (good for long sessions). IP Hash: Client IP determines server (for sticky sessions). Weighted Round Robin: Powerful servers get more requests.", "briefDescription": "Rules for distributing requests.", "priority": "must" },
                 { "id": "nginx-lb", "title": "Nginx", "description": "Nginx can act as a high-performance software load balancer. It sits in front of your Node.js application servers, handling SSL termination, static files, and distributing API requests to backend instances. Essential for identifying healthy instances and removing unhealthy ones.", "briefDescription": "Using Nginx as a Load Balancer.", "priority": "must" }
              ]
            },
             { "id": "reverse-proxy", "title": "Reverse Proxy", "description": "A server (like Nginx) that sits before web servers and forwards client requests to them. Benefits: Security (hides internal server IPs), SSL Termination (offloads encryption overhead), Caching (serves static content), Compression (gzip), and Load Balancing. Node.js is great for logic but Nginx is better for these edge tasks.", "briefDescription": "Gateway server for backend protection.", "priority": "must" }
          ]
        },
        {
          "id": "caching-system",
          "title": "Caching",
          "description": "Storing copies of frequently accessed data in a temporary storage location (cache) for rapid access. It reduces latency and database load.",
          "briefDescription": "Temporary storage for speed.",
          "priority": "must",
          "children": [
            { "id": "client-side-caching", "title": "Client-Side Caching", "description": "Caching in the browser (HTTP Headers like Cache-Control, ETag). Reduces network requests. Useful for static assets (images, CSS, JS bundles).", "briefDescription": "Browser-based caching.", "priority": "imp" },
            { "id": "cdn-caching", "title": "CDN Caching", "description": "Content Delivery Networks (CloudFront, Cloudflare) cache static assets in edge servers geographically closer to the user. Drastically reduces latency for global users.", "briefDescription": "Geo-distributed edge caching.", "priority": "imp" },
            { "id": "server-side-caching", "title": "Server-Side Caching (Redis)", "description": "Storing computation results or DB queries in memory (Redis/Memcached). Reading from RAM (microseconds) is orders of magnitude faster than disk/DB (milliseconds). Essential for session storage, leaderboards, and frequent API responses.", "briefDescription": "In-memory backend caching.", "priority": "must" },
            { "id": "db-query-caching", "title": "Database Query Caching", "description": "Some databases cache query results automatically. You can also manually cache complex aggregation results. Be careful of stale data.", "briefDescription": "Caching database results.", "priority": "look" },
            { "id": "cache-invalidation", "title": "Cache Invalidation Strategies", "description": "The hard part of caching: knowing when to delete/update data. TTL (Time to Live): cache expires after set time (e.g., 5 mins). Event-based: clear cache when underlying data updates (e.g., clear 'user:123' cache when user updates profile).", "briefDescription": "Removing stale data from cache.", "priority": "must" },
            { "id": "cache-patterns", "title": "Cache Patterns", "description": "Cache-Aside (Lazy Loading): App checks cache; if miss, reads DB, writes to cache (most common). Write-Through: App writes to cache and DB simultaneously (slower write, fast read, consistent). Write-Behind: App writes to cache, cache async writes to DB (fastest write, risk of data loss).", "briefDescription": "Strategies for reading/writing cache.", "priority": "must" }
          ]
        },
        {
          "id": "database-design-sys",
          "title": "Database Design",
          "description": "Designing the data layer for scalability and performance is critical.",
          "briefDescription": "Structuring data for scale.",
          "priority": "must",
          "children": [
            { "id": "schema-design-patterns", "title": "Schema Design Patterns", "description": "Embedding vs Referencing in MongoDB. Embedding (denormalization) improves read performance (one query) but risks data duplication and consistency issues. Referencing (normalization) avoids duplication but requires $lookup joins (slower). Choose based on access patterns: read-heavy goes for embedding, write-heavy/frequently updated data goes for referencing.", "briefDescription": "Embed vs Reference strategies.", "priority": "must" },
            { "id": "indexing-strategies", "title": "Indexing Strategies", "description": "Indexes speed up read queries by creating a sorted data structure. Without indexes, DB performs full collection scan (slow). Single field index, Compound index (order matters: equality -> sort -> range), Text index for search. Trade-off: indexes slow down writes (must update index on every insert/update) and consume RAM.", "briefDescription": "Optimizing query performance.", "priority": "must" },
            {
              "id": "sharding",
              "title": "Sharding",
              "description": "Horizontal scaling for databases. Splitting a large dataset across multiple servers (shards).",
              "briefDescription": "Partitioning data across servers.",
              "priority": "must",
              "children": [
                { "id": "sharding-hash", "title": "Hash-based", "description": "Distributes data based on a hash of the shard key. Ensures uniform distribution but makes range queries efficient (scatter-gather).", "briefDescription": "Random distribution via hash.", "priority": "must" },
                { "id": "sharding-range", "title": "Range-based", "description": "Distributes data based on key ranges (e.g., A-M, N-Z). Good for range queries but can lead to 'hot spots' if one range is accessed more frequently.", "briefDescription": "Distribution by key value range.", "priority": "must" }
              ]
            },
            {
              "id": "replication",
              "title": "Replication",
              "description": "Copying data to multiple servers for redundancy and higher read availability.",
              "briefDescription": "Duplicating data for safety.",
              "priority": "must",
              "children": [
                 { "id": "replication-primary-secondary", "title": "Primary-Secondary", "description": "One Primary node (handles all Writes + Reads), multiple Secondaries (replicate data, can handle Reads). If Primary fails, election promotes a Secondary. MongoDB Replica Sets work this way.", "briefDescription": "Master-Slave architecture.", "priority": "must" },
                 { "id": "replication-multi-primary", "title": "Primary-Primary", "description": "Multiple nodes can handle writes. Complex conflict resolution needed. High availability for writes.", "briefDescription": "Master-Master architecture.", "priority": "look" }
              ]
            },
             { "id": "read-replicas", "title": "Read Replicas", "description": "Offloading read traffic to secondary replicas to reduce load on the primary (which focuses on writes). Consistency can be eventually consistent (lag).", "briefDescription": "Scaling reads via copies.", "priority": "must" },
             { "id": "connection-pooling", "title": "Connection Pooling", "description": "Reusing open database connections instead of opening/closing a new TCP handshake for every request. Reduces overhead significantly. Libraries like Mongoose manage this automatically.", "briefDescription": "Reusing DB connections.", "priority": "imp" },
             { "id": "db-per-service", "title": "Database Per Service", "description": "In microservices, each service manages its own database schema. Prevents coupling and allows services to choose the right DB tool (e.g., Usage Service uses Cassandra, User Service uses MySQL). Requires eventual consistency.", "briefDescription": "Decoupled data storage.", "priority": "imp" }
          ]
        },
        {
          "id": "message-queues",
          "title": "Message Queues",
          "description": "Asynchronous communication between services. Decouples producer (sender) from consumer (receiver), buffering requests to handle load spikes.",
          "briefDescription": "Async service communication.",
          "priority": "must",
          "children": [
            { "id": "rabbitmq", "title": "RabbitMQ", "description": "Popular open-source message broker. Uses standard protocols (AMQP). Good for complex routing logic. Push-based.", "briefDescription": "Robust message broker.", "priority": "imp" },
            { "id": "apache-kafka", "title": "Apache Kafka", "description": "Distributed event streaming platform. High throughput, log-based storage. Messages are persistent. Pull-based. Best for event sourcing and analytics streams.", "briefDescription": "High-throughput event streaming.", "priority": "must", "children": [ { "id": "kafka-concepts", "title": "Topics, Partitions, Consumer Groups", "description": "Topics: Categories for messages. Partitions: Sharding within topics for parallelism. Consumer Groups: Allow multiple consumers to process a topic in parallel (each partition read by one consumer in group).", "briefDescription": "Core Kafka architecture.", "priority": "look" } ] },
            { "id": "bull-redis", "title": "Bull/BullMQ (Redis-based)", "description": "Node.js message queue library backed by Redis. simpler than Kafka/RabbitMQ. Great for background jobs like sending emails, generating reports, video processing. Features: priorities, delays, retries.", "briefDescription": "Simple Node.js job queues.", "priority": "must" },
            { "id": "event-driven-arch", "title": "Event-Driven Architecture", "description": "Services react to events (state changes) rather than direct calls. 'UserCreated' event triggers Email Service (Welcome Email) and Analytics Service. Highly decoupled.", "briefDescription": "Reactive system design.", "priority": "must" },
            { "id": "pub-sub", "title": "Pub/Sub Pattern", "description": "Publishers send messages to topics/channels without knowing subscribers. Subscribers listen to topics. 1-to-Many communication.", "briefDescription": "Publish-Subscribe model.", "priority": "must" },
            { "id": "dead-letter-queue", "title": "Dead Letter Queue", "description": "A queue where messages are sent if they cannot be processed successfully after max retries. Prevents bad messages from blocking consumption and allows manual inspection/debugging.", "briefDescription": "Holding area for failed messages.", "priority": "imp" }
          ]
        },
        {
          "id": "microservices",
          "title": "Microservices",
          "description": "Architectural style structuring an application as a collection of loosely coupled services.",
          "briefDescription": "Decoupled service architecture.",
          "priority": "imp",
          "children": [
            { "id": "monolith-microservices", "title": "Monolith vs Microservices", "description": "Monolith: One code base, one deployment, shared memory. Simple to develop/deploy initially, hard to scale parts independently, becomes 'spaghetti code'. Microservices: Independent services, independent deployment, isolated failures. Scalable, flexible tech stack, but introduces complexity (distributed systems problems, network latency, data consistency).", "briefDescription": "Unified vs Distributed approaches.", "priority": "must" },
            { "id": "service-communication", "title": "Service Communication", "description": "How services talk. Synchronous (REST, gRPC): Tight coupling, requester waits. Asynchronous (Message Queues): Loose coupling, fire-and-forget. API Gateway acts as entry point.", "briefDescription": "Inter-service messaging.", "priority": "must", "children": [ { "id": "sc-rest", "title": "REST", "description": "Standard HTTP calls. Easy, creating tight runtime coupling.", "priority": "must"}, { "id": "sc-grpc", "title": "gRPC", "description": "High performance RPC framework using Protocol Buffers. Binary protocol, strictly typed, faster than JSON/REST. Good for internal service traffic.", "priority": "look" }, { "id": "sc-mq", "title": "Message Queue", "description": "Async communication for decoupling.", "priority": "must" } ] },
            { "id": "api-gateway", "title": "API Gateway", "description": "Single entry point for all clients. Routes requests to appropriate microservices. Handles cross-cutting concerns: Authentication, Rate Limiting, SSL, Logging, Caching. Examples: Kong, AWS API Gateway, Nginx.", "briefDescription": "Unified entry point.", "priority": "must" },
            { "id": "service-discovery", "title": "Service Discovery", "description": "Mechanism for services to find each other's IP addresses in dynamic environments (like Kubernetes) where IPs change. (e.g., Consul, Eureka, CoreDNS).", "briefDescription": "Locating dynamic services.", "priority": "look" },
            { "id": "circuit-breaker", "title": "Circuit Breaker Pattern", "description": "Prevents cascading failures. If a service is failing (e.g., timeout), the circuit breaker 'trips' and immediately returns error/fallback without calling the failing service, giving it time to recover.", "briefDescription": "Failing fast to save system.", "priority": "imp" },
            { "id": "saga-pattern", "title": "Saga Pattern", "description": "Solving distributed transactions. Instead of locking across DBs (2PC), execute a sequence of local transactions. If one fails, execute compensating transactions to undo changes.", "briefDescription": "Distributed transaction management.", "priority": "look" },
            { "id": "event-sourcing", "title": "Event Sourcing", "description": "Build state by logging sequence of state-changing events. Don't just store 'Current Balance', store 'Deposited $10', 'Withdrew $5'. Replay events to reconstruct state.", "briefDescription": "State as event log.", "priority": "look" },
            { "id": "cqrs", "title": "CQRS (Command Query Responsibility Segregation)", "description": "Separate models for reading and updating information. Optimize read DB (denormalized) differently from write DB. Often used with Event Sourcing.", "briefDescription": "Separate Read/Write models.", "priority": "look" },
            { "id": "ms-db-per-service", "title": "Database per Service", "description": "Key rule: Microservices should not share a database to ensure loose coupling.", "briefDescription": "Data isolation rule.", "priority": "imp" }
          ]
        },
        {
          "id": "design-patterns-sys",
          "title": "Design Patterns",
          "description": "Reusable solutions to common software design problems.",
          "briefDescription": "Standard code solutions.",
          "priority": "imp",
          "children": [
            { "id": "mvc", "title": "MVC (Model-View-Controller)", "description": "Separates concerns. Model: Data/Logic (Mongoose schemas). View: User Interface (React components). Controller: Handles input, interacts with Model, updates View (Express route handlers).", "briefDescription": "Separation of concerns.", "priority": "must" },
            { "id": "repository-pattern", "title": "Repository Pattern", "description": "Abstraction layer between business logic and data access. Logic calls repository interfaces, not DB directly. Allows swapping DBs easily and easier testing (mocking repository).", "briefDescription": "Data access abstraction.", "priority": "imp" },
            { "id": "factory-pattern", "title": "Factory Pattern", "description": "Object creation logic is encapsulated. Client calls a method to create objects without specifying exact class. Useful for varied object creation based on input.", "briefDescription": "Encapsulated object creation.", "priority": "look" },
            { "id": "observer-pattern", "title": "Observer Pattern", "description": "Subscription mechanism. Observers subscribe to an Subject. Subject notifies observers on state change. Used in Redux (store subscribers), Event Listeners.", "briefDescription": "Subscription mechanism.", "priority": "imp" },
             { "id": "strategy-pattern", "title": "Strategy Pattern", "description": "Define a family of algorithms, encapsulate each one, and make them interchangeable. Example: Payment processing (Strategy interface) with implementations for PayPal, Stripe, CreditCard. Switch at runtime.", "briefDescription": "Interchangeable algorithms.", "priority": "look" },
             { "id": "decorator-pattern", "title": "Decorator Pattern", "description": "Dynamically adds behavior to an object. Higher-Order Components (HOC) in React are decorators. Middleware in Express is a form of decorator.", "briefDescription": "Extending behavior wrappers.", "priority": "look" },
             { "id": "singleton-pattern", "title": "Singleton Pattern", "description": "Ensures a class has only one instance. Database connections are often singletons. Use with care (global state).", "briefDescription": "Single instance restriction.", "priority": "imp" },
             { "id": "middleware-pattern", "title": "Middleware Pattern", "description": "Chain of processing units. Request passes through sequence of functions (auth, logging, parsing) before reaching handler. Core to Express.js and Redux.", "briefDescription": "Chain of responsibility.", "priority": "must" },
             { "id": "adapter-pattern", "title": "Adapter Pattern", "description": "Allows incompatible interfaces to work together. Wraps an interface to match what client expects. Example: React component adapting data formatting.", "briefDescription": "Interface compatibility wrapper.", "priority": "look" }
          ]
        },
        {
          "id": "common-sys-design-qs",
          "title": "Common System Design Questions",
          "description": "Classic interview problems testing your ability to apply design concepts. Practice defining requirements, estimation, schema design, and scaling strategy for these.",
          "briefDescription": "Practice interview problems.",
          "priority": "must",
          "children": [
            { "id": "design-url-shortener", "title": "URL Shortener (TinyURL)", "description": "Key points: Unique ID generation (Base62 encoding vs UUID), Redirection (301 vs 302), High Read/Write ratio, Caching hot URLs. Database: NoSQL (Key-Value) works well.", "briefDescription": "Shortening services design.", "priority": "must" },
            { "id": "design-chat-app", "title": "Chat Application (WhatsApp/Slack)", "description": "Key points: Real-time (WebSockets/Socket.io), Message persistence (Cassandra/MongoDB), Presence (Redis), Group chats, Push Notifications. Protocol: XMPP vs MQTT vs WebSocket.", "briefDescription": "Real-time messaging design.", "priority": "must" },
            { "id": "design-feed", "title": "Social Media Feed", "description": "Key points: Feed Generation (Fan-out on Write vs Fan-out on Read), Pagination (Cursor-based), Caching, Ranking algorithms. Heavy read load.", "briefDescription": "News feed architecture.", "priority": "must" },
            { "id": "design-ecommerce", "title": "E-Commerce System", "description": "Key points: Consistency is king (Inventory management, Payments), ACID transactions (SQL often better), Search (Elasticsearch), Recommendation engine.", "briefDescription": "Online store architecture.", "priority": "must" },
            { "id": "design-notification", "title": "Notification System", "description": "Key points: Pluggable providers (Email, SMS, Push), Bulk sending, Retry mechanisms, Rate limiting, User preferences, Queue-based processing.", "briefDescription": "Alert delivery system.", "priority": "imp" },
            { "id": "design-file-storage", "title": "File Storage System (Dropbox)", "description": "Key points: Chunking large files, De-duplication, Synchronization, Metadata DB vs Block Storage (S3), Offline support.", "briefDescription": "Cloud storage design.", "priority": "look" },
            { "id": "design-rate-limiter", "title": "Rate Limiter", "description": "Key points: Algorithms (Token Bucket, Leaky Bucket, Sliding Window), Distributed tracking (Redis), HTTP Headers implementation.", "briefDescription": "Throttling system design.", "priority": "must" },
            { "id": "design-autocomplete", "title": "Search Autocomplete", "description": "Key points: Trie data structure, Typeahead search, Caching top queries, updating frequency. ElasticSearch/Solr.", "briefDescription": "Predictive text search.", "priority": "look" },
            { "id": "design-collab", "title": "Real-time Collaboration (Google Docs)", "description": "Key points: Operational Transformation (OT) or CRDTs (Conflict-free Replicated Data Types) for concurrency control. WebSocket for sync.", "briefDescription": "Concurrent editing design.", "priority": "look" }
          ]
        },
        {
          "id": "frontend-architecture",
          "title": "Frontend Architecture",
          "description": "Designing scalable frontend applications involves more than just components. It encompasses code organization, state management strategy, build systems, and performance.",
          "briefDescription": "Scalable frontend patterns.",
          "priority": "must",
          "children": [
            { "id": "micro-frontends", "title": "Micro-Frontends", "description": "Splitting a generic frontend app into smaller, independent apps (e.g., Header, Checkout, Product). Independent deployment, autonomous teams. Tools: Module Federation, Single-SPA. adds complexity.", "briefDescription": "Decoupled UI applications.", "priority": "imp" },
            { "id": "module-federation", "title": "Module Federation", "description": "Webpack feature allowing code loading from another build at runtime. Key enabler for Micro-Frontends. Shared dependencies to avoid huge bundles.", "briefDescription": "Runtime code sharing.", "priority": "look" },
            { "id": "monorepo-polyrepo", "title": "Monorepo vs Polyrepo", "description": "Monorepo (Turborepo, Nx): One git repo, multiple packages. Pros: Shared code, atomic commits, unified tooling. Cons: long build times if unoptimized. Polyrepo: Standard separate repos.", "briefDescription": "Repository strategies.", "priority": "imp" },
            { "id": "feature-flags", "title": "Feature Flags", "description": "Toggling features on/off without redeploying. Enables trunk-based development, canary releases, and A/B testing. Tools: LaunchDarkly.", "briefDescription": "Runtime feature toggles.", "priority": "imp" },
            { "id": "ab-testing", "title": "A/B Testing Architecture", "description": "Serving different versions of UI to different user segments to measure engagement. Requires analytics integration and assignment logic.", "briefDescription": "Experimentation setup.", "priority": "look" },
            { "id": "error-tracking", "title": "Error Tracking (Sentry)", "description": "Catching crashes in production. Source maps help decode minified stack traces. Context (user actions, breadcrumbs) is vital.", "briefDescription": "Production crash monitoring.", "priority": "must" },
            { "id": "analytics-integration", "title": "Analytics Integration", "description": "Tracking user behavior (Page views, Clicks). Abstraction layer prevents vendor lock-in (Google Analytics, Mixpanel, Segment).", "briefDescription": "User behavior tracking.", "priority": "imp" }
          ]
        }
      ]
    },
    {
      "id": "devops-cicd",
      "title": "DevOps, CI/CD & Deployment",
      "description": "DevOps brings Development and Operations teams together to streamline software delivery. It emphasizes automation, infrastructure as code, and continuous feedback. In the MERN context, this means containerizing your application (Docker), establishing automated pipelines to build and test code (CI), and deploying seamlessly to production (CD). Understanding deployment strategies, managing cloud infrastructure (AWS), ensuring observability through logging and monitoring, and securing your deployment environment are critical skills for a full-stack developer. You move from 'it works on my machine' to 'it works reliably in production for everyone'.",
      "briefDescription": "Automation, containerization, and cloud deployment.",
      "priority": "must",
      "children": [
        {
          "id": "docker",
          "title": "Docker",
          "description": "Docker is a platform for developing, shipping, and running applications in containers. Containers are lightweight, portable, and self-sufficient units that include everything needed to run software: code, runtime, system tools, and libraries. This eliminates environment inconsistencies ('it works on my machine' syndrome).",
          "briefDescription": "Containerization platform for reliable environments.",
          "priority": "must",
          "children": [
            {
              "id": "dockerfile",
              "title": "Dockerfile",
              "description": "A text document typically named 'Dockerfile' that contains all commands to assemble a Docker image. It's the blueprint for your container.",
              "briefDescription": "Script to build Docker images.",
              "priority": "must",
              "children": [
                { "id": "dockerfile-instructions", "title": "Directives (FROM, RUN, COPY, etc.)", "description": "FROM: Base image (e.g., node:18-alpine). WORKDIR: Sets working directory (/app). COPY: Copies files from host to container context (COPY package.json .). RUN: Executes commands during build (npm install). CMD: Default command to run when container starts (npm start). ENTRYPOINT: Configures container as executable. EXPOSE: Documents ports (Doesn't publish them). ENV: Sets environment variables. ARG: Build-time variables.", "briefDescription": "Core Dockerfile instructions.", "priority": "must" },
                { "id": "multistage-builds", "title": "Multi-stage Builds", "description": "Using multiple FROM statements in one Dockerfile to create smaller, efficient images. Example: Stage 1 compiles TypeScript/builds React app. Stage 2 (final) only copies the built artifacts (dist/build folder) and runs a lightweight server (nginx/node). drastically reduces image size by discarding build tools and dependencies.", "briefDescription": "Optimizing image size via build stages.", "priority": "must" },
                { "id": "dockerignore", "title": ".dockerignore", "description": "Excludes files from the build context (like .gitignore). Essential for ignoring node_modules (preventing long copy times and wrong architecture modules), .git folder, .env files (security), and logs.", "briefDescription": "Excluding files from Docker build.", "priority": "must" }
              ]
            },
            {
              "id": "docker-images",
              "title": "Docker Images",
              "description": "Read-only templates used to create containers. Built from a Dockerfile.",
              "briefDescription": "Snapshots of application state.",
              "priority": "must",
              "children": [
                { "id": "image-layers", "title": "Layers", "description": "Images are built in layers. Each instruction in Dockerfile creates a read-only layer. Layers are cached. If you change a line, only that layer and subsequent ones are rebuilt. Optimize by ordering instructions from least frequent to most frequent changes (e.g., Copy package.json -> Run Install -> Copy Source Code).", "briefDescription": "Cached, stacked filesystem changes.", "priority": "must" },
                { "id": "image-optimization", "title": "Image Optimization", "description": "Techniques to keep images small/secure: Use Alpine variants (node:alpine - 5MB vs 100MB+), Multi-stage builds, Combine RUN commands to reduce layers, Remove cache after install (apt-get clean), Don't run as root user.", "briefDescription": "Reducing size and surface area.", "priority": "imp" }
              ]
            },
            {
              "id": "docker-containers",
              "title": "Docker Containers",
              "description": "Runnable instances of Docker images. Isolated processes running on the host kernel.",
              "briefDescription": "Running application instances.",
              "priority": "must",
              "children": [
                { "id": "container-lifecycle", "title": "Container Lifecycle", "description": "create -> start -> run -> pause/unpause -> stop -> kill -> remove. 'docker run' creates and starts. 'docker stop' sends SIGTERM (graceful). 'docker kill' sends SIGKILL. Stopped containers persist until removed ('docker rm').", "briefDescription": "States of a container.", "priority": "must" },
                { "id": "port-mapping", "title": "Port Mapping", "description": "Map host port to container port (-p 3000:80). Outside traffic hits host:3000 -> forwarded to container:80. Without mapping, container is isolated from outside network.", "briefDescription": "Exposing container services.", "priority": "must" },
                { "id": "volume-mounting", "title": "Volume Mounting", "description": "Persisting data outside container lifecycle. Volumes: Managed by Docker (/var/lib/docker/volumes). Bind Mounts: Map specific host folder to container path (great for dev hot-reloading: -v $(pwd):/app). Tmpfs: In-memory only.", "briefDescription": "Data persistence strategies.", "priority": "must" },
                { "id": "docker-env-vars", "title": "Environment Variables", "description": "Injecting configuration at runtime (-e NODE_ENV=production). Allows same image to run in Dev, Test, Prod with different configs.", "briefDescription": "Runtime configuration injection.", "priority": "must" }
              ]
            },
            {
              "id": "docker-compose",
              "title": "Docker Compose",
              "description": "Tool for defining and running multi-container applications using YAML. Simplifies orchestration of App + DB + Redis.",
              "briefDescription": "Multi-container orchestration.",
              "priority": "must",
              "children": [
                { "id": "multi-container-setup", "title": "Multi-container Setup", "description": "Define services (web, api, mongo) in docker-compose.yml. 'docker-compose up' starts everything. Connects containers automatically via a default network so they can talk to each other by service name.", "briefDescription": "Orchestrating stack services.", "priority": "must" },
                { "id": "compose-networks", "title": "Networks", "description": "Defines custom networks for isolation. Services on same network can reach each other. E.g., Backend on 'app-net', DB on 'data-net', Proxy on both.", "briefDescription": "Network isolation in Compose.", "priority": "imp" },
                { "id": "compose-volumes", "title": "Volumes", "description": "Defining named volumes for persistence across container restarts (e.g., mongo-data:/data/db).", "briefDescription": "Persistent storage config.", "priority": "must" },
                { "id": "depends_on", "title": "Depends On", "description": "Control startup order: ensure Database starts before Backend. (Note: doesn't wait for DB to be *ready*, just started).", "briefDescription": "Service startup order.", "priority": "imp" }
              ]
            },
            {
              "id": "docker-networking",
              "title": "Docker Networking",
              "description": "How containers communicate with each other and the world.",
              "briefDescription": "Container communication drivers.",
              "priority": "imp",
              "children": [
                 { "id": "network-drivers", "title": "Drivers (Bridge, Host, None)", "description": "Bridge: Default. Containers get private IP, talk via bridge interface (NAT). Host: Container shares host's network stack (no isolation, fast). None: No networking.", "briefDescription": "Networking modes.", "priority": "imp" },
                 { "id": "container-communication", "title": "Container Communication", "description": "Containers on same network can verify via DNS name (service name). Docker embeds a DNS server.", "briefDescription": "Service discovery via DNS.", "priority": "must" }
              ]
            }
          ]
        },
        {
          "id": "cicd",
          "title": "CI/CD",
          "description": "Continuous Integration (CI) and Continuous Deployment/Delivery (CD) automate code integration and release processes.",
          "briefDescription": "Automated delivery pipelines.",
          "priority": "must",
          "children": [
            {
              "id": "github-actions",
              "title": "GitHub Actions",
              "description": "CI/CD platform built into GitHub. Automates workflows directly from your repository.",
              "briefDescription": "GitHub-native automation.",
              "priority": "must",
              "children": [
                { "id": "gha-workflows", "title": "Workflows", "description": "YAML files in .github/workflows/. Defines the automation process. Starts with name and on (trigger).", "briefDescription": "Pipeline definition files.", "priority": "must" },
                { "id": "gha-jobs-steps", "title": "Jobs & Steps", "description": "Jobs run in parallel by default. A Job consists of sequential Steps. Steps can run commands (run: npm test) or use Actions (uses: actions/checkout).", "briefDescription": "Execution units.", "priority": "must" },
                { "id": "gha-triggers", "title": "Triggers", "description": "Events that start workflows: push (on every commit), pull_request (on PR opening/update), schedule (cron job), workflow_dispatch (manual button).", "briefDescription": "Events starting pipelines.", "priority": "must" },
                { "id": "gha-secrets", "title": "Secrets & Variables", "description": "Storing sensitive data (API Keys, SSH Keys) safely in repo settings. Accessed via ${{ secrets.KEY }}. Never hardcode secrets in YAML.", "briefDescription": "Secure configuration storage.", "priority": "must" },
                { "id": "gha-matrix", "title": "Matrix Builds", "description": "Running same job across multiple configurations (e.g., Node 14, 16, 18) simultaneously.", "briefDescription": "Parallel multi-config testing.", "priority": "imp" },
                { "id": "gha-caching", "title": "Caching Dependencies", "description": "caching node_modules to speed up builds. Uses hash of package-lock.json as key.", "briefDescription": "Speeding up pipelines.", "priority": "imp" },
                { "id": "custom-actions", "title": "Custom Actions", "description": "Reusable logic packaged as an action. Can be JavaScript, Docker, or Composite.", "briefDescription": "Reusable pipeline tasks.", "priority": "look" }
              ]
            },
            { "id": "jenkins-basics", "title": "Jenkins (Basics)", "description": "Older, self-hosted, open-source automation server. Configured via Jenkinsfile (Groovy). highly plugin-dependent. Industry standard for legacy or complex on-prem setups.", "briefDescription": "Legacy CI automation server.", "priority": "look" },
            { "id": "gitlab-ci", "title": "GitLab CI (Basics)", "description": "Integrated CI/CD in GitLab. Uses .gitlab-ci.yml. Known for comprehensive features and Auto DevOps.", "briefDescription": "GitLab's integrated pipelines.", "priority": "look" },
            {
              "id": "pipeline-design",
              "title": "CI/CD Pipeline Design",
              "description": "Designing effective Stages for reliable delivery.",
              "briefDescription": "Structuring automated flows.",
              "priority": "must",
              "children": [
                { "id": "build-stage", "title": "Build Stage", "description": "Install dependencies (npm ci), Transpile code (Babel/TSC), Bundle assets (Webpack), Build Docker Image. Fail fast if build breaks.", "briefDescription": "Compiling and bundling.", "priority": "must" },
                { "id": "test-stage", "title": "Test Stage", "description": "Run Linters, Unit Tests, Integration Tests. Only proceed if 100% pass. Run separately or parallel to build.", "briefDescription": "Verifying code quality.", "priority": "must" },
                { "id": "deploy-stage", "title": "Deploy Stage", "description": "Push artifacts to registry (Docker Hub) or deploy code to server/cloud (AWS/Vercel). Can be continuous (every commit) or gated (manual approval).", "briefDescription": "Releasing to production.", "priority": "must" },
                { "id": "rollback-strategy", "title": "Rollback Strategy", "description": "Plan to undo a failed deployment instantly. Blue/Green Deployment or simply reverting to previous Docker image tag.", "briefDescription": "Disaster recovery plan.", "priority": "must" }
              ]
            }
          ]
        },
        {
          "id": "cloud-deployment",
          "title": "Cloud Deployment",
          "description": "Hosting your application on cloud infrastructure providers.",
          "briefDescription": "Cloud hosting platforms.",
          "priority": "must",
          "children": [
            {
              "id": "aws",
              "title": "AWS (Amazon Web Services)",
              "description": "Market leader. Vast ecosystem.",
              "briefDescription": "Comprehensive cloud platform.",
              "priority": "must",
              "children": [
                { "id": "aws-ec2", "title": "EC2 (Elastic Compute Cloud)", "description": "Virtual Servers (VPS). You manage OS, updates, scaling manually. Full control, high maintenance.", "briefDescription": "Virtual servers.", "priority": "must" },
                { "id": "aws-s3", "title": "S3 (Simple Storage Service)", "description": "Object storage for file uploads (images, videos, logs). Highly durable, cheap. Static website hosting capability.", "briefDescription": "Object storage.", "priority": "must" },
                { "id": "aws-lambda", "title": "Lambda", "description": "Serverless compute. Run code without provisioning servers. Pay per millisecond. Event-driven.", "briefDescription": "Serverless functions.", "priority": "imp" },
                { "id": "aws-rds", "title": "RDS (Relational Database Service)", "description": "Managed SQL databases (Postgres, MySQL). Handles backups, patching, replication automatically.", "briefDescription": "Managed SQL databases.", "priority": "imp" },
                { "id": "aws-cloudfront", "title": "CloudFront", "description": "CDN (Content Delivery Network). Caches S3 content or API responses at global edge locations.", "briefDescription": "Global Content Delivery Network.", "priority": "imp" },
                { "id": "aws-route53", "title": "Route 53", "description": "Scalable DNS and Domain management service.", "briefDescription": "DNS management.", "priority": "imp" },
                { "id": "aws-ecs-eks", "title": "ECS / EKS", "description": "Container Orchestration. ECS (native), EKS (Kubernetes managed service). Running Docker containers at scale.", "briefDescription": "Container orchestration.", "priority": "look" },
                { "id": "aws-iam", "title": "IAM", "description": "Identity and Access Management. Managing permissions for users and services. Principle of Least Privilege.", "briefDescription": "Security and access control.", "priority": "must" }
              ]
            },
            {
              "id": "vercel",
              "title": "Vercel",
              "description": "Platform optimizing frontend frameworks (Next.js). Zero-config CI/CD. Best for static/hybrid sites.",
              "briefDescription": "Frontend-focused cloud.",
              "priority": "must",
              "children": [
                 { "id": "serverless-funcs", "title": "Serverless Functions", "description": "API routes in Next.js deployed automatically as Lambdas.", "briefDescription": "API routes as serverless.", "priority": "must" },
                 { "id": "edge-functions", "title": "Edge Functions", "description": "Code running at the CDN edge (clover to user) for low latency middleware tasks.", "briefDescription": "Low-latency edge compute.", "priority": "imp" },
                 { "id": "preview-deployments", "title": "Preview Deployments", "description": "Automatically deploys every Pull Request to a unique URL for review.", "briefDescription": "Automatic branch previews.", "priority": "must" }
              ]
            },
            { "id": "railway-render", "title": "Railway / Render", "description": "Modern PaaS alternatives to Heroku. Great DX, easy deployment from GitHub, managed databases. Good for full-stack apps.", "briefDescription": "Modern PaaS providers.", "priority": "imp" },
            { "id": "digitalocean", "title": "DigitalOcean", "description": "Developer-friendly cloud. Droplets (VPS) are cheaper/simpler than EC2. App Platform is their PaaS offering.", "briefDescription": "Simple developer cloud.", "priority": "imp" },
            { "id": "heroku-legacy", "title": "Heroku (Legacy)", "description": "Pioneer of PaaS. Easy but expensive. Ephemeral file system (files deleted on restart). Dynos (containers).", "briefDescription": "Pioneering PaaS usage.", "priority": "look" }
          ]
        },
        {
          "id": "monitoring-logging",
          "title": "Monitoring & Logging",
          "description": "Observability acts as the eyes and ears of production systems.",
          "briefDescription": "System observability.",
          "priority": "must",
          "children": [
            {
              "id": "app-logging",
              "title": "Application Logging",
              "description": "Recording app events.",
              "briefDescription": "Event recording.",
              "priority": "must",
              "children": [
                { "id": "logging-libs", "title": "Use Libraries (Winston/Pino)", "description": "Don't use console.log in production (blocking in Node, unstructured). Winston/Pino offer structured JSON logs, levels, and transports (file, remote).", "briefDescription": "Pro logging libraries.", "priority": "must" },
                { "id": "http-logging", "title": "Morgan", "description": "Middleware for logging HTTP requests (method, URL, status, time) in Express.", "briefDescription": "HTTP request logger.", "priority": "must" },
                { "id": "log-levels", "title": "Log Levels", "description": "Error (fix now), Warn (investigate), Info (routine), Debug (dev detail). Filter logs by level to reduce noise.", "briefDescription": "Categorizing log severity.", "priority": "must" },
                { "id": "structured-logging", "title": "Structured Logging", "description": "Logging as JSON objects rather than plain text strings. Allows querying logs (e.g., find all logs where userId=123).", "briefDescription": "Machine-readable logs.", "priority": "imp" }
              ]
            },
            {
              "id": "monitoring-sys",
              "title": "Monitoring",
              "description": "Checking system health.",
              "briefDescription": "Health surveillance.",
              "priority": "must",
              "children": [
                 { "id": "health-checks", "title": "Health Checks", "description": "API endpoint (/health) returning 200 OK if app is running. Used by Load Balancers to restart failed instances.", "briefDescription": "Status endpoint.", "priority": "must" },
                 { "id": "uptime-monitoring", "title": "Uptime Monitoring", "description": "External service (UptimeRobot) pinging your site every 5 mins to alert if down.", "briefDescription": "External availability checks.", "priority": "imp" },
                 { "id": "apm", "title": "APM", "description": "Application Performance Monitoring (New Relic, Datadog). Traces transactions through stack, finding slow DB queries or memory leaks.", "briefDescription": "Deep performance tracing.", "priority": "look" }
              ]
            },
            { "id": "error-tracking-tools", "title": "Error Tracking (Sentry)", "description": "Dedicated tool capturing unhandled exceptions with full context (stack trace, user inputs). Far superior to grepping log files.", "briefDescription": "Crash reporting.", "priority": "must" },
            { "id": "metrics-alerts", "title": "Metrics & Alerts", "description": "Collecting numerical data (CPU usage, Request Rate, Error Rate) and alerting (Email/Slack/PagerDuty) when thresholds breached.", "briefDescription": "Quantitative health tracking.", "priority": "imp" }
          ]
        },
        {
          "id": "infrastructure",
          "title": "Infrastructure",
          "description": "Fundamental components supporting web deployment.",
          "briefDescription": "Core web infrastructure.",
          "priority": "imp",
          "children": [
            {
              "id": "nginx",
              "title": "Nginx",
              "description": "High-performance web server and reverse proxy.",
              "briefDescription": "Web server & proxy.",
              "priority": "imp",
              "children": [
                 { "id": "reverse-proxy-infra", "title": "Reverse Proxy", "description": "Standard setup: Client -> Nginx -> Node App. Nginx handles exposure to internet.", "briefDescription": "Gateway proxying.", "priority": "must" },
                 { "id": "ssl-termination", "title": "SSL Termination", "description": "Nginx decrypts HTTPS traffic and talks HTTP to local Node app. Saves Node CPU cycles.", "briefDescription": "Decryption offloading.", "priority": "imp" },
                 { "id": "static-serving", "title": "Static File Serving", "description": "Serving React build folder / public assets directly from disk. Much faster than Node.js.", "briefDescription": "Efficient asset delivery.", "priority": "imp" }
              ]
            },
            { "id": "ssl-tls", "title": "SSL/TLS (Let's Encrypt)", "description": "HTTPS allows secure encrypted communication. Let's Encrypt provides free, automated certificates. Certbot automates renewal.", "briefDescription": "Secure encrypted connections.", "priority": "must" },
            { "id": "dns-config", "title": "DNS Configuration", "description": "A Records (Domain -> IP), CNAME (Domain -> Domain), MX (Mail). Propagation times.", "briefDescription": "Domain name mapping.", "priority": "imp" },
            { "id": "env-management", "title": "Environment Management", "description": "Managing .env files safely. Never commit to Git. Use Secret Managers in cloud.", "briefDescription": "Secure config management.", "priority": "must" },
            { "id": "k8s-basics", "title": "Kubernetes (Basics)", "description": "Container Orchestration for massive scale. Pods (smallest unit, one or more containers), Services (Networking), Deployments (Scaling & Updates), ConfigMaps (Env vars). Overkill for small apps.", "briefDescription": "Orchestration at scale.", "priority": "look" }
          ]
        }
      ]
    },
    {
      "id": "git-version-control",
      "title": "Git & Version Control",
      "description": "Git is the distributed version control system that acts as the backbone of modern software development. It allows tracking changes, reverting to previous states, and collaborating with safe merging of code. Beyond basic push/pull, mastering Git involves understanding its internal data model (blobs, trees, commits), managing complex branching strategies, advanced history rewriting (rebase, reset), and resolving conflicts confidently. In a team setting, Git skills determine how smoothly you can integrate your work, review others' code, and manage releases. It's often the first test of competence in a new job - can you clone the repo and get running without help?",
      "briefDescription": "Source code management and collaboration.",
      "priority": "must",
      "children": [
        {
          "id": "git-basics",
          "title": "Git Basics",
          "description": "Fundamental commands for daily operations. Understanding standard workflow: Working Directory -> Staging Area -> Local Repository -> Remote Repository.",
          "briefDescription": "Core Git commands.",
          "priority": "must",
          "children": [
            { "id": "git-commands", "title": "Core Commands", "description": "init: Initialize repo. clone: Copy remote repo. status: Check state. add: Move changes to staging area (index). commit: Snapshot staged changes. push: Upload commits to remote. pull: Fetch and merge remote changes. fetch: Download remote changes without merging (safer than pull).", "briefDescription": "Essential daily commands.", "priority": "must" },
            { "id": "gitignore", "title": ".gitignore", "description": "Specifies intentionally untracked files to ignore. Essential to keep repo clean. Ignore: node_modules/, .env, build/, .DS_Store, log files. Use patterns (*.log, /dist). Global .gitignore for system files.", "briefDescription": "Ignoring build artifacts and secrets.", "priority": "must" },
            { "id": "git-config", "title": "Git Config", "description": "Configuration levels: --system, --global, --local. Set user.name, user.email (must match GitHub email for attribution). core.editor (vim/nano/code). alias (create shortcuts like 'git co' for checkout).", "briefDescription": "User and repository configuration.", "priority": "must" }
          ]
        },
        {
          "id": "git-branching",
          "title": "Branching",
          "description": "Branching allows diverting from the main line of development to work on features safely without affecting the main codebase.",
          "briefDescription": "Isolated development lines.",
          "priority": "must",
          "children": [
            { "id": "create-delete-branch", "title": "Creating & Deleting", "description": "Create: 'git branch <name>'. Create & Switch: 'git checkout -b <name>'. Delete (safe): 'git branch -d <name>'. Force Delete (unmerged): 'git branch -D <name>'. Clean up local branches after merge.", "briefDescription": "Managing branch usage.", "priority": "must" },
            { "id": "switch-branch", "title": "Switching (checkout/switch)", "description": "Legacy: 'git checkout <name>'. Modern: 'git switch <name>' (introduced to separate switching from restoring files). 'git switch -c <name>' creates new branch. detaching HEAD (checkout commit hash) allows inspection of past states.", "briefDescription": "Navigating between branches.", "priority": "must" },
            { "id": "branch-naming", "title": "Naming Conventions", "description": "Consistent naming aids readability. Prefixes: feature/login-page, bugfix/header-crash, hotfix/production-error, release/v1.0. Lowercase, hyphen-separated. Include ticket ID if applicable (jira-123-fix-login).", "briefDescription": "Standardized branch names.", "priority": "imp" },
            { "id": "feature-branches", "title": "Feature Branches", "description": "Workflow where every new feature gets its own branch from 'main' or 'develop'. Kept short-lived. Merged via Pull Request.", "briefDescription": "Feature development strategy.", "priority": "must" }
          ]
        },
        {
          "id": "git-merging",
          "title": "Merging",
          "description": "Integrating changes from one branch into another.",
          "briefDescription": "Combining development histories.",
          "priority": "must",
          "children": [
            { "id": "fast-forward", "title": "Fast-Forward Merge", "description": "If target branch hasn't moved since source branched off, git just moves the pointer forward. Linear history. No merge commit created unless --no-ff used.", "briefDescription": "Linear pointer update.", "priority": "must" },
            { "id": "three-way-merge", "title": "Three-Way Merge", "description": "If branches diverged, git creates a new 'Merge Commit' with two parents, combining snapshots. Preserves history of when branching happened. standard git merge behavior.", "briefDescription": "Combining divergent branches.", "priority": "must" },
            {
              "id": "merge-conflicts",
              "title": "Merge Conflicts",
              "description": "Occur when same lines modified differently in both branches. Git pauses for manual resolution.",
              "briefDescription": "Resolving overlapping changes.",
              "priority": "must",
              "children": [
                { "id": "conflict-resolution", "title": "Resolution Strategies", "description": "Accept Current (yours), Accept Incoming (theirs), Accept Both, or Manual Edit. Use GUI tools (VS Code) or 'git mergetool'. After edit: git add <file>, git commit.", "briefDescription": "manual conflict fixing.", "priority": "must" },
                { "id": "conflict-markers", "title": "Conflict Markers", "description": "<<<<<<< HEAD (Current Change) ... ======= ... >>>>>>> branch-name (Incoming Change). Understanding these delimiters is vital for manual resolution.", "briefDescription": "Reading git conflict syntax.", "priority": "must" }
              ]
            }
          ]
        },
        {
          "id": "git-rebasing",
          "title": "Rebasing",
          "description": "Alternative to merging. Moves the entire feature branch to begin on the tip of the latest main branch. Rewrites history to make it linear.",
          "briefDescription": "Rewriting history for linearity.",
          "priority": "imp",
          "children": [
            { "id": "interactive-rebase", "title": "Interactive Rebase", "description": "'git rebase -i HEAD~n'. Powerful tool to edit, reorder, squash, or drop previous commits. Useful for cleaning up local history before pushing.", "briefDescription": "Editing commit history.", "priority": "imp" },
            { "id": "rebase-vs-merge", "title": "Rebase vs Merge", "description": "Merge: Preserves true history, safer, creates merge bubbles. Rebase: Clean linear history, dangerous on shared branches (rewrites history). Golden Rule: Never rebase public branches (like main), only local feature branches.", "briefDescription": "Choosing integration strategy.", "priority": "imp" },
            { "id": "squashing-commits", "title": "Squashing Commits", "description": "Combining multiple small 'wip' commits into one meaningful commit. Done via interactive rebase or 'git merge --squash'. Keeps history clean.", "briefDescription": "Condensing commit history.", "priority": "imp" },
            { "id": "rewriting-history", "title": "Rewriting History", "description": "Changing past commits (amend, rebase). 'git commit --amend' fixes last commit message/files. Dangerous if already pushed (requires force push).", "briefDescription": "Modifying past states.", "priority": "imp" }
          ]
        },
        {
          "id": "advanced-git",
          "title": "Advanced Git",
          "description": "Tools for troubleshooting and complex history management.",
          "briefDescription": "Expert Git tools.",
          "priority": "look",
          "children": [
            { "id": "cherry-pick", "title": "Cherry-Pick", "description": "Apply the changes introduced by some existing commits (by hash) to current branch. Useful for backporting bugfixes to stable branches without merging everything.", "briefDescription": "Selecting specific commits.", "priority": "look" },
            {
              "id": "git-stash",
              "title": "Stash",
              "description": "Temporarily shelves (stashes) changes you've made to your working copy so you can work on something else, and then come back and re-apply them later.",
              "briefDescription": "Shelving temporary changes.",
              "priority": "imp",
              "children": [
                 { "id": "stash-commands", "title": "Commands", "description": "push: Save changes. pop: Apply and remove from stash list. list: Show stashes. apply: Apply but keep. drop: Delete stash. 'git stash -u' includes untracked files.", "briefDescription": "Stash management commands.", "priority": "imp" }
              ]
            },
            { "id": "git-reset", "title": "Git Reset", "description": "Move HEAD to specific state. Soft (--soft): Move HEAD, keep changes staged (good for squashing). Mixed (--mixed): Move HEAD, keep changes unstaged (default). Hard (--hard): Move HEAD, discard ALL changes (dangerous).", "briefDescription": "Moving HEAD pointer.", "priority": "must" },
            { "id": "git-revert", "title": "Git Revert", "description": "Create a new commit that undoes the changes of a previous commit. Safe for public history (unlike reset) because it adds history rather than rewriting it.", "briefDescription": "Undoing commits safely.", "priority": "must" },
            { "id": "git-bisect", "title": "Git Bisect", "description": "Binary search to find the commit that introduced a bug. You mark a 'good' commit and a 'bad' commit, git checks out the middle. You say good/bad, it narrows down. fast debugging.", "briefDescription": "Binary search for bugs.", "priority": "look" },
            { "id": "git-reflog", "title": "Git Reflog", "description": "Reference Log. Records updates to the tip of branches. Allows recovering 'lost' commits (e.g., after a bad reset or rebase). The safety net of git.", "briefDescription": "Recovering lost commits.", "priority": "imp" },
            {
              "id": "git-hooks",
              "title": "Git Hooks",
              "description": "Scripts running at certain points in git execution.",
              "briefDescription": "Automated git scripts.",
              "priority": "look",
              "children": [
                { "id": "pre-commit", "title": "Pre-commit", "description": "Runs before commit. Use 'Husky' and 'lint-staged' to run Linters/Formatters automatically on changed files. Prevents bad code from entering repo.", "briefDescription": "Linting before commit.", "priority": "must" },
                { "id": "commit-msg", "title": "Commit Message Validation", "description": "Verifies commit message format (e.g., Conventional Commits) using 'commitlint'.", "briefDescription": "Enforcing message standards.", "priority": "look" }
              ]
            },
            { "id": "git-tags", "title": "Git Tags", "description": "Marking specific points in history as important, typically for releases (v1.0.0). Semantic Versioning.", "briefDescription": "Release versioning.", "priority": "imp" },
            { "id": "submodules", "title": "Submodules", "description": "Keep a Git repository as a subdirectory of another Git repository. Complex, often replaced by package managers, but useful for shared config repos.", "briefDescription": "Nested repositories.", "priority": "look" }
          ]
        },
        {
          "id": "git-workflows",
          "title": "Workflows",
          "description": "Strategies for team collaboration using branches.",
          "briefDescription": "Collaboration strategies.",
          "priority": "must",
          "children": [
            { "id": "git-flow", "title": "Git Flow", "description": "Strict branching model. Main, Develop, Feature, Release, Hotfix branches. Robust but complex. Good for scheduled release cycles.", "briefDescription": "Structured enterprise workflow.", "priority": "look" },
            { "id": "github-flow", "title": "GitHub Flow", "description": "Simple workflow. Main branch is always deployable. Create branch, commit, open PR, review, merge, deploy. Good for CI/CD and web apps.", "briefDescription": "Simple CI/CD workflow.", "priority": "must" },
            { "id": "trunk-based", "title": "Trunk-Based Development", "description": "Developers merge small, frequent updates to a core 'main' branch (trunk). Avoids long-lived feature branches and merge hell. Requires strong testing/CI.", "briefDescription": "Frequent integration strategy.", "priority": "imp" },
            { "id": "conventional-commits", "title": "Conventional Commits", "description": "Standardized commit messages: 'feat: add login', 'fix: crash on home', 'chore: update deps'. Enables automated changelog generation and semantic versioning.", "briefDescription": "Standardized message format.", "priority": "imp" },
            { "id": "pr-practices", "title": "Pull Request Best Practices", "description": "Small PRs (easy to review), Clear Title/Description, Screenshots for UI changes, Self-review before request, Link to ticket/issue.", "briefDescription": "Effective code submission.", "priority": "must" },
            { "id": "code-review", "title": "Code Review Guidelines", "description": "Reviewer: Be constructive, ask questions, focus on logic/security, not just style (let lint do that). Author: Don't take feedback personally, explain reasoning.", "briefDescription": "Professional review etiquette.", "priority": "must" }
          ]
        }
      ]
    },
    {
      "id": "performance-optimization",
      "title": "Performance Optimization",
      "description": "Performance optimization creates fast, responsive applications that retain users and rank better in search engines. In the MERN stack, this involves a holistic approach: optimizing the React frontend (loading speed, rendering efficiency), tuning the Node.js/Express backend (response time, throughput), and ensuring efficient database interactions. It requires measuring before optimizing (profiling), understanding the cost of network requests, managing memory, and utilizing caching strategies effectively. Performance isn't a one-time fix but a continuous culture.",
      "briefDescription": "Making apps fast and efficient.",
      "priority": "must",
      "children": [
        {
          "id": "frontend-performance",
          "title": "Frontend Performance",
          "description": "Optimizing what the user sees and interacts with. Critical for user experience and SEO.",
          "briefDescription": "Optimizing UI and browser delivery.",
          "priority": "must",
          "children": [
            {
              "id": "core-web-vitals",
              "title": "Core Web Vitals",
              "description": "Google's standard metrics for user experience. Essential for SEO rankings.",
              "briefDescription": "Google's UX metrics.",
              "priority": "must",
              "children": [
                 { "id": "lcp", "title": "LCP (Largest Contentful Paint)", "description": "Measures loading performance. Time until the largest element (hero image, heading) is visible. Good: < 2.5s. Improve by: optimizing images, server response time.", "briefDescription": "Loading speed metric.", "priority": "must" },
                 { "id": "fid-inp", "title": "FID / INP (Interaction to Next Paint)", "description": "Measures interactivity. Time from user action (click) to browser response. INP replaces FID. Good: < 200ms. Improve by: reducing main thread blocking (long JS tasks).", "briefDescription": "Interactivity metric.", "priority": "must" },
                 { "id": "cls", "title": "CLS (Cumulative Layout Shift)", "description": "Measures visual stability. Do elements jump around while loading? Good: < 0.1. Improve by: setting size attributes on images/videos, avoiding inserting ads/content above existing content.", "briefDescription": "Visual stability metric.", "priority": "must" }
              ]
            },
            {
              "id": "bundle-optimization",
              "title": "Bundle Optimization",
              "description": "Reducing the amount of JavaScript sent to the browser.",
              "briefDescription": "Shrinking JS payload.",
              "priority": "must",
              "children": [
                { "id": "code-splitting", "title": "Code Splitting", "description": "Splitting code into smaller distinct chunks that can be loaded on demand. React.lazy() + Suspense allows route-based splitting. Don't load Admin Dashboard code for the Home Page.", "briefDescription": "Loading code on demand.", "priority": "must" },
                { "id": "tree-shaking", "title": "Tree Shaking", "description": "Removing unused code / dead code during build process (webpack/rollup). Ensure you use ES Modules (import/export) so bundlers can detect dependencies.", "briefDescription": "Removing executing unused code.", "priority": "imp" },
                { "id": "dynamic-import", "title": "Dynamic Import", "description": "import() syntax. Load modules only when needed (e.g., heavy chart library loads only when user clicks 'Show Chart').", "briefDescription": "Runtime module loading.", "priority": "imp" },
                { "id": "lazy-loading-components", "title": "Lazy Loading Components", "description": "Deferring loading of non-critical components (below the fold). Reduces initial bundle size. 'const Widget = React.lazy(() => import('./Widget'));'.", "briefDescription": "Deferring component load.", "priority": "must" },
                { "id": "bundle-analysis", "title": "Bundle Analysis", "description": "Using tools like webpack-bundle-analyzer to visualize what's inside your bundle. Identify accidental large libraries (like all of lodash vs just debounce).", "briefDescription": "Visualizing bundle contents.", "priority": "imp" }
              ]
            },
            {
              "id": "image-optimization",
              "title": "Image Optimization",
              "description": "Images often account for the majority of downloaded bytes.",
              "briefDescription": "Reducing image weight.",
              "priority": "must",
              "children": [
                { "id": "lazy-loading-images", "title": "Lazy Loading", "description": "Native attribute processing: <img loading='lazy' />. Browser downloads image only when it enters viewport.", "briefDescription": "Load upon scroll.", "priority": "must" },
                { "id": "responsive-images", "title": "Responsive Images (srcset)", "description": "Serving different image sizes for different screens (mobile vs desktop). <img srcset='small.jpg 500w, large.jpg 1000w' />. Saves bandwidth for mobile users.", "briefDescription": "Right-sized images.", "priority": "must" },
                { "id": "modern-formats", "title": "Modern Formats (WebP, AVIF)", "description": "Using WebP or AVIF instead of JPEG/PNG. Provides better compression with same quality. use <picture> tag for fallbacks.", "briefDescription": "Next-gen file formats.", "priority": "imp" },
                { "id": "image-cdn", "title": "Image CDN", "description": "Services like Cloudinary or Imgix that resize, crop, and optimize images on-the-fly via URL parameters.", "briefDescription": "Dynamic image service.", "priority": "imp" },
                { "id": "sprites-svg", "title": "Sprites & SVG Icons", "description": "Use SVGs for icons (vector, small size). Combine small images into sprites to reduce HTTP requests (less relevant with HTTP/2).", "briefDescription": "Icon optimization.", "priority": "look" }
              ]
            },
            {
              "id": "rendering-performance",
              "title": "Rendering Performance",
              "description": "Ensuring the browser can paint frames at 60fps.",
              "briefDescription": "Smooth UI interactions.",
              "priority": "must",
              "children": [
                { "id": "debounce-throttle", "title": "Debouncing & Throttling", "description": "Debounce: Wait for pause in events (e.g., search typeahead). Throttle: Limit execution frequency (e.g., scroll handler run max once per 100ms).", "briefDescription": "Limiting event frequency.", "priority": "must" },
                { "id": "virtual-scrolling", "title": "Virtual Scrolling", "description": "Rendering only visible items in a long list. Libraries: react-window, react-virtualized. DOM stays small even with 10,000 items.", "briefDescription": "Large list optimization.", "priority": "must" },
                { "id": "request-animation-frame", "title": "requestAnimationFrame", "description": "Scheduling visual updates before next repaint. Better than setTimeout for animations.", "briefDescription": "Syncing with refresh rate.", "priority": "look" },
                { "id": "will-change", "title": "will-change", "description": "CSS property hinting browser about upcoming changes (e.g., transform, opacity). Allows browser to optimize ahead of time. Use sparingly.", "briefDescription": "Performance hint CSS.", "priority": "look" },
                { "id": "layout-thrashing", "title": "Avoiding Layout Thrashing", "description": "Reading and writing DOM dimensions in a loop causes browser to re-calculate layout repeatedly (Reflow). Batch reads and writes separately.", "briefDescription": "Preventing costly reflows.", "priority": "imp" },
                { "id": "css-containment", "title": "CSS Containment", "description": "contain property isolates a subtree from rest of page, speeding up rendering calculations.", "briefDescription": "Isolating render scope.", "priority": "look" }
              ]
            },
            {
              "id": "network-optimization",
              "title": "Network Optimization",
              "description": "Improving how data is fetched.",
              "briefDescription": "Fetch efficiency.",
              "priority": "must",
              "children": [
                { "id": "http2", "title": "HTTP/2 Multiplexing", "description": "Allows multiple requests/responses in parallel over single TCP connection. Eliminates need for domain sharding or specialized concatenation.", "briefDescription": "Parallel requests.", "priority": "must" },
                { "id": "compression", "title": "Compression (gzip, Brotli)", "description": "Compressing text assets (JS, CSS, HTML). Brotli compresses better than gzip. Enable on server/CDN.", "briefDescription": "Shrinking text assets.", "priority": "must" },
                { "id": "preloading", "title": "Preloading & Prefetching", "description": "preload: Download critical asset ASAP (hero image, font). prefetch: Download future asset in background (next page JS).", "briefDescription": "Prioritizing loads.", "priority": "imp" },
                { "id": "resource-hints", "title": "Resource Hints", "description": "preconnect: handshake with domain early. dns-prefetch: resolve DNS early. Speeds up third-party requests.", "briefDescription": "Connection warm-up.", "priority": "look" },
                { "id": "cdn-usage", "title": "CDN Usage", "description": "Content Delivery Networks serve static files from edge locations near users.", "briefDescription": "Edge delivery.", "priority": "must" },
                { "id": "service-workers", "title": "Service Workers", "description": "Scripts running in background. Enable offline capabilities and advanced caching strategies (PWA).", "briefDescription": "Offline & background.", "priority": "imp" }
              ]
            },
            {
              "id": "browser-caching",
              "title": "Caching",
              "description": "The fastest request is the one not made.",
              "briefDescription": "Storage strategies.",
              "priority": "must",
              "children": [
                 { "id": "cache-control", "title": "Browser Cache", "description": "Cache-Control header defines how long browser keeps file (max-age). ETag allows revalidation (304 Not Modified) if file unchanged. Immutable assets can have long cache time.", "briefDescription": "HTTP cache headers.", "priority": "must" },
                 { "id": "sw-cache", "title": "Service Worker Cache", "description": "Programmatic control over caching via Cache API. Cache-First, Network-First, Stale-While-Revalidate strategies.", "briefDescription": "Programmatic caching.", "priority": "imp" }
              ]
            }
          ]
        },
        {
          "id": "backend-performance",
          "title": "Backend Performance",
          "description": "Optimizing server-side execution and data handling to handle high concurrency and reduce latency.",
          "briefDescription": "Server & DB speed.",
          "priority": "must",
          "children": [
            {
              "id": "db-query-optimization",
              "title": "Database Query Optimization",
              "description": "Database is often the bottleneck.",
              "briefDescription": "Speeding up data retrieval.",
              "priority": "must",
              "children": [
                { "id": "db-indexing", "title": "Indexing", "description": "Adding indexes to frequently queried fields. Without them, MongoDB sets scan every document.", "briefDescription": "Fast data lookup.", "priority": "must" },
                { "id": "query-profiling", "title": "Query Profiling (explain)", "description": "Using .explain('executionStats') to see if query uses index (IXSCAN) or full scan (COLLSCAN) and time taken.", "briefDescription": "Analyzing query plans.", "priority": "must" },
                { "id": "n-plus-1", "title": "Avoiding N+1 Queries", "description": "Fetching a parent, then running a loop to fetch unrelated children individually. 1 + N queries. Fix with $lookup (aggregation) or population optimized.", "briefDescription": "Batching database calls.", "priority": "must" },
                { "id": "projection", "title": "Projection", "description": "Selecting only necessary fields ({ name: 1, email: 1 }). Reduces network payload and deserialization cost.", "briefDescription": "Fetching only needed fields.", "priority": "imp" },
                { "id": "lean-queries", "title": "Lean Queries (Mongoose)", "description": "Using .lean() returns plain JS objects instead of heavy Mongoose Documents. Skips hydration, validation, getters. 5-10x faster for read-only data.", "briefDescription": "Faster Mongoose reads.", "priority": "must" }
              ]
            },
            { "id": "connection-pooling-perf", "title": "Connection Pooling", "description": "Maintaining a pool of kept-alive DB connections to reuse, avoiding handshake overhead.", "briefDescription": "Reusing expensive connections.", "priority": "imp" },
            { "id": "caching-redis-perf", "title": "Caching (Redis)", "description": "Cache expensive query results or API responses in Redis. Serve subsequent requests from RAM.", "briefDescription": "In-memory caching.", "priority": "must" },
            { "id": "response-compression", "title": "Response Compression", "description": "Using compression middleware in Express. Reduces JSON response size typically by 60-80%.", "briefDescription": "Gzipping API responses.", "priority": "must" },
            { "id": "pagination-perf", "title": "Pagination", "description": "Never return 'all' records. Limit large datasets. Cursor-based is faster than Offset-based for large sets.", "briefDescription": "Limiting result sets.", "priority": "must" },
            { "id": "worker-threads", "title": "Worker Threads", "description": "Offloading CPU-intensive tasks (image processing, crypto) to Worker Threads to avoid blocking the Node.js Event Loop.", "briefDescription": "Parallel CPU execution.", "priority": "imp" },
            { "id": "stream-processing", "title": "Stream Processing", "description": "Processing large files (uploads/downloads) chunk-by-chunk using Streams instead of buffering entire file in memory.", "briefDescription": "Memory-efficient data handling.", "priority": "imp" },
            { "id": "load-balancing-perf", "title": "Load Balancing", "description": "Distributing traffic to horizontally scaled instances to utilize multiple CPU cores/servers.", "briefDescription": "Distributing work.", "priority": "must" }
          ]
        },
        {
          "id": "profiling-tools-perf",
          "title": "Profiling Tools",
          "description": "Tools to measure and identify bottlenecks.",
          "briefDescription": "Measurement utilities.",
          "priority": "must",
          "children": [
            { "id": "chrome-devtools-perf", "title": "Chrome DevTools", "description": "Performance Tab (CPU/Rendering flame charts), Memory (Heap snapshots for leaks), Network (Waterfall).", "briefDescription": "Browser built-in profiler.", "priority": "must" },
            { "id": "lighthouse", "title": "Lighthouse", "description": "Automated audit for Performance, Accessibility, SEO. Gives scores and actionable advice.", "briefDescription": "Site auditing tool.", "priority": "must" },
            { "id": "react-devtools-profiler", "title": "React DevTools Profiler", "description": "Records component renders. Shows 'Why did this render?' and render duration. Identifies unnecessary re-renders.", "briefDescription": "Component render analysis.", "priority": "must" },
            { "id": "nodejs-profiling", "title": "Node.js Profiling", "description": "Tools like clinic.js (Doctor, Flame, Bubble) or 0x to visualize Event Loop lag, CPU hotspots, and I/O bottlenecks.", "briefDescription": "Server performance analysis.", "priority": "look" },
            { "id": "webpack-analyzer", "title": "webpack-bundle-analyzer", "description": "Visualizes size of output files.", "briefDescription": "Bundle size visualizer.", "priority": "imp" }
          ]
        }
      ]
    },
    {
      "id": "behavioral-hr",
      "title": "Behavioral & HR Round",
      "description": "Technical skills get you the interview, soft skills get you the job. This round assesses cultural fit, communication, adaptability, and emotional intelligence. Interviewers want to know: Can I work with this person? Do they handle conflict well? Are they passionate? Prepare stories, be genuine, and show self-awareness. Never underestimate this round - a 'No Hire' here vetoes a 'Strong Yes' in technical rounds.",
      "briefDescription": "Soft skills and culture fit.",
      "priority": "must",
      "children": [
        {
          "id": "common-hr-questions",
          "title": "Common Questions",
          "description": "Standard non-technical questions. Prepare 2-minute answers for each.",
          "briefDescription": "Standard interview questions.",
          "priority": "must",
          "children": [
            { "id": "tell-me-about-yourself", "title": "Tell Me About Yourself", "description": "The elevator pitch. Past (School/Background), Present (Current Role/Tech Stack), Future (Why here/Goals). Keep it relevant to the role.", "briefDescription": "Elevator pitch.", "priority": "must" },
            { "id": "why-this-company", "title": "Why This Company?", "description": "Show you did research. Mention their mission, specific products, engineering culture, or recent news. Don't just say 'good salary'.", "briefDescription": "Research and motivation.", "priority": "must" },
            { "id": "strengths-weaknesses", "title": "Strengths & Weaknesses", "description": "Strengths: Relevant to job (e.g., 'Quick learner', 'detail-oriented'). Weakness: Real but resolvable (e.g., 'Public speaking, so I joined Toastmasters', 'Delegating, but I'm using Trello/Jira to improve'). No 'I work too hard'.", "briefDescription": "Self-awareness check.", "priority": "must" },
            { "id": "five-years", "title": "Where Do You See Yourself in 5 Years?", "description": "Show ambition but loyalty. 'Growing into a Senior Engineer / Architect role where I can mentor others and lead technical decisions'.", "briefDescription": "Career trajectory.", "priority": "imp" },
            { "id": "why-leaving", "title": "Why Are You Leaving?", "description": "Stay positive. Move 'towards' opportunity (growth, new challenges, tech stack), not 'away' from bad boss/company. Never badmouth current employer.", "briefDescription": "Reason for transition.", "priority": "must" },
            { "id": "challenge-faced", "title": "Describe a Challenge You Faced", "description": "Use STAR method. Technical challenge (bug, scaling issue) or timeline pressure.", "briefDescription": "Problem-solving story.", "priority": "must" },
            { "id": "conflict-teammate", "title": "Describe a Conflict with a Teammate", "description": "Focus on resolution. 'We disagreed on approach A vs B. I listened to their side, we compared pros/cons, we compromised or I realized they were right.' Show maturity, not drama.", "briefDescription": "Conflict resolution story.", "priority": "must" },
            { "id": "proud-project", "title": "Describe a Project You're Proud Of", "description": "Highlight YOUR contribution. 'I built X using Y which solved Z problem'. Mention metrics/impact if possible.", "briefDescription": "Portfolio highlight.", "priority": "must" }
          ]
        },
        {
          "id": "star-method",
          "title": "STAR Method",
          "description": "Structure for answering behavioral questions effectively.",
          "briefDescription": "Storytelling framework.",
          "priority": "must",
          "children": [
            { "id": "star-situation", "title": "Situation", "description": "Set the scene and provide necessary details of your example.", "priority": "must" },
            { "id": "star-task", "title": "Task", "description": "Describe what your responsibility was in that situation.", "priority": "must" },
            { "id": "star-action", "title": "Action", "description": "Explain exactly what steps YOU took to address it.", "priority": "must" },
            { "id": "star-result", "title": "Result", "description": "Share what outcomes your actions achieved (quantify if possible).", "priority": "must" }
          ]
        },
        {
          "id": "technical-communication",
          "title": "Technical Communication",
          "description": "Ability to explain complex ideas clearly is as important as coding skills.",
          "briefDescription": "Clarity in explanation.",
          "priority": "must",
          "children": [
            { "id": "explain-concepts", "title": "Explaining to Non-Tech", "description": "Use analogies. Avoid jargon. Focus on 'Why' and 'Impact' rather than 'How'.", "briefDescription": "Simplifying complexity.", "priority": "imp" },
            { "id": "whiteboard-solving", "title": "Whiteboard Problem Solving", "description": "It's about the process, not just syntax. Clarify requirements, plan solution, write code, test/dry-run.", "briefDescription": "Live coding approach.", "priority": "must" },
            { "id": "think-out-loud", "title": "Think Out Loud", "description": "Let interviewer hear your mental process. 'I'm thinking of using a HashMap for O(1) lookups...'. Silence is bad.", "briefDescription": "Vocalizing thought process.", "priority": "must" },
            { "id": "clarifying-questions", "title": "Asking Clarifying Questions", "description": "Don't assume. 'How large is the input?', 'Can there be duplicates?', 'Do we need to handle mobile?'. Shows senior mindset.", "briefDescription": "Defining scope.", "priority": "must" },
            { "id": "handling-unknown", "title": "Handling 'I Don't Know'", "description": "Be honest. Say 'I haven't used that specifically, but based on my experience with X, I assume it works like...'. Offer to look it up.", "briefDescription": "Honesty and adaptability.", "priority": "must" }
          ]
        },
        {
          "id": "culture-fit",
          "title": "Culture & Work Style",
          "description": "Aligning with the team's way of working.",
          "briefDescription": "Organizational fit.",
          "priority": "must",
          "children": [
            { "id": "agile-exp", "title": "Agile/Scrum Experience", "description": "Familiarity with Sprints, Stand-ups, Retro, Jira/Linear. Iterative delivery.", "briefDescription": "Agile methodology.", "priority": "must" },
            { "id": "remote-exp", "title": "Remote Work Experience", "description": "Self-discipline, asynchronous communication, over-communication in Slack/Teams.", "briefDescription": "Remote collaboration.", "priority": "imp" },
            { "id": "team-collab", "title": "Team Collaboration", "description": "Pair programming, helping others, being unblocked.", "briefDescription": "Working with others.", "priority": "must" },
            { "id": "code-review-culture", "title": "Code Review Culture", "description": "Viewing reviews as learning, not criticism. Giving constructive feedback.", "briefDescription": "Feedback mindset.", "priority": "must" },
            { "id": "continuous-learning", "title": "Continuous Learning", "description": "How do you stay updated? (Blogs, YouTube, Podcasts, Side projects). Shows passion.", "briefDescription": "Growth mindset.", "priority": "must" }
          ]
        },
        {
          "id": "salary-negotiation",
          "title": "Salary Negotiation",
          "description": "Business side of the interview.",
          "briefDescription": "Comp negotiation.",
          "priority": "look",
          "children": [
            { "id": "market-research", "title": "Market Research", "description": "Know your worth. Use levels.fyi, Glassdoor. Know rate for location/experience.", "briefDescription": "Knowing your value.", "priority": "look" },
            { "id": "total-comp", "title": "Total Compensation", "description": "Look beyond base salary. Bonus, Equity (RSUs/Options), Benefits, PTO, Remote stipend.", "briefDescription": "Full package value.", "priority": "look" },
            { "id": "counter-offer", "title": "Counter-Offer Strategy", "description": "Polite negotiation. 'I'm excited about the role. Based on market and other offers, I was looking for X range'.", "briefDescription": "Negotiation tactics.", "priority": "look" }
          ]
        }
      ]
    }
  ]
}
